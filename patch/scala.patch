diff --git a/src/api/video_codecs/builtin_video_encoder_factory.cc b/src/api/video_codecs/builtin_video_encoder_factory.cc
index 573eb47..fada36f 100644
--- a/src/api/video_codecs/builtin_video_encoder_factory.cc
+++ b/src/api/video_codecs/builtin_video_encoder_factory.cc
@@ -13,6 +13,7 @@
 #include <memory>
 #include <string>
 #include <vector>
+#include <android/log.h>
 
 #include "absl/strings/match.h"
 #include "absl/types/optional.h"
@@ -50,6 +51,7 @@ class BuiltinVideoEncoderFactory : public VideoEncoderFactory {
   }
 
   std::vector<SdpVideoFormat> GetSupportedFormats() const override {
+  __android_log_print(ANDROID_LOG_ERROR, "HORSE", "%s", "NOPE");
     return internal_encoder_factory_->GetSupportedFormats();
   }
 
diff --git a/src/api/video_codecs/video_decoder_factory_template.h b/src/api/video_codecs/video_decoder_factory_template.h
index 703ae11..227ec0b 100644
--- a/src/api/video_codecs/video_decoder_factory_template.h
+++ b/src/api/video_codecs/video_decoder_factory_template.h
@@ -39,6 +39,7 @@ template <typename... Ts>
 class VideoDecoderFactoryTemplate : public VideoDecoderFactory {
  public:
   std::vector<SdpVideoFormat> GetSupportedFormats() const override {
+    __android_log_print(ANDROID_LOG_ERROR, "HORSE2", "%s", "NOPE");
     return GetSupportedFormatsInternal<Ts...>();
   }
 
@@ -60,12 +61,14 @@ class VideoDecoderFactoryTemplate : public VideoDecoderFactory {
 
   template <typename V, typename... Vs>
   std::vector<SdpVideoFormat> GetSupportedFormatsInternal() const {
+    __android_log_print(ANDROID_LOG_ERROR, "HORSE3", "%s", "NOPE")
     auto supported_formats = V::SupportedFormats();
 
     if constexpr (sizeof...(Vs) > 0) {
       // Supported formats may overlap between implementations, so duplicates
       // should be filtered out.
       for (const auto& other_format : GetSupportedFormatsInternal<Vs...>()) {
+        __android_log_print(ANDROID_LOG_ERROR, "HORSE4", "%s", "NOPE")
         if (!IsFormatInList(other_format, supported_formats)) {
           supported_formats.push_back(other_format);
         }
diff --git a/src/api/video_codecs/video_encoder_factory_template.h b/src/api/video_codecs/video_encoder_factory_template.h
index 10212ac..44f61a7 100644
--- a/src/api/video_codecs/video_encoder_factory_template.h
+++ b/src/api/video_codecs/video_encoder_factory_template.h
@@ -14,6 +14,7 @@
 #include <memory>
 #include <string>
 #include <vector>
+#include <android/log.h>
 
 #include "absl/algorithm/container.h"
 #include "api/array_view.h"
@@ -47,6 +48,7 @@ template <typename... Ts>
 class VideoEncoderFactoryTemplate : public VideoEncoderFactory {
  public:
   std::vector<SdpVideoFormat> GetSupportedFormats() const override {
+    __android_log_print(ANDROID_LOG_ERROR, "HOPE", "%s", "NOPE")
     return GetSupportedFormatsInternal<Ts...>();
   }
 
@@ -95,12 +97,14 @@ class VideoEncoderFactoryTemplate : public VideoEncoderFactory {
 
   template <typename V, typename... Vs>
   std::vector<SdpVideoFormat> GetSupportedFormatsInternal() const {
+    __android_log_print(ANDROID_LOG_ERROR, "HOPE2", "%s", "NOPE")
     auto supported_formats = V::SupportedFormats();
 
     if constexpr (sizeof...(Vs) > 0) {
       // Supported formats may overlap between implementations, so duplicates
       // should be filtered out.
       for (const auto& other_format : GetSupportedFormatsInternal<Vs...>()) {
+    __android_log_print(ANDROID_LOG_ERROR, "HOPE3", "%s", "NOPE")
         if (!IsFormatInList(other_format, supported_formats)) {
           supported_formats.push_back(other_format);
         }
diff --git a/src/api/video_codecs/video_encoder_factory_template_libvpx_vp8_adapter.h b/src/api/video_codecs/video_encoder_factory_template_libvpx_vp8_adapter.h
index 0f0a9ba..a2d608b 100644
--- a/src/api/video_codecs/video_encoder_factory_template_libvpx_vp8_adapter.h
+++ b/src/api/video_codecs/video_encoder_factory_template_libvpx_vp8_adapter.h
@@ -18,6 +18,7 @@
 #include "api/video_codecs/sdp_video_format.h"
 #include "modules/video_coding/codecs/vp8/include/vp8.h"
 #include "modules/video_coding/codecs/vp8/vp8_scalability.h"
+#include <android/log.h>
 
 namespace webrtc {
 struct LibvpxVp8EncoderTemplateAdapter {
@@ -26,6 +27,9 @@ struct LibvpxVp8EncoderTemplateAdapter {
         scalability_modes;
     for (const auto scalability_mode : kVP8SupportedScalabilityModes) {
       scalability_modes.push_back(scalability_mode);
+        auto sv2 = ScalabilityModeToString(scalability_mode);
+        std::string s2 = {sv2.begin(), sv2.end()};
+        __android_log_print(ANDROID_LOG_ERROR, "LibvpxVp8EncoderTemplateAdapter", "%s", s2.c_str());
     }
 
     return {
diff --git a/src/media/base/media_engine.cc b/src/media/base/media_engine.cc
index 7304ab0..e69e712 100644
--- a/src/media/base/media_engine.cc
+++ b/src/media/base/media_engine.cc
@@ -15,6 +15,9 @@
 #include <cstdint>
 #include <string>
 #include <utility>
+#include <sstream>
+#include <iostream>
+#include <android/log.h>
 
 #include "absl/algorithm/container.h"
 #include "api/video/video_bitrate_allocation.h"
@@ -95,10 +98,22 @@ webrtc::RTCError CheckScalabilityModeValues(
       }
     }
     if (rtp_parameters.encodings[i].scalability_mode) {
+        std::stringstream ss;
       if (!send_codec) {
-        bool scalabilityModeFound = false;
-        for (const cricket::VideoCodec& codec : codec_preferences) {
-          for (const auto& scalability_mode : codec.scalability_modes) {
+         bool scalabilityModeFound = false;
+        __android_log_print(ANDROID_LOG_ERROR, "codec_preferences", "%lu", (unsigned long) codec_preferences.size());
+         for (const cricket::VideoCodec& codec : codec_preferences) {
+        __android_log_print(ANDROID_LOG_ERROR, "codec", "|%s|", codec.name.c_str());
+        __android_log_print(ANDROID_LOG_ERROR, "codec_preferences.scalability_modes", "%lu", (unsigned long) codec.scalability_modes.size());
+           for (const auto& scalability_mode : codec.scalability_modes) {
+        auto sv = *rtp_parameters.encodings[i].scalability_mode; auto sv2 = ScalabilityModeToString(scalability_mode);
+        std::string s = {sv.begin(), sv.end()}; std::string s2 = {sv2.begin(), sv2.end()};
+        __android_log_print(ANDROID_LOG_ERROR, "scalability_mode", "|%s|", s2.c_str());
+        __android_log_print(ANDROID_LOG_ERROR, "scalability_mode2", "|%s|", s.c_str());
+
+
+          ss << "\nscalability_mode" << ScalabilityModeToString(scalability_mode) << "-" << *rtp_parameters.encodings[i].scalability_mode;
+
             if (ScalabilityModeToString(scalability_mode) ==
                 *rtp_parameters.encodings[i].scalability_mode) {
               scalabilityModeFound = true;
@@ -110,14 +125,24 @@ webrtc::RTCError CheckScalabilityModeValues(
         }
 
         if (!scalabilityModeFound) {
+        __android_log_print(ANDROID_LOG_ERROR, "AAAAA42", "%s", ss.str().c_str());
+          std::cout << ss.str() << std::endl;
           LOG_AND_RETURN_ERROR(
               RTCErrorType::INVALID_MODIFICATION,
               "Attempted to set RtpParameters scalabilityMode "
               "to an unsupported value for the current codecs.");
         }
       } else {
+          ss << "\nsend_codec";
+
         bool scalabilityModeFound = false;
         for (const auto& scalability_mode : send_codec->scalability_modes) {
+          ss << "\nscalability_mode" << ScalabilityModeToString(scalability_mode) << "-" << *rtp_parameters.encodings[i].scalability_mode;
+        auto sv = *rtp_parameters.encodings[i].scalability_mode; auto sv2 = ScalabilityModeToString(scalability_mode);
+        std::string s = {sv.begin(), sv.end()}; std::string s2 = {sv2.begin(), sv2.end()};
+        __android_log_print(ANDROID_LOG_ERROR, "scalability_mode", "|%s|", s2.c_str());
+        __android_log_print(ANDROID_LOG_ERROR, "scalability_mode2", "|%s|", s.c_str());
+
           if (ScalabilityModeToString(scalability_mode) ==
               *rtp_parameters.encodings[i].scalability_mode) {
             scalabilityModeFound = true;
@@ -125,6 +150,8 @@ webrtc::RTCError CheckScalabilityModeValues(
           }
         }
         if (!scalabilityModeFound) {
+        __android_log_print(ANDROID_LOG_ERROR, "AAAAA422", "%s", ss.str().c_str());
+          std::cout << ss.str() << std::endl;
           LOG_AND_RETURN_ERROR(
               RTCErrorType::INVALID_MODIFICATION,
               "Attempted to set RtpParameters scalabilityMode "
diff --git a/src/media/engine/webrtc_video_engine.cc b/src/media/engine/webrtc_video_engine.cc
index 91750b8..c63ced1 100644
--- a/src/media/engine/webrtc_video_engine.cc
+++ b/src/media/engine/webrtc_video_engine.cc
@@ -19,6 +19,7 @@
 #include <string>
 #include <type_traits>
 #include <utility>
+#include <android/log.h>
 
 #include "absl/algorithm/container.h"
 #include "absl/container/inlined_vector.h"
@@ -179,7 +180,10 @@ std::vector<VideoCodec> GetPayloadTypesAndDefaultCodecs(
     bool is_decoder_factory,
     bool include_rtx,
     const webrtc::FieldTrialsView& trials) {
+
+  __android_log_print(ANDROID_LOG_ERROR, "GetPayloadTypesAndDefaultCodecs", "%s", "GetPayloadTypesAndDefaultCodecs");
   if (!factory) {
+  __android_log_print(ANDROID_LOG_ERROR, "GetPayloadTypesAndDefaultCodecs", "%s", "NOPE");
     return {};
   }
 
@@ -219,6 +223,8 @@ std::vector<VideoCodec> GetPayloadTypesAndDefaultCodecs(
 
   std::vector<VideoCodec> output_codecs;
   for (const webrtc::SdpVideoFormat& format : supported_formats) {
+  __android_log_print(ANDROID_LOG_ERROR, "GetPayloadTypesAndDefaultCodecs", "%s %lu", format.name.c_str(), (unsigned long) format.scalability_modes.size());
+
     VideoCodec codec = cricket::CreateVideoCodec(format);
     bool isFecCodec = absl::EqualsIgnoreCase(codec.name, kUlpfecCodecName) ||
                       absl::EqualsIgnoreCase(codec.name, kFlexfecCodecName);
diff --git a/src/modules/video_coding/codecs/av1/av1_svc_config.cc b/src/modules/video_coding/codecs/av1/av1_svc_config.cc
index 30c0f30..325bc4e 100644
--- a/src/modules/video_coding/codecs/av1/av1_svc_config.cc
+++ b/src/modules/video_coding/codecs/av1/av1_svc_config.cc
@@ -20,6 +20,7 @@
 #include "rtc_base/checks.h"
 #include "rtc_base/logging.h"
 #include "rtc_base/strings/string_builder.h"
+#include <android/log.h>
 
 namespace webrtc {
 namespace {
@@ -58,6 +59,9 @@ LibaomAv1EncoderSupportedScalabilityModes() {
   for (ScalabilityMode scalability_mode : kAllScalabilityModes) {
     if (ScalabilityStructureConfig(scalability_mode) != absl::nullopt) {
       scalability_modes.push_back(scalability_mode);
+              auto sv2 = ScalabilityModeToString(scalability_mode);
+        std::string s2 = {sv2.begin(), sv2.end()};
+        __android_log_print(ANDROID_LOG_ERROR, "LibaomAv1EncoderSupportedScalabilityModes", "%s", s2.c_str());
     }
   }
   return scalability_modes;
diff --git a/src/modules/video_coding/codecs/h264/h264.cc b/src/modules/video_coding/codecs/h264/h264.cc
index 5b9f033..177b8e3 100644
--- a/src/modules/video_coding/codecs/h264/h264.cc
+++ b/src/modules/video_coding/codecs/h264/h264.cc
@@ -19,6 +19,7 @@
 #include "api/video_codecs/sdp_video_format.h"
 #include "media/base/media_constants.h"
 #include "rtc_base/trace_event.h"
+#include <android/log.h>
 
 #if defined(WEBRTC_USE_H264)
 #include "modules/video_coding/codecs/h264/h264_decoder_impl.h"
@@ -61,6 +62,9 @@ SdpVideoFormat CreateH264Format(H264Profile profile,
   if (add_scalability_modes) {
     for (const auto scalability_mode : kSupportedScalabilityModes) {
       scalability_modes.push_back(scalability_mode);
+              auto sv2 = ScalabilityModeToString(scalability_mode);
+        std::string s2 = {sv2.begin(), sv2.end()};
+        __android_log_print(ANDROID_LOG_ERROR, "H264ProfileLevelIdToString", "%s", s2.c_str());
     }
   }
   return SdpVideoFormat(
diff --git a/src/modules/video_coding/codecs/vp9/vp9.cc b/src/modules/video_coding/codecs/vp9/vp9.cc
index c1dbf3a..2a810be 100644
--- a/src/modules/video_coding/codecs/vp9/vp9.cc
+++ b/src/modules/video_coding/codecs/vp9/vp9.cc
@@ -25,6 +25,7 @@
 #include "vpx/vp8cx.h"
 #include "vpx/vp8dx.h"
 #include "vpx/vpx_codec.h"
+#include <android/log.h>
 
 namespace webrtc {
 
@@ -43,6 +44,9 @@ std::vector<SdpVideoFormat> SupportedVP9Codecs(bool add_scalability_modes) {
     for (const auto scalability_mode : kAllScalabilityModes) {
       if (ScalabilityStructureConfig(scalability_mode).has_value()) {
         scalability_modes.push_back(scalability_mode);
+                auto sv2 = ScalabilityModeToString(scalability_mode);
+        std::string s2 = {sv2.begin(), sv2.end()};
+        __android_log_print(ANDROID_LOG_ERROR, "SupportedVP9Codecs", "%s", s2.c_str());
       }
     }
   }
diff --git a/src/pc/rtp_sender.cc b/src/pc/rtp_sender.cc
index cdae159..f7827da 100644
--- a/src/pc/rtp_sender.cc
+++ b/src/pc/rtp_sender.cc
@@ -237,6 +237,7 @@ void RtpSenderBase::SetParametersInternal(const RtpParameters& parameters,
   RTC_DCHECK_RUN_ON(signaling_thread_);
   RTC_DCHECK(!stopped_);
 
+  // nope2
   if (UnimplementedRtpParameterHasValue(parameters)) {
     RTCError error(
         RTCErrorType::UNSUPPORTED_PARAMETER,
@@ -247,6 +248,7 @@ void RtpSenderBase::SetParametersInternal(const RtpParameters& parameters,
     return;
   }
   if (!media_channel_ || !ssrc_) {
+    // nope3
     auto result = cricket::CheckRtpParametersInvalidModificationAndValues(
         init_parameters_, parameters, codec_preferences_, absl::nullopt);
     if (result.ok()) {
@@ -265,6 +267,7 @@ void RtpSenderBase::SetParametersInternal(const RtpParameters& parameters,
                                              old_parameters.encodings);
     }
 
+    // nope4
     RTCError result = cricket::CheckRtpParametersInvalidModificationAndValues(
         old_parameters, rtp_parameters);
     if (!result.ok()) {
@@ -272,6 +275,8 @@ void RtpSenderBase::SetParametersInternal(const RtpParameters& parameters,
       return;
     }
 
+    // nope ?
+
     result = CheckCodecParameters(rtp_parameters);
     if (!result.ok()) {
       webrtc::InvokeSetParametersCallback(callback, result);
@@ -353,7 +358,8 @@ RTCError RtpSenderBase::CheckCodecParameters(const RtpParameters& parameters) {
       send_codec_with_svc_info = *codec_match;
     }
   }
-
+  
+  // here
   return cricket::CheckScalabilityModeValues(parameters, codec_preferences_,
                                              send_codec_with_svc_info);
 }
@@ -364,6 +370,7 @@ RTCError RtpSenderBase::SetParameters(const RtpParameters& parameters) {
   RTCError result = CheckSetParameters(parameters);
   if (!result.ok())
     return result;
+  // nope
 
   // Some tests rely on working in single thread mode without a run loop and a
   // blocking call is required to keep them working. The encoder configuration
diff --git a/src/pc/rtp_sender.h b/src/pc/rtp_sender.h
index d29c376..1a7c34c 100644
--- a/src/pc/rtp_sender.h
+++ b/src/pc/rtp_sender.h
@@ -21,6 +21,7 @@
 #include <memory>
 #include <string>
 #include <vector>
+#include <android/log.h>
 
 #include "absl/types/optional.h"
 #include "api/crypto/frame_encryptor_interface.h"
@@ -225,6 +226,22 @@ class RtpSenderBase : public RtpSenderInternal, public ObserverInterface {
 
   void SetCodecPreferences(
       std::vector<cricket::Codec> codec_preferences) override {
+    __android_log_print(ANDROID_LOG_ERROR, "SetCodecPreferences", "%lu",
+                        (unsigned long)codec_preferences.size());
+    for (size_t i = 0; i < codec_preferences.size(); ++i) {
+      __android_log_print(
+          ANDROID_LOG_ERROR, "SetCodecPreferences scalability_modes", "%lu",
+          (unsigned long)codec_preferences[i].scalability_modes.size());
+
+      for (size_t j = 0; j < codec_preferences[i].scalability_modes.size(); ++j) {
+        auto sv =
+            ScalabilityModeToString(codec_preferences[i].scalability_modes[j]);
+        std::string s = {sv.begin(), sv.end()};
+
+        __android_log_print(ANDROID_LOG_ERROR, "SetCodecPreferences MOD", "%s",
+                            s.c_str());
+      }
+    }
     codec_preferences_ = codec_preferences;
   }
 
diff --git a/src/pc/rtp_transceiver.cc b/src/pc/rtp_transceiver.cc
index 815ec9d..0e69e96 100644
--- a/src/pc/rtp_transceiver.cc
+++ b/src/pc/rtp_transceiver.cc
@@ -17,6 +17,7 @@
 #include <string>
 #include <utility>
 #include <vector>
+#include <android/log.h>
 
 #include "absl/algorithm/container.h"
 #include "absl/memory/memory.h"
@@ -171,6 +172,28 @@ RtpTransceiver::RtpTransceiver(
   RTC_DCHECK(media_type_ == cricket::MEDIA_TYPE_AUDIO ||
              media_type_ == cricket::MEDIA_TYPE_VIDEO);
   RTC_DCHECK_EQ(sender->media_type(), receiver->media_type());
+
+{
+  auto aa = media_engine()->video().send_codecs(false);
+
+      __android_log_print(ANDROID_LOG_ERROR, "RtpTransceiver", "%lu",
+                        (unsigned long)aa.size());
+    for (size_t i = 0; i < aa.size(); ++i) {
+      __android_log_print(
+          ANDROID_LOG_ERROR, "RtpTransceiver scalability_modes", "%lu",
+          (unsigned long)aa[i].scalability_modes.size());
+
+      for (size_t j = 0; j < aa[i].scalability_modes.size(); ++j) {
+        auto sv =
+            ScalabilityModeToString(aa[i].scalability_modes[j]);
+        std::string s = {sv.begin(), sv.end()};
+
+        __android_log_print(ANDROID_LOG_ERROR, "RtpTransceiver MOD", "%s",
+                            s.c_str());
+      }
+    }
+}
+
   sender->internal()->SetCodecPreferences(
       sender->media_type() == cricket::MEDIA_TYPE_VIDEO
           ? media_engine()->video().send_codecs(false)
diff --git a/src/sdk/BUILD.gn b/src/sdk/BUILD.gn
index 4f5ceb5..a743579 100644
--- a/src/sdk/BUILD.gn
+++ b/src/sdk/BUILD.gn
@@ -991,6 +991,15 @@ if (is_ios || is_mac) {
         "objc/api/peerconnection/RTCRtcpParameters+Private.h",
         "objc/api/peerconnection/RTCRtcpParameters.h",
         "objc/api/peerconnection/RTCRtcpParameters.mm",
+        "objc/api/peerconnection/RTCRtpCapabilities.h",
+        "objc/api/peerconnection/RTCRtpCapabilities.mm",
+        "objc/api/peerconnection/RTCRtpCapabilities+Private.h",
+        "objc/api/peerconnection/RTCRtpCodecCapability.h",
+        "objc/api/peerconnection/RTCRtpCodecCapability.mm",
+        "objc/api/peerconnection/RTCRtpCodecCapability+Private.h",
+        "objc/api/peerconnection/RTCRtpHeaderExtensionCapability.h",
+        "objc/api/peerconnection/RTCRtpHeaderExtensionCapability.mm",
+        "objc/api/peerconnection/RTCRtpHeaderExtensionCapability+Private.h",
         "objc/api/peerconnection/RTCRtpCodecParameters+Private.h",
         "objc/api/peerconnection/RTCRtpCodecParameters.h",
         "objc/api/peerconnection/RTCRtpCodecParameters.mm",
@@ -1309,6 +1318,9 @@ if (is_ios || is_mac) {
           "objc/api/peerconnection/RTCPeerConnectionFactory.h",
           "objc/api/peerconnection/RTCPeerConnectionFactoryOptions.h",
           "objc/api/peerconnection/RTCRtcpParameters.h",
+          "objc/api/peerconnection/RTCRtpCapabilities.h",
+          "objc/api/peerconnection/RTCRtpCodecCapability.h",
+          "objc/api/peerconnection/RTCRtpHeaderExtensionCapability.h",
           "objc/api/peerconnection/RTCRtpCodecParameters.h",
           "objc/api/peerconnection/RTCRtpEncodingParameters.h",
           "objc/api/peerconnection/RTCRtpHeaderExtension.h",
@@ -1423,6 +1435,9 @@ if (is_ios || is_mac) {
           "objc/api/peerconnection/RTCPeerConnectionFactory.h",
           "objc/api/peerconnection/RTCPeerConnectionFactoryOptions.h",
           "objc/api/peerconnection/RTCRtcpParameters.h",
+          "objc/api/peerconnection/RTCRtpCapabilities.h",
+          "objc/api/peerconnection/RTCRtpCodecCapability.h",
+          "objc/api/peerconnection/RTCRtpHeaderExtensionCapability.h",
           "objc/api/peerconnection/RTCRtpCodecParameters.h",
           "objc/api/peerconnection/RTCRtpEncodingParameters.h",
           "objc/api/peerconnection/RTCRtpHeaderExtension.h",
diff --git a/src/sdk/android/api/org/webrtc/HardwareVideoEncoderFactory.java b/src/sdk/android/api/org/webrtc/HardwareVideoEncoderFactory.java
index d43fc27..478035e 100644
--- a/src/sdk/android/api/org/webrtc/HardwareVideoEncoderFactory.java
+++ b/src/sdk/android/api/org/webrtc/HardwareVideoEncoderFactory.java
@@ -133,6 +133,8 @@ public class HardwareVideoEncoderFactory implements VideoEncoderFactory {
     List<VideoCodecInfo> supportedCodecInfos = new ArrayList<VideoCodecInfo>();
     // Generate a list of supported codecs in order of preference:
     // VP8, VP9, H264 (high profile), H264 (baseline profile), AV1 and H265.
+
+    // tut?
     for (VideoCodecMimeType type :
         new VideoCodecMimeType[] {VideoCodecMimeType.VP8, VideoCodecMimeType.VP9,
             VideoCodecMimeType.H264, VideoCodecMimeType.AV1, VideoCodecMimeType.H265}) {
@@ -141,13 +143,82 @@ public class HardwareVideoEncoderFactory implements VideoEncoderFactory {
         String name = type.name();
         // TODO(sakal): Always add H264 HP once WebRTC correctly removes codecs that are not
         // supported by the decoder.
+
         if (type == VideoCodecMimeType.H264 && isH264HighProfileSupported(codec)) {
           supportedCodecInfos.add(new VideoCodecInfo(
-              name, MediaCodecUtils.getCodecProperties(type, /* highProfile= */ true)));
+              name, MediaCodecUtils.getCodecProperties(type, /* highProfile= */ true), new Arrays.asList(
+                  "L1T1",
+                  "L1T2",
+                  "L1T3",
+                  "L2T1",
+                  "L2T1h",
+                  "L2T1_KEY",
+                  "L2T2",
+                  "L2T2h",
+                  "L2T2_KEY",
+                  "L2T2_KEY_SHIFT",
+                  "L2T3",
+                  "L2T3h",
+                  "L2T3_KEY",
+                  "L3T1",
+                  "L3T1h",
+                  "L3T1_KEY",
+                  "L3T2",
+                  "L3T2h",
+                  "L3T2_KEY",
+                  "L3T3",
+                  "L3T3h",
+                  "L3T3_KEY",
+                  "S2T1",
+                  "S2T1h",
+                  "S2T2",
+                  "S2T2h",
+                  "S2T3",
+                  "S2T3h",
+                  "S3T1",
+                  "S3T1h",
+                  "S3T2",
+                  "S3T2h",
+                  "S3T3",
+                  "S3T3h")));
         }
 
-        supportedCodecInfos.add(new VideoCodecInfo(
-            name, MediaCodecUtils.getCodecProperties(type, /* highProfile= */ false)));
+          supportedCodecInfos.add(new VideoCodecInfo(
+              name, MediaCodecUtils.getCodecProperties(type, /* highProfile= */ false), new Arrays.asList(
+                  "L1T1",
+                  "L1T2",
+                  "L1T3",
+                  "L2T1",
+                  "L2T1h",
+                  "L2T1_KEY",
+                  "L2T2",
+                  "L2T2h",
+                  "L2T2_KEY",
+                  "L2T2_KEY_SHIFT",
+                  "L2T3",
+                  "L2T3h",
+                  "L2T3_KEY",
+                  "L3T1",
+                  "L3T1h",
+                  "L3T1_KEY",
+                  "L3T2",
+                  "L3T2h",
+                  "L3T2_KEY",
+                  "L3T3",
+                  "L3T3h",
+                  "L3T3_KEY",
+                  "S2T1",
+                  "S2T1h",
+                  "S2T2",
+                  "S2T2h",
+                  "S2T3",
+                  "S2T3h",
+                  "S3T1",
+                  "S3T1h",
+                  "S3T2",
+                  "S3T2h",
+                  "S3T3",
+                  "S3T3h")));
       }
     }
 
diff --git a/src/sdk/android/api/org/webrtc/RtpParameters.java b/src/sdk/android/api/org/webrtc/RtpParameters.java
index 9ca8311..1fcffe7 100644
--- a/src/sdk/android/api/org/webrtc/RtpParameters.java
+++ b/src/sdk/android/api/org/webrtc/RtpParameters.java
@@ -73,6 +73,8 @@ public class RtpParameters {
     @Nullable public Integer maxFramerate;
     // The number of temporal layers for video.
     @Nullable public Integer numTemporalLayers;
+    // https://w3c.github.io/webrtc-svc/#rtcrtpencodingparameters
+    @Nullable public String scalabilityMode;
     // If non-null, scale the width and height down by this factor for video. If null,
     // implementation default scaling factor will be used.
     @Nullable public Double scaleResolutionDownBy;
@@ -93,7 +95,7 @@ public class RtpParameters {
     @CalledByNative("Encoding")
     Encoding(String rid, boolean active, double bitratePriority, @Priority int networkPriority,
         Integer maxBitrateBps, Integer minBitrateBps, Integer maxFramerate,
-        Integer numTemporalLayers, Double scaleResolutionDownBy, Long ssrc,
+        Integer numTemporalLayers, String scalabilityMode, Double scaleResolutionDownBy, Long ssrc,
         boolean adaptiveAudioPacketTime) {
       this.rid = rid;
       this.active = active;
@@ -103,6 +105,7 @@ public class RtpParameters {
       this.minBitrateBps = minBitrateBps;
       this.maxFramerate = maxFramerate;
       this.numTemporalLayers = numTemporalLayers;
+      this.scalabilityMode = scalabilityMode;
       this.scaleResolutionDownBy = scaleResolutionDownBy;
       this.ssrc = ssrc;
       this.adaptiveAudioPacketTime = adaptiveAudioPacketTime;
@@ -154,6 +157,12 @@ public class RtpParameters {
       return numTemporalLayers;
     }
 
+    @Nullable
+    @CalledByNative("Encoding")
+    String getScalabilityMode() {
+      return scalabilityMode;
+    }
+
     @Nullable
     @CalledByNative("Encoding")
     Double getScaleResolutionDownBy() {
diff --git a/src/sdk/android/api/org/webrtc/VideoCodecInfo.java b/src/sdk/android/api/org/webrtc/VideoCodecInfo.java
index 4f97cf7..d357ff0 100644
--- a/src/sdk/android/api/org/webrtc/VideoCodecInfo.java
+++ b/src/sdk/android/api/org/webrtc/VideoCodecInfo.java
@@ -34,20 +34,23 @@ public class VideoCodecInfo {
 
   public final String name;
   public final Map<String, String> params;
+  public final List<String> scalabilityMods;
   @Deprecated public final int payload;
 
   @CalledByNative
-  public VideoCodecInfo(String name, Map<String, String> params) {
+  public VideoCodecInfo(String name, Map<String, String> params, List<String> scalabilityMods) {
     this.payload = 0;
     this.name = name;
     this.params = params;
+    this.scalabilityMods = scalabilityMods;
   }
 
   @Deprecated
-  public VideoCodecInfo(int payload, String name, Map<String, String> params) {
+  public VideoCodecInfo(int payload, String name, Map<String, String> params, List<String> scalabilityMods) {
     this.payload = payload;
     this.name = name;
     this.params = params;
+    this.scalabilityMods = scalabilityMods;
   }
 
   @Override
@@ -83,4 +86,9 @@ public class VideoCodecInfo {
   Map getParams() {
     return params;
   }
+
+  @CalledByNative
+  List getScalabiltyMods() {
+    return scalabilityMods;
+  }
 }
diff --git a/src/sdk/android/instrumentationtests/src/org/webrtc/AndroidVideoDecoderInstrumentationTest.java b/src/sdk/android/instrumentationtests/src/org/webrtc/AndroidVideoDecoderInstrumentationTest.java
index 6f44812..7750762 100644
--- a/src/sdk/android/instrumentationtests/src/org/webrtc/AndroidVideoDecoderInstrumentationTest.java
+++ b/src/sdk/android/instrumentationtests/src/org/webrtc/AndroidVideoDecoderInstrumentationTest.java
@@ -48,7 +48,7 @@ public final class AndroidVideoDecoderInstrumentationTest {
     if (codecName.equals("H264")) {
       this.codecType = H264Utils.DEFAULT_H264_BASELINE_PROFILE_CODEC;
     } else {
-      this.codecType = new VideoCodecInfo(codecName, new HashMap<>());
+      this.codecType = new VideoCodecInfo(codecName, new HashMap<>(), new Arrays.asList());
     }
     this.useEglContext = useEglContext;
   }
diff --git a/src/sdk/android/instrumentationtests/src/org/webrtc/DefaultVideoEncoderFactoryTest.java b/src/sdk/android/instrumentationtests/src/org/webrtc/DefaultVideoEncoderFactoryTest.java
index fe608c7..bc247a1 100644
--- a/src/sdk/android/instrumentationtests/src/org/webrtc/DefaultVideoEncoderFactoryTest.java
+++ b/src/sdk/android/instrumentationtests/src/org/webrtc/DefaultVideoEncoderFactoryTest.java
@@ -15,6 +15,7 @@ import static org.junit.Assert.assertEquals;
 import androidx.annotation.Nullable;
 import androidx.test.filters.SmallTest;
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.HashMap;
 import org.junit.Before;
 import org.junit.Test;
@@ -47,7 +48,7 @@ public class DefaultVideoEncoderFactoryTest {
   @SmallTest
   @Test
   public void getSupportedCodecs_hwVp8SameParamsAsSwVp8_oneVp8() {
-    VideoCodecInfo hwVp8Encoder = new VideoCodecInfo("VP8", new HashMap<>());
+    VideoCodecInfo hwVp8Encoder = new VideoCodecInfo("VP8", new HashMap<>(), new Arrays.asList());
     VideoEncoderFactory hwFactory = new CustomHardwareVideoEncoderFactory(hwVp8Encoder);
     DefaultVideoEncoderFactory defFactory = new DefaultVideoEncoderFactory(hwFactory);
     VideoCodecInfo[] supportedCodecs = defFactory.getSupportedCodecs();
@@ -62,7 +63,7 @@ public class DefaultVideoEncoderFactoryTest {
   public void getSupportedCodecs_hwVp8WithDifferentParams_twoVp8() {
     VideoCodecInfo hwVp8Encoder = new VideoCodecInfo("VP8", new HashMap<String, String>() {
       { put("param", "value"); }
-    });
+    }, new Arrays.asList());
     VideoEncoderFactory hwFactory = new CustomHardwareVideoEncoderFactory(hwVp8Encoder);
     DefaultVideoEncoderFactory defFactory = new DefaultVideoEncoderFactory(hwFactory);
     VideoCodecInfo[] supportedCodecs = defFactory.getSupportedCodecs();
diff --git a/src/sdk/android/instrumentationtests/src/org/webrtc/RtpCapabilitiesTest.java b/src/sdk/android/instrumentationtests/src/org/webrtc/RtpCapabilitiesTest.java
index 961ecd5..1c4203e 100644
--- a/src/sdk/android/instrumentationtests/src/org/webrtc/RtpCapabilitiesTest.java
+++ b/src/sdk/android/instrumentationtests/src/org/webrtc/RtpCapabilitiesTest.java
@@ -82,8 +82,8 @@ public class RtpCapabilitiesTest {
                                          .setNativeLibraryName(TestConstants.NATIVE_LIBRARY)
                                          .createInitializationOptions());
 
-    VideoCodecInfo vp8Codec = new VideoCodecInfo("VP8", new HashMap<>());
-    VideoCodecInfo h264Codec = new VideoCodecInfo("H264", new HashMap<>());
+    VideoCodecInfo vp8Codec = new VideoCodecInfo("VP8", new HashMap<>(), new Arrays.asList());
+    VideoCodecInfo h264Codec = new VideoCodecInfo("H264", new HashMap<>(), new Arrays.asList());
     List<VideoCodecInfo> supportedCodecs = new ArrayList<>();
     supportedCodecs.add(vp8Codec);
     supportedCodecs.add(h264Codec);
diff --git a/src/sdk/android/instrumentationtests/src/org/webrtc/SoftwareVideoDecoderFactoryTest.java b/src/sdk/android/instrumentationtests/src/org/webrtc/SoftwareVideoDecoderFactoryTest.java
index 8a5d978..fc37e54 100644
--- a/src/sdk/android/instrumentationtests/src/org/webrtc/SoftwareVideoDecoderFactoryTest.java
+++ b/src/sdk/android/instrumentationtests/src/org/webrtc/SoftwareVideoDecoderFactoryTest.java
@@ -14,6 +14,8 @@ import static com.google.common.truth.Truth.assertThat;
 
 import androidx.annotation.Nullable;
 import androidx.test.filters.SmallTest;
+
+import java.util.Arrays;
 import java.util.HashMap;
 import org.junit.Before;
 import org.junit.Test;
@@ -55,7 +57,7 @@ public class SoftwareVideoDecoderFactoryTest {
   @Test
   public void createDecoder_unsupportedCodec_returnsNull() {
     VideoDecoderFactory factory = new SoftwareVideoDecoderFactory();
-    VideoCodecInfo codec = new VideoCodecInfo("unsupported", new HashMap<String, String>());
+    VideoCodecInfo codec = new VideoCodecInfo("unsupported", new HashMap<String, String>(), new Arrays.asList());
     VideoDecoder decoder = factory.createDecoder(codec);
     assertThat(decoder).isNull();
   }
diff --git a/src/sdk/android/instrumentationtests/src/org/webrtc/SoftwareVideoEncoderFactoryTest.java b/src/sdk/android/instrumentationtests/src/org/webrtc/SoftwareVideoEncoderFactoryTest.java
index 696b423..b6f613e 100644
--- a/src/sdk/android/instrumentationtests/src/org/webrtc/SoftwareVideoEncoderFactoryTest.java
+++ b/src/sdk/android/instrumentationtests/src/org/webrtc/SoftwareVideoEncoderFactoryTest.java
@@ -14,6 +14,8 @@ import static com.google.common.truth.Truth.assertThat;
 
 import androidx.annotation.Nullable;
 import androidx.test.filters.SmallTest;
+
+import java.util.Arrays;
 import java.util.HashMap;
 import org.junit.Before;
 import org.junit.Test;
@@ -52,7 +54,7 @@ public class SoftwareVideoEncoderFactoryTest {
   @Test
   public void createEncoder_unsupportedCodec_returnsNull() {
     VideoEncoderFactory factory = new SoftwareVideoEncoderFactory();
-    VideoCodecInfo codec = new VideoCodecInfo("unsupported", new HashMap<String, String>());
+    VideoCodecInfo codec = new VideoCodecInfo("unsupported", new HashMap<String, String>(), new Arrays.asList());
     VideoEncoder encoder = factory.createEncoder(codec);
     assertThat(encoder).isNull();
   }
diff --git a/src/sdk/android/src/java/org/webrtc/H264Utils.java b/src/sdk/android/src/java/org/webrtc/H264Utils.java
index abb79c6..277479f 100644
--- a/src/sdk/android/src/java/org/webrtc/H264Utils.java
+++ b/src/sdk/android/src/java/org/webrtc/H264Utils.java
@@ -11,6 +11,7 @@
 package org.webrtc;
 
 import java.util.Map;
+import java.util.Arrays;
 import java.util.HashMap;
 
 /** Container for static helper functions related to dealing with H264 codecs. */
@@ -38,9 +39,9 @@ class H264Utils {
   }
 
   public static VideoCodecInfo DEFAULT_H264_BASELINE_PROFILE_CODEC =
-      new VideoCodecInfo("H264", getDefaultH264Params(/* isHighProfile= */ false));
+      new VideoCodecInfo("H264", getDefaultH264Params(/* isHighProfile= */ false), new Arrays.asList());
   public static VideoCodecInfo DEFAULT_H264_HIGH_PROFILE_CODEC =
-      new VideoCodecInfo("H264", getDefaultH264Params(/* isHighProfile= */ true));
+      new VideoCodecInfo("H264", getDefaultH264Params(/* isHighProfile= */ true), new Arrays.asList());
 
   public static boolean isSameH264Profile(
       Map<String, String> params1, Map<String, String> params2) {
diff --git a/src/sdk/android/src/java/org/webrtc/MediaCodecVideoDecoderFactory.java b/src/sdk/android/src/java/org/webrtc/MediaCodecVideoDecoderFactory.java
index 9a73bc4..a211359 100644
--- a/src/sdk/android/src/java/org/webrtc/MediaCodecVideoDecoderFactory.java
+++ b/src/sdk/android/src/java/org/webrtc/MediaCodecVideoDecoderFactory.java
@@ -19,6 +19,7 @@ import android.media.MediaCodecList;
 import android.os.Build;
 import androidx.annotation.Nullable;
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.List;
 
 /** Factory for decoders backed by Android MediaCodec API. */
@@ -72,11 +73,79 @@ class MediaCodecVideoDecoderFactory implements VideoDecoderFactory {
         String name = type.name();
         if (type == VideoCodecMimeType.H264 && isH264HighProfileSupported(codec)) {
           supportedCodecInfos.add(new VideoCodecInfo(
-              name, MediaCodecUtils.getCodecProperties(type, /* highProfile= */ true)));
+              name, MediaCodecUtils.getCodecProperties(type, /* highProfile= */ true), new Arrays.asList(
+                  "L1T1",
+                  "L1T2",
+                  "L1T3",
+                  "L2T1",
+                  "L2T1h",
+                  "L2T1_KEY",
+                  "L2T2",
+                  "L2T2h",
+                  "L2T2_KEY",
+                  "L2T2_KEY_SHIFT",
+                  "L2T3",
+                  "L2T3h",
+                  "L2T3_KEY",
+                  "L3T1",
+                  "L3T1h",
+                  "L3T1_KEY",
+                  "L3T2",
+                  "L3T2h",
+                  "L3T2_KEY",
+                  "L3T3",
+                  "L3T3h",
+                  "L3T3_KEY",
+                  "S2T1",
+                  "S2T1h",
+                  "S2T2",
+                  "S2T2h",
+                  "S2T3",
+                  "S2T3h",
+                  "S3T1",
+                  "S3T1h",
+                  "S3T2",
+                  "S3T2h",
+                  "S3T3",
+                  "S3T3h")));
         }
 
-        supportedCodecInfos.add(new VideoCodecInfo(
-            name, MediaCodecUtils.getCodecProperties(type, /* highProfile= */ false)));
+          supportedCodecInfos.add(new VideoCodecInfo(
+              name, MediaCodecUtils.getCodecProperties(type, /* highProfile= */ false), new Arrays.asList(
+                  "L1T1",
+                  "L1T2",
+                  "L1T3",
+                  "L2T1",
+                  "L2T1h",
+                  "L2T1_KEY",
+                  "L2T2",
+                  "L2T2h",
+                  "L2T2_KEY",
+                  "L2T2_KEY_SHIFT",
+                  "L2T3",
+                  "L2T3h",
+                  "L2T3_KEY",
+                  "L3T1",
+                  "L3T1h",
+                  "L3T1_KEY",
+                  "L3T2",
+                  "L3T2h",
+                  "L3T2_KEY",
+                  "L3T3",
+                  "L3T3h",
+                  "L3T3_KEY",
+                  "S2T1",
+                  "S2T1h",
+                  "S2T2",
+                  "S2T2h",
+                  "S2T3",
+                  "S2T3h",
+                  "S3T1",
+                  "S3T1h",
+                  "S3T2",
+                  "S3T2h",
+                  "S3T3",
+                  "S3T3h")));
       }
     }
 
diff --git a/src/sdk/android/src/jni/pc/rtp_parameters.cc b/src/sdk/android/src/jni/pc/rtp_parameters.cc
index 4bd9ee0..1f5957b 100644
--- a/src/sdk/android/src/jni/pc/rtp_parameters.cc
+++ b/src/sdk/android/src/jni/pc/rtp_parameters.cc
@@ -52,6 +52,7 @@ ScopedJavaLocalRef<jobject> NativeToJavaRtpEncodingParameter(
       NativeToJavaInteger(env, encoding.min_bitrate_bps),
       NativeToJavaInteger(env, encoding.max_framerate),
       NativeToJavaInteger(env, encoding.num_temporal_layers),
+      NativeToJavaString(env, encoding.scalability_mode),
       NativeToJavaDouble(env, encoding.scale_resolution_down_by),
       encoding.ssrc ? NativeToJavaLong(env, *encoding.ssrc) : nullptr,
       encoding.adaptive_ptime);
@@ -112,6 +113,11 @@ RtpEncodingParameters JavaToNativeRtpEncodingParameters(
       Java_Encoding_getNumTemporalLayers(jni, j_encoding_parameters);
   encoding.num_temporal_layers =
       JavaToNativeOptionalInt(jni, j_num_temporal_layers);
+  ScopedJavaLocalRef<jstring> j_scalability_mode =
+      Java_Encoding_getScalabilityMode(jni, j_encoding_parameters);
+  if (!IsNull(jni, j_scalability_mode)) {
+    encoding.scalability_mode = JavaToNativeString(jni, j_scalability_mode);
+  }
   ScopedJavaLocalRef<jobject> j_scale_resolution_down_by =
       Java_Encoding_getScaleResolutionDownBy(jni, j_encoding_parameters);
   encoding.scale_resolution_down_by =
diff --git a/src/sdk/android/src/jni/pc/rtp_sender.cc b/src/sdk/android/src/jni/pc/rtp_sender.cc
index ddb53f6..533d0e9 100644
--- a/src/sdk/android/src/jni/pc/rtp_sender.cc
+++ b/src/sdk/android/src/jni/pc/rtp_sender.cc
@@ -70,7 +70,7 @@ jlong JNI_RtpSender_GetDtmfSender(JNIEnv* jni, jlong j_rtp_sender_pointer) {
           ->GetDtmfSender()
           .release());
 }
-
+ // here
 jboolean JNI_RtpSender_SetParameters(
     JNIEnv* jni,
     jlong j_rtp_sender_pointer,
diff --git a/src/sdk/android/src/jni/video_codec_info.cc b/src/sdk/android/src/jni/video_codec_info.cc
index a218a1d..df0a844 100644
--- a/src/sdk/android/src/jni/video_codec_info.cc
+++ b/src/sdk/android/src/jni/video_codec_info.cc
@@ -13,15 +13,30 @@
 #include "sdk/android/generated_video_jni/VideoCodecInfo_jni.h"
 #include "sdk/android/native_api/jni/java_types.h"
 #include "sdk/android/src/jni/jni_helpers.h"
+#include "absl/container/inlined_vector.h"
+#include "absl/types/optional.h"
+#include "api/video_codecs/scalability_mode.h"
 
 namespace webrtc {
 namespace jni {
 
 SdpVideoFormat VideoCodecInfoToSdpVideoFormat(JNIEnv* jni,
                                               const JavaRef<jobject>& j_info) {
+  absl::InlinedVector<ScalabilityMode, kScalabilityModeCount> scalability_modes;
+  auto scalability_modes_str = JavaToStdVectorStrings(Java_VideoCodecInfo_getScalabiltyMods(jni, j_info));
+  for (size_t i = 0; i<scalability_modes_str.size(); ++i) {
+    for (size_t j = 0; j < kAllScalabilityModes.size(); ++j) {
+      if (ScalabilityModeToString(kAllScalabilityModes[j]) == scalability_modes_str[i]) {
+        scalability_modes.push(kAllScalabilityModes[j]);
+      }
+    }
+
+  }
   return SdpVideoFormat(
       JavaToNativeString(jni, Java_VideoCodecInfo_getName(jni, j_info)),
-      JavaToNativeStringMap(jni, Java_VideoCodecInfo_getParams(jni, j_info)));
+      JavaToNativeStringMap(jni, Java_VideoCodecInfo_getParams(jni, j_info)),
+      scalability_modes
+      );
 }
 
 ScopedJavaLocalRef<jobject> SdpVideoFormatToVideoCodecInfo(
@@ -29,8 +44,12 @@ ScopedJavaLocalRef<jobject> SdpVideoFormatToVideoCodecInfo(
     const SdpVideoFormat& format) {
   ScopedJavaLocalRef<jobject> j_params =
       NativeToJavaStringMap(jni, format.parameters);
+  ScopedJavaLocalRef<jobject> j_scala = NativeToJavaList(
+      jni, format.scalability_modes, [](JNIEnv* jni, ScalabilityMode mode) {
+        NativeToJavaString(jni, ScalabilityModeToString(mode))
+      });
   return Java_VideoCodecInfo_Constructor(
-      jni, NativeToJavaString(jni, format.name), j_params);
+      jni, NativeToJavaString(jni, format.name), j_params, j_scala);
 }
 
 }  // namespace jni
diff --git a/src/sdk/android/src/jni/video_encoder_factory_wrapper.cc b/src/sdk/android/src/jni/video_encoder_factory_wrapper.cc
index 7df129b..67b2931 100644
--- a/src/sdk/android/src/jni/video_encoder_factory_wrapper.cc
+++ b/src/sdk/android/src/jni/video_encoder_factory_wrapper.cc
@@ -77,6 +77,7 @@ class VideoEncoderSelectorWrapper
 
 }  // namespace
 
+ // here!!
 VideoEncoderFactoryWrapper::VideoEncoderFactoryWrapper(
     JNIEnv* jni,
     const JavaRef<jobject>& encoder_factory)
diff --git a/src/sdk/objc/api/peerconnection/RTCPeerConnectionFactory.h b/src/sdk/objc/api/peerconnection/RTCPeerConnectionFactory.h
index 5575af9..f8dfae1 100644
--- a/src/sdk/objc/api/peerconnection/RTCPeerConnectionFactory.h
+++ b/src/sdk/objc/api/peerconnection/RTCPeerConnectionFactory.h
@@ -23,6 +23,10 @@ NS_ASSUME_NONNULL_BEGIN
 @class RTC_OBJC_TYPE(RTCVideoSource);
 @class RTC_OBJC_TYPE(RTCVideoTrack);
 @class RTC_OBJC_TYPE(RTCPeerConnectionFactoryOptions);
+@class RTC_OBJC_TYPE(RTCRtpCapabilities);
+
+typedef NS_ENUM(NSInteger, RTCRtpMediaType);
+
 @protocol RTC_OBJC_TYPE
 (RTCPeerConnectionDelegate);
 @protocol RTC_OBJC_TYPE
@@ -51,6 +55,10 @@ RTC_OBJC_EXPORT
             decoderFactory:(nullable id<RTC_OBJC_TYPE(RTCVideoDecoderFactory)>)decoderFactory
                audioDevice:(nullable id<RTC_OBJC_TYPE(RTCAudioDevice)>)audioDevice;
 
+- (RTC_OBJC_TYPE(RTCRtpCapabilities) *)rtpSenderCapabilitiesFor:(RTCRtpMediaType)mediaType;
+
+- (RTC_OBJC_TYPE(RTCRtpCapabilities) *)rtpReceiverCapabilitiesFor:(RTCRtpMediaType)mediaType;
+
 /** Initialize an RTCAudioSource with constraints. */
 - (RTC_OBJC_TYPE(RTCAudioSource) *)audioSourceWithConstraints:
     (nullable RTC_OBJC_TYPE(RTCMediaConstraints) *)constraints;
diff --git a/src/sdk/objc/api/peerconnection/RTCPeerConnectionFactory.mm b/src/sdk/objc/api/peerconnection/RTCPeerConnectionFactory.mm
index 62b5554..e63104d 100644
--- a/src/sdk/objc/api/peerconnection/RTCPeerConnectionFactory.mm
+++ b/src/sdk/objc/api/peerconnection/RTCPeerConnectionFactory.mm
@@ -21,6 +21,9 @@
 #import "RTCPeerConnection+Private.h"
 #import "RTCVideoSource+Private.h"
 #import "RTCVideoTrack+Private.h"
+#import "RTCRtpReceiver+Private.h"
+#import "RTCRtpCapabilities+Private.h"
+#import "RTCRtpCodecCapability+Private.h"
 #import "base/RTCLogging.h"
 #import "base/RTCVideoDecoderFactory.h"
 #import "base/RTCVideoEncoderFactory.h"
@@ -116,6 +119,20 @@
 #endif
 }
 
+- (RTC_OBJC_TYPE(RTCRtpCapabilities) *)rtpSenderCapabilitiesFor:(RTCRtpMediaType)mediaType {
+
+  webrtc::RtpCapabilities capabilities = _nativeFactory->GetRtpSenderCapabilities([RTCRtpReceiver nativeMediaTypeForMediaType: mediaType]);
+
+  return [[RTCRtpCapabilities alloc] initWithNativeCapabilities: capabilities];
+}
+
+- (RTC_OBJC_TYPE(RTCRtpCapabilities) *)rtpReceiverCapabilitiesFor:(RTCRtpMediaType)mediaType {
+
+  webrtc::RtpCapabilities capabilities = _nativeFactory->GetRtpReceiverCapabilities([RTCRtpReceiver nativeMediaTypeForMediaType: mediaType]);
+
+  return [[RTCRtpCapabilities alloc] initWithNativeCapabilities: capabilities];
+}
+
 - (instancetype)initNative {
   if (self = [super init]) {
     _networkThread = rtc::Thread::CreateWithSocketServer();
diff --git a/src/sdk/objc/api/peerconnection/RTCRtpCapabilities+Private.h b/src/sdk/objc/api/peerconnection/RTCRtpCapabilities+Private.h
new file mode 100644
index 0000000..15c8fe3
--- /dev/null
+++ b/src/sdk/objc/api/peerconnection/RTCRtpCapabilities+Private.h
@@ -0,0 +1,33 @@
+/*
+ * Copyright 2023 LiveKit
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#import "RTCRtpCapabilities.h"
+
+#include "api/rtp_parameters.h"
+
+NS_ASSUME_NONNULL_BEGIN
+
+@interface RTC_OBJC_TYPE (RTCRtpCapabilities)
+()
+
+    @property(nonatomic, readonly) webrtc::RtpCapabilities nativeCapabilities;
+
+- (instancetype)initWithNativeCapabilities:(const webrtc::RtpCapabilities &)nativeCapabilities
+    NS_DESIGNATED_INITIALIZER;
+
+@end
+
+NS_ASSUME_NONNULL_END
\ No newline at end of file
diff --git a/src/sdk/objc/api/peerconnection/RTCRtpCapabilities.h b/src/sdk/objc/api/peerconnection/RTCRtpCapabilities.h
new file mode 100644
index 0000000..2dea41a
--- /dev/null
+++ b/src/sdk/objc/api/peerconnection/RTCRtpCapabilities.h
@@ -0,0 +1,37 @@
+/*
+ * Copyright 2023 LiveKit
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#import <Foundation/Foundation.h>
+
+#import "RTCMacros.h"
+
+@class RTC_OBJC_TYPE(RTCRtpCodecCapability);
+@class RTC_OBJC_TYPE(RTCRtpHeaderExtensionCapability);
+
+NS_ASSUME_NONNULL_BEGIN
+
+RTC_OBJC_EXPORT
+@interface RTC_OBJC_TYPE (RTCRtpCapabilities) : NSObject
+
+- (instancetype)init NS_UNAVAILABLE;
+
+@property(nonatomic, readonly) NSArray<RTC_OBJC_TYPE(RTCRtpCodecCapability) *> *codecs;
+
+@property(nonatomic, readonly) NSArray<RTC_OBJC_TYPE(RTCRtpHeaderExtensionCapability) *> *header_extensions;
+
+@end
+
+NS_ASSUME_NONNULL_END
\ No newline at end of file
diff --git a/src/sdk/objc/api/peerconnection/RTCRtpCapabilities.mm b/src/sdk/objc/api/peerconnection/RTCRtpCapabilities.mm
new file mode 100644
index 0000000..7f73108
--- /dev/null
+++ b/src/sdk/objc/api/peerconnection/RTCRtpCapabilities.mm
@@ -0,0 +1,63 @@
+/*
+ * Copyright 2023 LiveKit
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#import "RTCRtpCapabilities+Private.h"
+#import "RTCRtpCodecCapability+Private.h"
+#import "RTCRtpHeaderExtensionCapability+Private.h"
+
+#import "RTCMediaStreamTrack.h"
+#import "helpers/NSString+StdString.h"
+
+#include "media/base/media_constants.h"
+#include "rtc_base/checks.h"
+
+@implementation RTC_OBJC_TYPE (RTCRtpCapabilities)
+
+@synthesize nativeCapabilities = _nativeCapabilities;
+
+- (instancetype)initWithNativeCapabilities:(const webrtc::RtpCapabilities &)nativeCapabilities {
+  if (self = [super init]) {
+    _nativeCapabilities = nativeCapabilities;
+  }
+
+  return self;
+}
+
+- (NSArray<RTC_OBJC_TYPE(RTCRtpCodecCapability) *> *)codecs {
+  NSMutableArray *result = [NSMutableArray array];
+
+  for (auto &element : _nativeCapabilities.codecs) {
+    RTCRtpCodecCapability *object =
+        [[RTCRtpCodecCapability alloc] initWithNativeCodecCapability:element];
+    [result addObject:object];
+  }
+
+  return result;
+}
+
+- (NSArray<RTC_OBJC_TYPE(RTCRtpHeaderExtensionCapability) *> *)header_extensions {
+  NSMutableArray *result = [NSMutableArray array];
+
+  for (auto &element : _nativeCapabilities.header_extensions) {
+    RTCRtpHeaderExtensionCapability *object =
+        [[RTCRtpHeaderExtensionCapability alloc] initWithNativeHeaderExtensionCapability:element];
+    [result addObject:object];
+  }
+
+  return result;
+}
+
+@end
\ No newline at end of file
diff --git a/src/sdk/objc/api/peerconnection/RTCRtpCodecCapability+Private.h b/src/sdk/objc/api/peerconnection/RTCRtpCodecCapability+Private.h
new file mode 100644
index 0000000..b36d26c
--- /dev/null
+++ b/src/sdk/objc/api/peerconnection/RTCRtpCodecCapability+Private.h
@@ -0,0 +1,33 @@
+/*
+ * Copyright 2023 LiveKit
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#import "RTCRtpCodecCapability.h"
+
+#include "api/rtp_parameters.h"
+
+NS_ASSUME_NONNULL_BEGIN
+
+@interface RTC_OBJC_TYPE (RTCRtpCodecCapability)
+()
+
+    @property(nonatomic, readonly) webrtc::RtpCodecCapability nativeCodecCapability;
+
+- (instancetype)initWithNativeCodecCapability:
+    (const webrtc::RtpCodecCapability &)nativeCodecCapability NS_DESIGNATED_INITIALIZER;
+
+@end
+
+NS_ASSUME_NONNULL_END
\ No newline at end of file
diff --git a/src/sdk/objc/api/peerconnection/RTCRtpCodecCapability.h b/src/sdk/objc/api/peerconnection/RTCRtpCodecCapability.h
new file mode 100644
index 0000000..0daf40e
--- /dev/null
+++ b/src/sdk/objc/api/peerconnection/RTCRtpCodecCapability.h
@@ -0,0 +1,63 @@
+/*
+ * Copyright 2023 LiveKit
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#import <Foundation/Foundation.h>
+
+#import "RTCMacros.h"
+
+typedef NS_ENUM(NSInteger, RTCRtpMediaType);
+
+NS_ASSUME_NONNULL_BEGIN
+
+RTC_OBJC_EXPORT
+@interface RTC_OBJC_TYPE (RTCRtpCodecCapability) : NSObject
+
+// Build MIME "type/subtype" string from `name` and `kind`.
+@property(nonatomic, readonly) NSString *mimeType;
+
+// Used to identify the codec. Equivalent to MIME subtype.
+@property(nonatomic, copy) NSString *name;
+
+// The media type of this codec. Equivalent to MIME top-level type.
+@property(nonatomic, assign) RTCRtpMediaType kind;
+
+// Clock rate in Hertz. If unset, the codec is applicable to any clock rate.
+@property(nonatomic, copy, nullable) NSNumber *clockRate;
+
+// Default payload type for this codec. Mainly needed for codecs that use
+// that have statically assigned payload types.
+@property(nonatomic, copy, nullable) NSNumber *preferredPayloadType;
+
+// The number of audio channels supported. Unused for video codecs.
+@property(nonatomic, copy, nullable) NSNumber *numChannels;
+
+// Codec-specific parameters that must be signaled to the remote party.
+//
+// Corresponds to "a=fmtp" parameters in SDP.
+//
+// Contrary to ORTC, these parameters are named using all lowercase strings.
+// This helps make the mapping to SDP simpler, if an application is using SDP.
+// Boolean values are represented by the string "1".
+// std::map<std::string, std::string> parameters;
+@property(nonatomic, copy) NSDictionary<NSString *, NSString *> *parameters;
+
+// Feedback mechanisms supported for this codec.
+// std::vector<RtcpFeedback> rtcp_feedback;
+// Not implemented.
+
+@end
+
+NS_ASSUME_NONNULL_END
\ No newline at end of file
diff --git a/src/sdk/objc/api/peerconnection/RTCRtpCodecCapability.mm b/src/sdk/objc/api/peerconnection/RTCRtpCodecCapability.mm
new file mode 100644
index 0000000..341cde4
--- /dev/null
+++ b/src/sdk/objc/api/peerconnection/RTCRtpCodecCapability.mm
@@ -0,0 +1,138 @@
+/*
+ * Copyright 2023 LiveKit
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#import "RTCRtpCodecCapability+Private.h"
+
+#import "RTCRtpReceiver+Private.h"
+
+#import "RTCMediaStreamTrack.h"
+#import "helpers/NSString+StdString.h"
+
+#include "media/base/media_constants.h"
+#include "rtc_base/checks.h"
+
+@implementation RTC_OBJC_TYPE (RTCRtpCodecCapability)
+
+@synthesize nativeCodecCapability = _nativeCodecCapability;
+
+- (instancetype)init {
+  return [self initWithNativeCodecCapability:webrtc::RtpCodecCapability()];
+}
+
+- (instancetype)initWithNativeCodecCapability:
+    (const webrtc::RtpCodecCapability &)nativeCodecCapability {
+  if (self = [super init]) {
+    _nativeCodecCapability = nativeCodecCapability;
+  }
+
+  return self;
+}
+
+- (NSString *)mimeType {
+  return [NSString stringWithUTF8String:_nativeCodecCapability.mime_type().c_str()];
+}
+
+- (NSString *)name {
+  return [NSString stringWithUTF8String:_nativeCodecCapability.name.c_str()];
+}
+
+- (void)setName:(NSString *)name {
+  _nativeCodecCapability.name = std::string([name UTF8String]);
+}
+
+- (RTCRtpMediaType)kind {
+  return [RTCRtpReceiver mediaTypeForNativeMediaType:_nativeCodecCapability.kind];
+}
+
+- (void)setKind:(RTCRtpMediaType)kind {
+  _nativeCodecCapability.kind = [RTCRtpReceiver nativeMediaTypeForMediaType:kind];
+}
+
+- (NSNumber *)clockRate {
+  if (!_nativeCodecCapability.clock_rate) {
+    return nil;
+  }
+
+  return [NSNumber numberWithInt:*_nativeCodecCapability.clock_rate];
+}
+
+- (void)setClockRate:(NSNumber *)clockRate {
+  if (clockRate == nil) {
+    _nativeCodecCapability.clock_rate = absl::optional<int>();
+    return;
+  }
+
+  _nativeCodecCapability.clock_rate = absl::optional<int>(clockRate.intValue);
+}
+
+- (NSNumber *)preferredPayloadType {
+  if (!_nativeCodecCapability.preferred_payload_type) {
+    return nil;
+  }
+
+  return [NSNumber numberWithInt:*_nativeCodecCapability.preferred_payload_type];
+}
+
+- (void)setPreferredPayloadType:(NSNumber *)preferredPayloadType {
+  if (preferredPayloadType == nil) {
+    _nativeCodecCapability.preferred_payload_type = absl::optional<int>();
+    return;
+  }
+
+  _nativeCodecCapability.preferred_payload_type =
+      absl::optional<int>(preferredPayloadType.intValue);
+}
+
+- (NSNumber *)numChannels {
+  if (!_nativeCodecCapability.num_channels) {
+    return nil;
+  }
+
+  return [NSNumber numberWithInt:*_nativeCodecCapability.num_channels];
+}
+
+- (void)setNumChannels:(NSNumber *)numChannels {
+  if (numChannels == nil) {
+    _nativeCodecCapability.num_channels = absl::optional<int>();
+    return;
+  }
+
+  _nativeCodecCapability.num_channels = absl::optional<int>(numChannels.intValue);
+}
+
+- (NSDictionary<NSString *, NSString *> *)parameters {
+  NSMutableDictionary *result = [NSMutableDictionary dictionary];
+  auto _parameters = _nativeCodecCapability.parameters;
+  for (auto it = _parameters.begin(); it != _parameters.end(); ++it) {
+    [result setObject:[NSString stringForStdString:it->second]
+               forKey:[NSString stringForStdString:it->first]];
+  }
+
+  return result;
+}
+
+- (void)setParameters:(NSDictionary<NSString *, NSString *> *)parameters {
+  std::map<std::string, std::string> _parameters;
+  for (NSString *paramKey in parameters.allKeys) {
+    std::string key = [NSString stdStringForString:paramKey];
+    std::string value = [NSString stdStringForString:parameters[paramKey]];
+    _parameters[key] = value;
+  }
+
+  _nativeCodecCapability.parameters = _parameters;
+}
+
+@end
\ No newline at end of file
diff --git a/src/sdk/objc/api/peerconnection/RTCRtpEncodingParameters.h b/src/sdk/objc/api/peerconnection/RTCRtpEncodingParameters.h
index 07f6b7a..d055115 100644
--- a/src/sdk/objc/api/peerconnection/RTCRtpEncodingParameters.h
+++ b/src/sdk/objc/api/peerconnection/RTCRtpEncodingParameters.h
@@ -51,6 +51,10 @@ RTC_OBJC_EXPORT
  */
 @property(nonatomic, copy, nullable) NSNumber *numTemporalLayers;
 
+/** A case-sensitive identifier of the scalability mode to be used for this stream.
+  https://w3c.github.io/webrtc-svc/#rtcrtpencodingparameters */
+@property(nonatomic, copy, nullable) NSString *scalabilityMode;
+
 /** Scale the width and height down by this factor for video. If nil,
  * implementation default scaling factor will be used.
  */
diff --git a/src/sdk/objc/api/peerconnection/RTCRtpEncodingParameters.mm b/src/sdk/objc/api/peerconnection/RTCRtpEncodingParameters.mm
index d6087da..e2020bb 100644
--- a/src/sdk/objc/api/peerconnection/RTCRtpEncodingParameters.mm
+++ b/src/sdk/objc/api/peerconnection/RTCRtpEncodingParameters.mm
@@ -20,6 +20,7 @@
 @synthesize minBitrateBps = _minBitrateBps;
 @synthesize maxFramerate = _maxFramerate;
 @synthesize numTemporalLayers = _numTemporalLayers;
+@synthesize scalabilityMode = _scalabilityMode;
 @synthesize scaleResolutionDownBy = _scaleResolutionDownBy;
 @synthesize ssrc = _ssrc;
 @synthesize bitratePriority = _bitratePriority;
@@ -52,6 +53,9 @@
     if (nativeParameters.num_temporal_layers) {
       _numTemporalLayers = [NSNumber numberWithInt:*nativeParameters.num_temporal_layers];
     }
+    if (nativeParameters.scalability_mode) {
+      _scalabilityMode = [NSString stringWithUTF8String:nativeParameters.scalability_mode->c_str()];
+    }
     if (nativeParameters.scale_resolution_down_by) {
       _scaleResolutionDownBy =
           [NSNumber numberWithDouble:*nativeParameters.scale_resolution_down_by];
@@ -85,6 +89,9 @@
   if (_numTemporalLayers != nil) {
     parameters.num_temporal_layers = absl::optional<int>(_numTemporalLayers.intValue);
   }
+  if (_scalabilityMode != nil) {
+    parameters.scalability_mode = absl::optional<std::string>(std::string([_scalabilityMode UTF8String]));
+  }
   if (_scaleResolutionDownBy != nil) {
     parameters.scale_resolution_down_by =
         absl::optional<double>(_scaleResolutionDownBy.doubleValue);
diff --git a/src/sdk/objc/api/peerconnection/RTCRtpHeaderExtensionCapability+Private.h b/src/sdk/objc/api/peerconnection/RTCRtpHeaderExtensionCapability+Private.h
new file mode 100644
index 0000000..2fa8c25
--- /dev/null
+++ b/src/sdk/objc/api/peerconnection/RTCRtpHeaderExtensionCapability+Private.h
@@ -0,0 +1,33 @@
+/*
+ * Copyright 2023 LiveKit
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#import "RTCRtpHeaderExtensionCapability.h"
+
+#include "api/rtp_parameters.h"
+
+NS_ASSUME_NONNULL_BEGIN
+
+@interface RTC_OBJC_TYPE (RTCRtpHeaderExtensionCapability)
+()
+
+    @property(nonatomic, readonly) webrtc::RtpHeaderExtensionCapability nativeHeaderExtensionCapability;
+
+- (instancetype)initWithNativeHeaderExtensionCapability:
+    (const webrtc::RtpHeaderExtensionCapability &)nativeHeaderExtensionCapability NS_DESIGNATED_INITIALIZER;
+
+@end
+
+NS_ASSUME_NONNULL_END
\ No newline at end of file
diff --git a/src/sdk/objc/api/peerconnection/RTCRtpHeaderExtensionCapability.h b/src/sdk/objc/api/peerconnection/RTCRtpHeaderExtensionCapability.h
new file mode 100644
index 0000000..27bb0e5
--- /dev/null
+++ b/src/sdk/objc/api/peerconnection/RTCRtpHeaderExtensionCapability.h
@@ -0,0 +1,37 @@
+/*
+ * Copyright 2023 LiveKit
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#import <Foundation/Foundation.h>
+
+#import "RTCMacros.h"
+
+NS_ASSUME_NONNULL_BEGIN
+
+RTC_OBJC_EXPORT
+@interface RTC_OBJC_TYPE (RTCRtpHeaderExtensionCapability) : NSObject
+
+// URI of this extension, as defined in RFC8285.
+@property(nonatomic, readonly) NSString *uri;
+
+// Preferred value of ID that goes in the packet.
+@property(nonatomic, assign) NSNumber *preferred_id;
+
+// If true, it's preferred that the value in the header is encrypted.
+@property(nonatomic, assign) BOOL preferred_encrypt;
+
+@end
+
+NS_ASSUME_NONNULL_END
\ No newline at end of file
diff --git a/src/sdk/objc/api/peerconnection/RTCRtpHeaderExtensionCapability.mm b/src/sdk/objc/api/peerconnection/RTCRtpHeaderExtensionCapability.mm
new file mode 100644
index 0000000..e36d2b4
--- /dev/null
+++ b/src/sdk/objc/api/peerconnection/RTCRtpHeaderExtensionCapability.mm
@@ -0,0 +1,54 @@
+/*
+ * Copyright 2023 LiveKit
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#import "RTCRtpHeaderExtensionCapability+Private.h"
+
+#import "helpers/NSString+StdString.h"
+
+#include "media/base/media_constants.h"
+#include "rtc_base/checks.h"
+
+@implementation RTC_OBJC_TYPE (RTCRtpHeaderExtensionCapability)
+
+@synthesize nativeHeaderExtensionCapability = _nativeHeaderExtensionCapability;
+
+- (instancetype)init {
+  return [self initWithNativeHeaderExtensionCapability:webrtc::RtpHeaderExtensionCapability()];
+}
+
+- (instancetype)initWithNativeHeaderExtensionCapability:
+    (const webrtc::RtpHeaderExtensionCapability &)nativeHeaderExtensionCapability {
+  if (self = [super init]) {
+    _nativeHeaderExtensionCapability = nativeHeaderExtensionCapability;
+  }
+
+  return self;
+}
+
+- (NSString *)uri {
+  return [NSString stringWithUTF8String:_nativeHeaderExtensionCapability.uri.c_str()];
+}
+
+- (NSNumber *)preferredId {
+  return [NSNumber numberWithInt:*_nativeHeaderExtensionCapability.preferred_id];
+
+}
+
+- (BOOL)preferredEncrypt {
+  return _nativeHeaderExtensionCapability.preferred_encrypt;
+}
+
+@end
\ No newline at end of file
diff --git a/src/sdk/objc/base/RTCVideoCodecInfo.h b/src/sdk/objc/base/RTCVideoCodecInfo.h
index fa28958..a82a690 100644
--- a/src/sdk/objc/base/RTCVideoCodecInfo.h
+++ b/src/sdk/objc/base/RTCVideoCodecInfo.h
@@ -30,6 +30,7 @@ RTC_OBJC_EXPORT
 
 @property(nonatomic, readonly) NSString *name;
 @property(nonatomic, readonly) NSDictionary<NSString *, NSString *> *parameters;
+@property(nonatomic, readonly) NSArray<NSString *> *scalabilty_modes;
 
 @end
 
diff --git a/src/sdk/objc/base/RTCVideoCodecInfo.m b/src/sdk/objc/base/RTCVideoCodecInfo.m
index ce26ae1..1b4e822 100644
--- a/src/sdk/objc/base/RTCVideoCodecInfo.m
+++ b/src/sdk/objc/base/RTCVideoCodecInfo.m
@@ -8,6 +8,7 @@
  *  be found in the AUTHORS file in the root of the source tree.
  */
 
+// here
 #import "RTCVideoCodecInfo.h"
 
 @implementation RTC_OBJC_TYPE (RTCVideoCodecInfo)
