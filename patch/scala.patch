diff --git a/src/api/video_codecs/video_encoder_factory_template_libvpx_vp8_adapter.h b/src/api/video_codecs/video_encoder_factory_template_libvpx_vp8_adapter.h
index 0f0a9ba..a2d608b 100644
--- a/src/api/video_codecs/video_encoder_factory_template_libvpx_vp8_adapter.h
+++ b/src/api/video_codecs/video_encoder_factory_template_libvpx_vp8_adapter.h
@@ -18,6 +18,7 @@
 #include "api/video_codecs/sdp_video_format.h"
 #include "modules/video_coding/codecs/vp8/include/vp8.h"
 #include "modules/video_coding/codecs/vp8/vp8_scalability.h"
+#include <android/log.h>
 
 namespace webrtc {
 struct LibvpxVp8EncoderTemplateAdapter {
@@ -26,6 +27,9 @@ struct LibvpxVp8EncoderTemplateAdapter {
         scalability_modes;
     for (const auto scalability_mode : kVP8SupportedScalabilityModes) {
       scalability_modes.push_back(scalability_mode);
+        auto sv2 = ScalabilityModeToString(scalability_mode);
+        std::string s2 = {sv2.begin(), sv2.end()};
+        __android_log_print(ANDROID_LOG_ERROR, "LibvpxVp8EncoderTemplateAdapter", "%s", s2.c_str());
     }
 
     return {
diff --git a/src/media/base/media_engine.cc b/src/media/base/media_engine.cc
index 7304ab0..e69e712 100644
--- a/src/media/base/media_engine.cc
+++ b/src/media/base/media_engine.cc
@@ -15,6 +15,9 @@
 #include <cstdint>
 #include <string>
 #include <utility>
+#include <sstream>
+#include <iostream>
+#include <android/log.h>
 
 #include "absl/algorithm/container.h"
 #include "api/video/video_bitrate_allocation.h"
@@ -95,10 +98,22 @@ webrtc::RTCError CheckScalabilityModeValues(
       }
     }
     if (rtp_parameters.encodings[i].scalability_mode) {
+        std::stringstream ss;
       if (!send_codec) {
-        bool scalabilityModeFound = false;
-        for (const cricket::VideoCodec& codec : codec_preferences) {
-          for (const auto& scalability_mode : codec.scalability_modes) {
+         bool scalabilityModeFound = false;
+        __android_log_print(ANDROID_LOG_ERROR, "codec_preferences", "%lu", (unsigned long) codec_preferences.size());
+         for (const cricket::VideoCodec& codec : codec_preferences) {
+        __android_log_print(ANDROID_LOG_ERROR, "codec", "|%s|", codec.name.c_str());
+        __android_log_print(ANDROID_LOG_ERROR, "codec_preferences.scalability_modes", "%lu", (unsigned long) codec.scalability_modes.size());
+           for (const auto& scalability_mode : codec.scalability_modes) {
+        auto sv = *rtp_parameters.encodings[i].scalability_mode; auto sv2 = ScalabilityModeToString(scalability_mode);
+        std::string s = {sv.begin(), sv.end()}; std::string s2 = {sv2.begin(), sv2.end()};
+        __android_log_print(ANDROID_LOG_ERROR, "scalability_mode", "|%s|", s2.c_str());
+        __android_log_print(ANDROID_LOG_ERROR, "scalability_mode2", "|%s|", s.c_str());
+
+
+          ss << "\nscalability_mode" << ScalabilityModeToString(scalability_mode) << "-" << *rtp_parameters.encodings[i].scalability_mode;
+
             if (ScalabilityModeToString(scalability_mode) ==
                 *rtp_parameters.encodings[i].scalability_mode) {
               scalabilityModeFound = true;
@@ -110,14 +125,24 @@ webrtc::RTCError CheckScalabilityModeValues(
         }
 
         if (!scalabilityModeFound) {
+        __android_log_print(ANDROID_LOG_ERROR, "AAAAA42", "%s", ss.str().c_str());
+          std::cout << ss.str() << std::endl;
           LOG_AND_RETURN_ERROR(
               RTCErrorType::INVALID_MODIFICATION,
               "Attempted to set RtpParameters scalabilityMode "
               "to an unsupported value for the current codecs.");
         }
       } else {
+          ss << "\nsend_codec";
+
         bool scalabilityModeFound = false;
         for (const auto& scalability_mode : send_codec->scalability_modes) {
+          ss << "\nscalability_mode" << ScalabilityModeToString(scalability_mode) << "-" << *rtp_parameters.encodings[i].scalability_mode;
+        auto sv = *rtp_parameters.encodings[i].scalability_mode; auto sv2 = ScalabilityModeToString(scalability_mode);
+        std::string s = {sv.begin(), sv.end()}; std::string s2 = {sv2.begin(), sv2.end()};
+        __android_log_print(ANDROID_LOG_ERROR, "scalability_mode", "|%s|", s2.c_str());
+        __android_log_print(ANDROID_LOG_ERROR, "scalability_mode2", "|%s|", s.c_str());
+
           if (ScalabilityModeToString(scalability_mode) ==
               *rtp_parameters.encodings[i].scalability_mode) {
             scalabilityModeFound = true;
@@ -125,6 +150,8 @@ webrtc::RTCError CheckScalabilityModeValues(
           }
         }
         if (!scalabilityModeFound) {
+        __android_log_print(ANDROID_LOG_ERROR, "AAAAA422", "%s", ss.str().c_str());
+          std::cout << ss.str() << std::endl;
           LOG_AND_RETURN_ERROR(
               RTCErrorType::INVALID_MODIFICATION,
               "Attempted to set RtpParameters scalabilityMode "
diff --git a/src/media/engine/webrtc_video_engine.cc b/src/media/engine/webrtc_video_engine.cc
index 91750b8..c63ced1 100644
--- a/src/media/engine/webrtc_video_engine.cc
+++ b/src/media/engine/webrtc_video_engine.cc
@@ -19,6 +19,7 @@
 #include <string>
 #include <type_traits>
 #include <utility>
+#include <android/log.h>
 
 #include "absl/algorithm/container.h"
 #include "absl/container/inlined_vector.h"
@@ -179,7 +180,10 @@ std::vector<VideoCodec> GetPayloadTypesAndDefaultCodecs(
     bool is_decoder_factory,
     bool include_rtx,
     const webrtc::FieldTrialsView& trials) {
+
+  __android_log_print(ANDROID_LOG_ERROR, "GetPayloadTypesAndDefaultCodecs", "%s", "GetPayloadTypesAndDefaultCodecs");
   if (!factory) {
+  __android_log_print(ANDROID_LOG_ERROR, "GetPayloadTypesAndDefaultCodecs", "%s", "NOPE");
     return {};
   }
 
@@ -219,6 +223,8 @@ std::vector<VideoCodec> GetPayloadTypesAndDefaultCodecs(
 
   std::vector<VideoCodec> output_codecs;
   for (const webrtc::SdpVideoFormat& format : supported_formats) {
+  __android_log_print(ANDROID_LOG_ERROR, "GetPayloadTypesAndDefaultCodecs", "%s %lu", format.name.c_str(), (unsigned long) format.scalability_modes.size());
+
     VideoCodec codec = cricket::CreateVideoCodec(format);
     bool isFecCodec = absl::EqualsIgnoreCase(codec.name, kUlpfecCodecName) ||
                       absl::EqualsIgnoreCase(codec.name, kFlexfecCodecName);
diff --git a/src/modules/video_coding/codecs/av1/av1_svc_config.cc b/src/modules/video_coding/codecs/av1/av1_svc_config.cc
index 30c0f30..325bc4e 100644
--- a/src/modules/video_coding/codecs/av1/av1_svc_config.cc
+++ b/src/modules/video_coding/codecs/av1/av1_svc_config.cc
@@ -20,6 +20,7 @@
 #include "rtc_base/checks.h"
 #include "rtc_base/logging.h"
 #include "rtc_base/strings/string_builder.h"
+#include <android/log.h>
 
 namespace webrtc {
 namespace {
@@ -58,6 +59,9 @@ LibaomAv1EncoderSupportedScalabilityModes() {
   for (ScalabilityMode scalability_mode : kAllScalabilityModes) {
     if (ScalabilityStructureConfig(scalability_mode) != absl::nullopt) {
       scalability_modes.push_back(scalability_mode);
+              auto sv2 = ScalabilityModeToString(scalability_mode);
+        std::string s2 = {sv2.begin(), sv2.end()};
+        __android_log_print(ANDROID_LOG_ERROR, "LibaomAv1EncoderSupportedScalabilityModes", "%s", s2.c_str());
     }
   }
   return scalability_modes;
diff --git a/src/modules/video_coding/codecs/h264/h264.cc b/src/modules/video_coding/codecs/h264/h264.cc
index 5b9f033..177b8e3 100644
--- a/src/modules/video_coding/codecs/h264/h264.cc
+++ b/src/modules/video_coding/codecs/h264/h264.cc
@@ -19,6 +19,7 @@
 #include "api/video_codecs/sdp_video_format.h"
 #include "media/base/media_constants.h"
 #include "rtc_base/trace_event.h"
+#include <android/log.h>
 
 #if defined(WEBRTC_USE_H264)
 #include "modules/video_coding/codecs/h264/h264_decoder_impl.h"
@@ -61,6 +62,9 @@ SdpVideoFormat CreateH264Format(H264Profile profile,
   if (add_scalability_modes) {
     for (const auto scalability_mode : kSupportedScalabilityModes) {
       scalability_modes.push_back(scalability_mode);
+              auto sv2 = ScalabilityModeToString(scalability_mode);
+        std::string s2 = {sv2.begin(), sv2.end()};
+        __android_log_print(ANDROID_LOG_ERROR, "H264ProfileLevelIdToString", "%s", s2.c_str());
     }
   }
   return SdpVideoFormat(
diff --git a/src/modules/video_coding/codecs/vp9/vp9.cc b/src/modules/video_coding/codecs/vp9/vp9.cc
index c1dbf3a..2a810be 100644
--- a/src/modules/video_coding/codecs/vp9/vp9.cc
+++ b/src/modules/video_coding/codecs/vp9/vp9.cc
@@ -25,6 +25,7 @@
 #include "vpx/vp8cx.h"
 #include "vpx/vp8dx.h"
 #include "vpx/vpx_codec.h"
+#include <android/log.h>
 
 namespace webrtc {
 
@@ -43,6 +44,9 @@ std::vector<SdpVideoFormat> SupportedVP9Codecs(bool add_scalability_modes) {
     for (const auto scalability_mode : kAllScalabilityModes) {
       if (ScalabilityStructureConfig(scalability_mode).has_value()) {
         scalability_modes.push_back(scalability_mode);
+                auto sv2 = ScalabilityModeToString(scalability_mode);
+        std::string s2 = {sv2.begin(), sv2.end()};
+        __android_log_print(ANDROID_LOG_ERROR, "SupportedVP9Codecs", "%s", s2.c_str());
       }
     }
   }
diff --git a/src/pc/rtp_sender.cc b/src/pc/rtp_sender.cc
index cdae159..f7827da 100644
--- a/src/pc/rtp_sender.cc
+++ b/src/pc/rtp_sender.cc
@@ -237,6 +237,7 @@ void RtpSenderBase::SetParametersInternal(const RtpParameters& parameters,
   RTC_DCHECK_RUN_ON(signaling_thread_);
   RTC_DCHECK(!stopped_);
 
+  // nope2
   if (UnimplementedRtpParameterHasValue(parameters)) {
     RTCError error(
         RTCErrorType::UNSUPPORTED_PARAMETER,
@@ -247,6 +248,7 @@ void RtpSenderBase::SetParametersInternal(const RtpParameters& parameters,
     return;
   }
   if (!media_channel_ || !ssrc_) {
+    // nope3
     auto result = cricket::CheckRtpParametersInvalidModificationAndValues(
         init_parameters_, parameters, codec_preferences_, absl::nullopt);
     if (result.ok()) {
@@ -265,6 +267,7 @@ void RtpSenderBase::SetParametersInternal(const RtpParameters& parameters,
                                              old_parameters.encodings);
     }
 
+    // nope4
     RTCError result = cricket::CheckRtpParametersInvalidModificationAndValues(
         old_parameters, rtp_parameters);
     if (!result.ok()) {
@@ -272,6 +275,8 @@ void RtpSenderBase::SetParametersInternal(const RtpParameters& parameters,
       return;
     }
 
+    // nope ?
+
     result = CheckCodecParameters(rtp_parameters);
     if (!result.ok()) {
       webrtc::InvokeSetParametersCallback(callback, result);
@@ -353,7 +358,8 @@ RTCError RtpSenderBase::CheckCodecParameters(const RtpParameters& parameters) {
       send_codec_with_svc_info = *codec_match;
     }
   }
-
+  
+  // here
   return cricket::CheckScalabilityModeValues(parameters, codec_preferences_,
                                              send_codec_with_svc_info);
 }
@@ -364,6 +370,7 @@ RTCError RtpSenderBase::SetParameters(const RtpParameters& parameters) {
   RTCError result = CheckSetParameters(parameters);
   if (!result.ok())
     return result;
+  // nope
 
   // Some tests rely on working in single thread mode without a run loop and a
   // blocking call is required to keep them working. The encoder configuration
diff --git a/src/pc/rtp_sender.h b/src/pc/rtp_sender.h
index d29c376..4332ba2 100644
--- a/src/pc/rtp_sender.h
+++ b/src/pc/rtp_sender.h
@@ -21,6 +21,7 @@
 #include <memory>
 #include <string>
 #include <vector>
+#include <android/log.h>
 
 #include "absl/types/optional.h"
 #include "api/crypto/frame_encryptor_interface.h"
@@ -225,6 +226,22 @@ class RtpSenderBase : public RtpSenderInternal, public ObserverInterface {
 
   void SetCodecPreferences(
       std::vector<cricket::Codec> codec_preferences) override {
+    __android_log_print(ANDROID_LOG_ERROR, "SetCodecPreferences", "%lu",
+                        (unsigned long)codec_preferences.size());
+    for (int i = 0; i < codec_preferences.size(); ++i) {
+      __android_log_print(
+          ANDROID_LOG_ERROR, "SetCodecPreferences scalability_modes", "%lu",
+          (unsigned long)codec_preferences[i].scalability_modes.size());
+
+      for (int j = 0; j < codec_preferences[i].scalability_modes.size(); ++j) {
+        auto sv =
+            ScalabilityModeToString(codec_preferences[i].scalability_modes[j]);
+        std::string s = {sv.begin(), sv.end()};
+
+        __android_log_print(ANDROID_LOG_ERROR, "SetCodecPreferences MOD", "%s",
+                            s.c_str());
+      }
+    }
     codec_preferences_ = codec_preferences;
   }
 
diff --git a/src/pc/rtp_transceiver.cc b/src/pc/rtp_transceiver.cc
index 815ec9d..381ba9f 100644
--- a/src/pc/rtp_transceiver.cc
+++ b/src/pc/rtp_transceiver.cc
@@ -17,6 +17,7 @@
 #include <string>
 #include <utility>
 #include <vector>
+#include <android/log.h>
 
 #include "absl/algorithm/container.h"
 #include "absl/memory/memory.h"
@@ -171,6 +172,28 @@ RtpTransceiver::RtpTransceiver(
   RTC_DCHECK(media_type_ == cricket::MEDIA_TYPE_AUDIO ||
              media_type_ == cricket::MEDIA_TYPE_VIDEO);
   RTC_DCHECK_EQ(sender->media_type(), receiver->media_type());
+
+{
+  auto aa = media_engine()->video().send_codecs(false);
+
+      __android_log_print(ANDROID_LOG_ERROR, "RtpTransceiver", "%lu",
+                        (unsigned long)aa.size());
+    for (int i = 0; i < aa.size(); ++i) {
+      __android_log_print(
+          ANDROID_LOG_ERROR, "RtpTransceiver scalability_modes", "%lu",
+          (unsigned long)aa[i].scalability_modes.size());
+
+      for (int j = 0; j < aa[i].scalability_modes.size(); ++j) {
+        auto sv =
+            ScalabilityModeToString(aa[i].scalability_modes[j]);
+        std::string s = {sv.begin(), sv.end()};
+
+        __android_log_print(ANDROID_LOG_ERROR, "RtpTransceiver MOD", "%s",
+                            s.c_str());
+      }
+    }
+}
+
   sender->internal()->SetCodecPreferences(
       sender->media_type() == cricket::MEDIA_TYPE_VIDEO
           ? media_engine()->video().send_codecs(false)
diff --git a/src/sdk/BUILD.gn b/src/sdk/BUILD.gn
index 4f5ceb5..a743579 100644
--- a/src/sdk/BUILD.gn
+++ b/src/sdk/BUILD.gn
@@ -991,6 +991,15 @@ if (is_ios || is_mac) {
         "objc/api/peerconnection/RTCRtcpParameters+Private.h",
         "objc/api/peerconnection/RTCRtcpParameters.h",
         "objc/api/peerconnection/RTCRtcpParameters.mm",
+        "objc/api/peerconnection/RTCRtpCapabilities.h",
+        "objc/api/peerconnection/RTCRtpCapabilities.mm",
+        "objc/api/peerconnection/RTCRtpCapabilities+Private.h",
+        "objc/api/peerconnection/RTCRtpCodecCapability.h",
+        "objc/api/peerconnection/RTCRtpCodecCapability.mm",
+        "objc/api/peerconnection/RTCRtpCodecCapability+Private.h",
+        "objc/api/peerconnection/RTCRtpHeaderExtensionCapability.h",
+        "objc/api/peerconnection/RTCRtpHeaderExtensionCapability.mm",
+        "objc/api/peerconnection/RTCRtpHeaderExtensionCapability+Private.h",
         "objc/api/peerconnection/RTCRtpCodecParameters+Private.h",
         "objc/api/peerconnection/RTCRtpCodecParameters.h",
         "objc/api/peerconnection/RTCRtpCodecParameters.mm",
@@ -1309,6 +1318,9 @@ if (is_ios || is_mac) {
           "objc/api/peerconnection/RTCPeerConnectionFactory.h",
           "objc/api/peerconnection/RTCPeerConnectionFactoryOptions.h",
           "objc/api/peerconnection/RTCRtcpParameters.h",
+          "objc/api/peerconnection/RTCRtpCapabilities.h",
+          "objc/api/peerconnection/RTCRtpCodecCapability.h",
+          "objc/api/peerconnection/RTCRtpHeaderExtensionCapability.h",
           "objc/api/peerconnection/RTCRtpCodecParameters.h",
           "objc/api/peerconnection/RTCRtpEncodingParameters.h",
           "objc/api/peerconnection/RTCRtpHeaderExtension.h",
@@ -1423,6 +1435,9 @@ if (is_ios || is_mac) {
           "objc/api/peerconnection/RTCPeerConnectionFactory.h",
           "objc/api/peerconnection/RTCPeerConnectionFactoryOptions.h",
           "objc/api/peerconnection/RTCRtcpParameters.h",
+          "objc/api/peerconnection/RTCRtpCapabilities.h",
+          "objc/api/peerconnection/RTCRtpCodecCapability.h",
+          "objc/api/peerconnection/RTCRtpHeaderExtensionCapability.h",
           "objc/api/peerconnection/RTCRtpCodecParameters.h",
           "objc/api/peerconnection/RTCRtpEncodingParameters.h",
           "objc/api/peerconnection/RTCRtpHeaderExtension.h",
diff --git a/src/sdk/android/api/org/webrtc/RtpParameters.java b/src/sdk/android/api/org/webrtc/RtpParameters.java
index 9ca8311..1fcffe7 100644
--- a/src/sdk/android/api/org/webrtc/RtpParameters.java
+++ b/src/sdk/android/api/org/webrtc/RtpParameters.java
@@ -73,6 +73,8 @@ public class RtpParameters {
     @Nullable public Integer maxFramerate;
     // The number of temporal layers for video.
     @Nullable public Integer numTemporalLayers;
+    // https://w3c.github.io/webrtc-svc/#rtcrtpencodingparameters
+    @Nullable public String scalabilityMode;
     // If non-null, scale the width and height down by this factor for video. If null,
     // implementation default scaling factor will be used.
     @Nullable public Double scaleResolutionDownBy;
@@ -93,7 +95,7 @@ public class RtpParameters {
     @CalledByNative("Encoding")
     Encoding(String rid, boolean active, double bitratePriority, @Priority int networkPriority,
         Integer maxBitrateBps, Integer minBitrateBps, Integer maxFramerate,
-        Integer numTemporalLayers, Double scaleResolutionDownBy, Long ssrc,
+        Integer numTemporalLayers, String scalabilityMode, Double scaleResolutionDownBy, Long ssrc,
         boolean adaptiveAudioPacketTime) {
       this.rid = rid;
       this.active = active;
@@ -103,6 +105,7 @@ public class RtpParameters {
       this.minBitrateBps = minBitrateBps;
       this.maxFramerate = maxFramerate;
       this.numTemporalLayers = numTemporalLayers;
+      this.scalabilityMode = scalabilityMode;
       this.scaleResolutionDownBy = scaleResolutionDownBy;
       this.ssrc = ssrc;
       this.adaptiveAudioPacketTime = adaptiveAudioPacketTime;
@@ -154,6 +157,12 @@ public class RtpParameters {
       return numTemporalLayers;
     }
 
+    @Nullable
+    @CalledByNative("Encoding")
+    String getScalabilityMode() {
+      return scalabilityMode;
+    }
+
     @Nullable
     @CalledByNative("Encoding")
     Double getScaleResolutionDownBy() {
diff --git a/src/sdk/android/src/jni/pc/rtp_parameters.cc b/src/sdk/android/src/jni/pc/rtp_parameters.cc
index 4bd9ee0..1f5957b 100644
--- a/src/sdk/android/src/jni/pc/rtp_parameters.cc
+++ b/src/sdk/android/src/jni/pc/rtp_parameters.cc
@@ -52,6 +52,7 @@ ScopedJavaLocalRef<jobject> NativeToJavaRtpEncodingParameter(
       NativeToJavaInteger(env, encoding.min_bitrate_bps),
       NativeToJavaInteger(env, encoding.max_framerate),
       NativeToJavaInteger(env, encoding.num_temporal_layers),
+      NativeToJavaString(env, encoding.scalability_mode),
       NativeToJavaDouble(env, encoding.scale_resolution_down_by),
       encoding.ssrc ? NativeToJavaLong(env, *encoding.ssrc) : nullptr,
       encoding.adaptive_ptime);
@@ -112,6 +113,11 @@ RtpEncodingParameters JavaToNativeRtpEncodingParameters(
       Java_Encoding_getNumTemporalLayers(jni, j_encoding_parameters);
   encoding.num_temporal_layers =
       JavaToNativeOptionalInt(jni, j_num_temporal_layers);
+  ScopedJavaLocalRef<jstring> j_scalability_mode =
+      Java_Encoding_getScalabilityMode(jni, j_encoding_parameters);
+  if (!IsNull(jni, j_scalability_mode)) {
+    encoding.scalability_mode = JavaToNativeString(jni, j_scalability_mode);
+  }
   ScopedJavaLocalRef<jobject> j_scale_resolution_down_by =
       Java_Encoding_getScaleResolutionDownBy(jni, j_encoding_parameters);
   encoding.scale_resolution_down_by =
diff --git a/src/sdk/android/src/jni/pc/rtp_sender.cc b/src/sdk/android/src/jni/pc/rtp_sender.cc
index ddb53f6..533d0e9 100644
--- a/src/sdk/android/src/jni/pc/rtp_sender.cc
+++ b/src/sdk/android/src/jni/pc/rtp_sender.cc
@@ -70,7 +70,7 @@ jlong JNI_RtpSender_GetDtmfSender(JNIEnv* jni, jlong j_rtp_sender_pointer) {
           ->GetDtmfSender()
           .release());
 }
-
+ // here
 jboolean JNI_RtpSender_SetParameters(
     JNIEnv* jni,
     jlong j_rtp_sender_pointer,
diff --git a/src/sdk/objc/api/peerconnection/RTCPeerConnectionFactory.h b/src/sdk/objc/api/peerconnection/RTCPeerConnectionFactory.h
index 5575af9..f8dfae1 100644
--- a/src/sdk/objc/api/peerconnection/RTCPeerConnectionFactory.h
+++ b/src/sdk/objc/api/peerconnection/RTCPeerConnectionFactory.h
@@ -23,6 +23,10 @@ NS_ASSUME_NONNULL_BEGIN
 @class RTC_OBJC_TYPE(RTCVideoSource);
 @class RTC_OBJC_TYPE(RTCVideoTrack);
 @class RTC_OBJC_TYPE(RTCPeerConnectionFactoryOptions);
+@class RTC_OBJC_TYPE(RTCRtpCapabilities);
+
+typedef NS_ENUM(NSInteger, RTCRtpMediaType);
+
 @protocol RTC_OBJC_TYPE
 (RTCPeerConnectionDelegate);
 @protocol RTC_OBJC_TYPE
@@ -51,6 +55,10 @@ RTC_OBJC_EXPORT
             decoderFactory:(nullable id<RTC_OBJC_TYPE(RTCVideoDecoderFactory)>)decoderFactory
                audioDevice:(nullable id<RTC_OBJC_TYPE(RTCAudioDevice)>)audioDevice;
 
+- (RTC_OBJC_TYPE(RTCRtpCapabilities) *)rtpSenderCapabilitiesFor:(RTCRtpMediaType)mediaType;
+
+- (RTC_OBJC_TYPE(RTCRtpCapabilities) *)rtpReceiverCapabilitiesFor:(RTCRtpMediaType)mediaType;
+
 /** Initialize an RTCAudioSource with constraints. */
 - (RTC_OBJC_TYPE(RTCAudioSource) *)audioSourceWithConstraints:
     (nullable RTC_OBJC_TYPE(RTCMediaConstraints) *)constraints;
diff --git a/src/sdk/objc/api/peerconnection/RTCPeerConnectionFactory.mm b/src/sdk/objc/api/peerconnection/RTCPeerConnectionFactory.mm
index 62b5554..e63104d 100644
--- a/src/sdk/objc/api/peerconnection/RTCPeerConnectionFactory.mm
+++ b/src/sdk/objc/api/peerconnection/RTCPeerConnectionFactory.mm
@@ -21,6 +21,9 @@
 #import "RTCPeerConnection+Private.h"
 #import "RTCVideoSource+Private.h"
 #import "RTCVideoTrack+Private.h"
+#import "RTCRtpReceiver+Private.h"
+#import "RTCRtpCapabilities+Private.h"
+#import "RTCRtpCodecCapability+Private.h"
 #import "base/RTCLogging.h"
 #import "base/RTCVideoDecoderFactory.h"
 #import "base/RTCVideoEncoderFactory.h"
@@ -116,6 +119,20 @@
 #endif
 }
 
+- (RTC_OBJC_TYPE(RTCRtpCapabilities) *)rtpSenderCapabilitiesFor:(RTCRtpMediaType)mediaType {
+
+  webrtc::RtpCapabilities capabilities = _nativeFactory->GetRtpSenderCapabilities([RTCRtpReceiver nativeMediaTypeForMediaType: mediaType]);
+
+  return [[RTCRtpCapabilities alloc] initWithNativeCapabilities: capabilities];
+}
+
+- (RTC_OBJC_TYPE(RTCRtpCapabilities) *)rtpReceiverCapabilitiesFor:(RTCRtpMediaType)mediaType {
+
+  webrtc::RtpCapabilities capabilities = _nativeFactory->GetRtpReceiverCapabilities([RTCRtpReceiver nativeMediaTypeForMediaType: mediaType]);
+
+  return [[RTCRtpCapabilities alloc] initWithNativeCapabilities: capabilities];
+}
+
 - (instancetype)initNative {
   if (self = [super init]) {
     _networkThread = rtc::Thread::CreateWithSocketServer();
diff --git a/src/sdk/objc/api/peerconnection/RTCRtpCapabilities+Private.h b/src/sdk/objc/api/peerconnection/RTCRtpCapabilities+Private.h
new file mode 100644
index 0000000..15c8fe3
--- /dev/null
+++ b/src/sdk/objc/api/peerconnection/RTCRtpCapabilities+Private.h
@@ -0,0 +1,33 @@
+/*
+ * Copyright 2023 LiveKit
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#import "RTCRtpCapabilities.h"
+
+#include "api/rtp_parameters.h"
+
+NS_ASSUME_NONNULL_BEGIN
+
+@interface RTC_OBJC_TYPE (RTCRtpCapabilities)
+()
+
+    @property(nonatomic, readonly) webrtc::RtpCapabilities nativeCapabilities;
+
+- (instancetype)initWithNativeCapabilities:(const webrtc::RtpCapabilities &)nativeCapabilities
+    NS_DESIGNATED_INITIALIZER;
+
+@end
+
+NS_ASSUME_NONNULL_END
\ No newline at end of file
diff --git a/src/sdk/objc/api/peerconnection/RTCRtpCapabilities.h b/src/sdk/objc/api/peerconnection/RTCRtpCapabilities.h
new file mode 100644
index 0000000..2dea41a
--- /dev/null
+++ b/src/sdk/objc/api/peerconnection/RTCRtpCapabilities.h
@@ -0,0 +1,37 @@
+/*
+ * Copyright 2023 LiveKit
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#import <Foundation/Foundation.h>
+
+#import "RTCMacros.h"
+
+@class RTC_OBJC_TYPE(RTCRtpCodecCapability);
+@class RTC_OBJC_TYPE(RTCRtpHeaderExtensionCapability);
+
+NS_ASSUME_NONNULL_BEGIN
+
+RTC_OBJC_EXPORT
+@interface RTC_OBJC_TYPE (RTCRtpCapabilities) : NSObject
+
+- (instancetype)init NS_UNAVAILABLE;
+
+@property(nonatomic, readonly) NSArray<RTC_OBJC_TYPE(RTCRtpCodecCapability) *> *codecs;
+
+@property(nonatomic, readonly) NSArray<RTC_OBJC_TYPE(RTCRtpHeaderExtensionCapability) *> *header_extensions;
+
+@end
+
+NS_ASSUME_NONNULL_END
\ No newline at end of file
diff --git a/src/sdk/objc/api/peerconnection/RTCRtpCapabilities.mm b/src/sdk/objc/api/peerconnection/RTCRtpCapabilities.mm
new file mode 100644
index 0000000..7f73108
--- /dev/null
+++ b/src/sdk/objc/api/peerconnection/RTCRtpCapabilities.mm
@@ -0,0 +1,63 @@
+/*
+ * Copyright 2023 LiveKit
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#import "RTCRtpCapabilities+Private.h"
+#import "RTCRtpCodecCapability+Private.h"
+#import "RTCRtpHeaderExtensionCapability+Private.h"
+
+#import "RTCMediaStreamTrack.h"
+#import "helpers/NSString+StdString.h"
+
+#include "media/base/media_constants.h"
+#include "rtc_base/checks.h"
+
+@implementation RTC_OBJC_TYPE (RTCRtpCapabilities)
+
+@synthesize nativeCapabilities = _nativeCapabilities;
+
+- (instancetype)initWithNativeCapabilities:(const webrtc::RtpCapabilities &)nativeCapabilities {
+  if (self = [super init]) {
+    _nativeCapabilities = nativeCapabilities;
+  }
+
+  return self;
+}
+
+- (NSArray<RTC_OBJC_TYPE(RTCRtpCodecCapability) *> *)codecs {
+  NSMutableArray *result = [NSMutableArray array];
+
+  for (auto &element : _nativeCapabilities.codecs) {
+    RTCRtpCodecCapability *object =
+        [[RTCRtpCodecCapability alloc] initWithNativeCodecCapability:element];
+    [result addObject:object];
+  }
+
+  return result;
+}
+
+- (NSArray<RTC_OBJC_TYPE(RTCRtpHeaderExtensionCapability) *> *)header_extensions {
+  NSMutableArray *result = [NSMutableArray array];
+
+  for (auto &element : _nativeCapabilities.header_extensions) {
+    RTCRtpHeaderExtensionCapability *object =
+        [[RTCRtpHeaderExtensionCapability alloc] initWithNativeHeaderExtensionCapability:element];
+    [result addObject:object];
+  }
+
+  return result;
+}
+
+@end
\ No newline at end of file
diff --git a/src/sdk/objc/api/peerconnection/RTCRtpCodecCapability+Private.h b/src/sdk/objc/api/peerconnection/RTCRtpCodecCapability+Private.h
new file mode 100644
index 0000000..b36d26c
--- /dev/null
+++ b/src/sdk/objc/api/peerconnection/RTCRtpCodecCapability+Private.h
@@ -0,0 +1,33 @@
+/*
+ * Copyright 2023 LiveKit
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#import "RTCRtpCodecCapability.h"
+
+#include "api/rtp_parameters.h"
+
+NS_ASSUME_NONNULL_BEGIN
+
+@interface RTC_OBJC_TYPE (RTCRtpCodecCapability)
+()
+
+    @property(nonatomic, readonly) webrtc::RtpCodecCapability nativeCodecCapability;
+
+- (instancetype)initWithNativeCodecCapability:
+    (const webrtc::RtpCodecCapability &)nativeCodecCapability NS_DESIGNATED_INITIALIZER;
+
+@end
+
+NS_ASSUME_NONNULL_END
\ No newline at end of file
diff --git a/src/sdk/objc/api/peerconnection/RTCRtpCodecCapability.h b/src/sdk/objc/api/peerconnection/RTCRtpCodecCapability.h
new file mode 100644
index 0000000..0daf40e
--- /dev/null
+++ b/src/sdk/objc/api/peerconnection/RTCRtpCodecCapability.h
@@ -0,0 +1,63 @@
+/*
+ * Copyright 2023 LiveKit
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#import <Foundation/Foundation.h>
+
+#import "RTCMacros.h"
+
+typedef NS_ENUM(NSInteger, RTCRtpMediaType);
+
+NS_ASSUME_NONNULL_BEGIN
+
+RTC_OBJC_EXPORT
+@interface RTC_OBJC_TYPE (RTCRtpCodecCapability) : NSObject
+
+// Build MIME "type/subtype" string from `name` and `kind`.
+@property(nonatomic, readonly) NSString *mimeType;
+
+// Used to identify the codec. Equivalent to MIME subtype.
+@property(nonatomic, copy) NSString *name;
+
+// The media type of this codec. Equivalent to MIME top-level type.
+@property(nonatomic, assign) RTCRtpMediaType kind;
+
+// Clock rate in Hertz. If unset, the codec is applicable to any clock rate.
+@property(nonatomic, copy, nullable) NSNumber *clockRate;
+
+// Default payload type for this codec. Mainly needed for codecs that use
+// that have statically assigned payload types.
+@property(nonatomic, copy, nullable) NSNumber *preferredPayloadType;
+
+// The number of audio channels supported. Unused for video codecs.
+@property(nonatomic, copy, nullable) NSNumber *numChannels;
+
+// Codec-specific parameters that must be signaled to the remote party.
+//
+// Corresponds to "a=fmtp" parameters in SDP.
+//
+// Contrary to ORTC, these parameters are named using all lowercase strings.
+// This helps make the mapping to SDP simpler, if an application is using SDP.
+// Boolean values are represented by the string "1".
+// std::map<std::string, std::string> parameters;
+@property(nonatomic, copy) NSDictionary<NSString *, NSString *> *parameters;
+
+// Feedback mechanisms supported for this codec.
+// std::vector<RtcpFeedback> rtcp_feedback;
+// Not implemented.
+
+@end
+
+NS_ASSUME_NONNULL_END
\ No newline at end of file
diff --git a/src/sdk/objc/api/peerconnection/RTCRtpCodecCapability.mm b/src/sdk/objc/api/peerconnection/RTCRtpCodecCapability.mm
new file mode 100644
index 0000000..341cde4
--- /dev/null
+++ b/src/sdk/objc/api/peerconnection/RTCRtpCodecCapability.mm
@@ -0,0 +1,138 @@
+/*
+ * Copyright 2023 LiveKit
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#import "RTCRtpCodecCapability+Private.h"
+
+#import "RTCRtpReceiver+Private.h"
+
+#import "RTCMediaStreamTrack.h"
+#import "helpers/NSString+StdString.h"
+
+#include "media/base/media_constants.h"
+#include "rtc_base/checks.h"
+
+@implementation RTC_OBJC_TYPE (RTCRtpCodecCapability)
+
+@synthesize nativeCodecCapability = _nativeCodecCapability;
+
+- (instancetype)init {
+  return [self initWithNativeCodecCapability:webrtc::RtpCodecCapability()];
+}
+
+- (instancetype)initWithNativeCodecCapability:
+    (const webrtc::RtpCodecCapability &)nativeCodecCapability {
+  if (self = [super init]) {
+    _nativeCodecCapability = nativeCodecCapability;
+  }
+
+  return self;
+}
+
+- (NSString *)mimeType {
+  return [NSString stringWithUTF8String:_nativeCodecCapability.mime_type().c_str()];
+}
+
+- (NSString *)name {
+  return [NSString stringWithUTF8String:_nativeCodecCapability.name.c_str()];
+}
+
+- (void)setName:(NSString *)name {
+  _nativeCodecCapability.name = std::string([name UTF8String]);
+}
+
+- (RTCRtpMediaType)kind {
+  return [RTCRtpReceiver mediaTypeForNativeMediaType:_nativeCodecCapability.kind];
+}
+
+- (void)setKind:(RTCRtpMediaType)kind {
+  _nativeCodecCapability.kind = [RTCRtpReceiver nativeMediaTypeForMediaType:kind];
+}
+
+- (NSNumber *)clockRate {
+  if (!_nativeCodecCapability.clock_rate) {
+    return nil;
+  }
+
+  return [NSNumber numberWithInt:*_nativeCodecCapability.clock_rate];
+}
+
+- (void)setClockRate:(NSNumber *)clockRate {
+  if (clockRate == nil) {
+    _nativeCodecCapability.clock_rate = absl::optional<int>();
+    return;
+  }
+
+  _nativeCodecCapability.clock_rate = absl::optional<int>(clockRate.intValue);
+}
+
+- (NSNumber *)preferredPayloadType {
+  if (!_nativeCodecCapability.preferred_payload_type) {
+    return nil;
+  }
+
+  return [NSNumber numberWithInt:*_nativeCodecCapability.preferred_payload_type];
+}
+
+- (void)setPreferredPayloadType:(NSNumber *)preferredPayloadType {
+  if (preferredPayloadType == nil) {
+    _nativeCodecCapability.preferred_payload_type = absl::optional<int>();
+    return;
+  }
+
+  _nativeCodecCapability.preferred_payload_type =
+      absl::optional<int>(preferredPayloadType.intValue);
+}
+
+- (NSNumber *)numChannels {
+  if (!_nativeCodecCapability.num_channels) {
+    return nil;
+  }
+
+  return [NSNumber numberWithInt:*_nativeCodecCapability.num_channels];
+}
+
+- (void)setNumChannels:(NSNumber *)numChannels {
+  if (numChannels == nil) {
+    _nativeCodecCapability.num_channels = absl::optional<int>();
+    return;
+  }
+
+  _nativeCodecCapability.num_channels = absl::optional<int>(numChannels.intValue);
+}
+
+- (NSDictionary<NSString *, NSString *> *)parameters {
+  NSMutableDictionary *result = [NSMutableDictionary dictionary];
+  auto _parameters = _nativeCodecCapability.parameters;
+  for (auto it = _parameters.begin(); it != _parameters.end(); ++it) {
+    [result setObject:[NSString stringForStdString:it->second]
+               forKey:[NSString stringForStdString:it->first]];
+  }
+
+  return result;
+}
+
+- (void)setParameters:(NSDictionary<NSString *, NSString *> *)parameters {
+  std::map<std::string, std::string> _parameters;
+  for (NSString *paramKey in parameters.allKeys) {
+    std::string key = [NSString stdStringForString:paramKey];
+    std::string value = [NSString stdStringForString:parameters[paramKey]];
+    _parameters[key] = value;
+  }
+
+  _nativeCodecCapability.parameters = _parameters;
+}
+
+@end
\ No newline at end of file
diff --git a/src/sdk/objc/api/peerconnection/RTCRtpEncodingParameters.h b/src/sdk/objc/api/peerconnection/RTCRtpEncodingParameters.h
index 07f6b7a..d055115 100644
--- a/src/sdk/objc/api/peerconnection/RTCRtpEncodingParameters.h
+++ b/src/sdk/objc/api/peerconnection/RTCRtpEncodingParameters.h
@@ -51,6 +51,10 @@ RTC_OBJC_EXPORT
  */
 @property(nonatomic, copy, nullable) NSNumber *numTemporalLayers;
 
+/** A case-sensitive identifier of the scalability mode to be used for this stream.
+  https://w3c.github.io/webrtc-svc/#rtcrtpencodingparameters */
+@property(nonatomic, copy, nullable) NSString *scalabilityMode;
+
 /** Scale the width and height down by this factor for video. If nil,
  * implementation default scaling factor will be used.
  */
diff --git a/src/sdk/objc/api/peerconnection/RTCRtpEncodingParameters.mm b/src/sdk/objc/api/peerconnection/RTCRtpEncodingParameters.mm
index d6087da..e2020bb 100644
--- a/src/sdk/objc/api/peerconnection/RTCRtpEncodingParameters.mm
+++ b/src/sdk/objc/api/peerconnection/RTCRtpEncodingParameters.mm
@@ -20,6 +20,7 @@
 @synthesize minBitrateBps = _minBitrateBps;
 @synthesize maxFramerate = _maxFramerate;
 @synthesize numTemporalLayers = _numTemporalLayers;
+@synthesize scalabilityMode = _scalabilityMode;
 @synthesize scaleResolutionDownBy = _scaleResolutionDownBy;
 @synthesize ssrc = _ssrc;
 @synthesize bitratePriority = _bitratePriority;
@@ -52,6 +53,9 @@
     if (nativeParameters.num_temporal_layers) {
       _numTemporalLayers = [NSNumber numberWithInt:*nativeParameters.num_temporal_layers];
     }
+    if (nativeParameters.scalability_mode) {
+      _scalabilityMode = [NSString stringWithUTF8String:nativeParameters.scalability_mode->c_str()];
+    }
     if (nativeParameters.scale_resolution_down_by) {
       _scaleResolutionDownBy =
           [NSNumber numberWithDouble:*nativeParameters.scale_resolution_down_by];
@@ -85,6 +89,9 @@
   if (_numTemporalLayers != nil) {
     parameters.num_temporal_layers = absl::optional<int>(_numTemporalLayers.intValue);
   }
+  if (_scalabilityMode != nil) {
+    parameters.scalability_mode = absl::optional<std::string>(std::string([_scalabilityMode UTF8String]));
+  }
   if (_scaleResolutionDownBy != nil) {
     parameters.scale_resolution_down_by =
         absl::optional<double>(_scaleResolutionDownBy.doubleValue);
diff --git a/src/sdk/objc/api/peerconnection/RTCRtpHeaderExtensionCapability+Private.h b/src/sdk/objc/api/peerconnection/RTCRtpHeaderExtensionCapability+Private.h
new file mode 100644
index 0000000..2fa8c25
--- /dev/null
+++ b/src/sdk/objc/api/peerconnection/RTCRtpHeaderExtensionCapability+Private.h
@@ -0,0 +1,33 @@
+/*
+ * Copyright 2023 LiveKit
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#import "RTCRtpHeaderExtensionCapability.h"
+
+#include "api/rtp_parameters.h"
+
+NS_ASSUME_NONNULL_BEGIN
+
+@interface RTC_OBJC_TYPE (RTCRtpHeaderExtensionCapability)
+()
+
+    @property(nonatomic, readonly) webrtc::RtpHeaderExtensionCapability nativeHeaderExtensionCapability;
+
+- (instancetype)initWithNativeHeaderExtensionCapability:
+    (const webrtc::RtpHeaderExtensionCapability &)nativeHeaderExtensionCapability NS_DESIGNATED_INITIALIZER;
+
+@end
+
+NS_ASSUME_NONNULL_END
\ No newline at end of file
diff --git a/src/sdk/objc/api/peerconnection/RTCRtpHeaderExtensionCapability.h b/src/sdk/objc/api/peerconnection/RTCRtpHeaderExtensionCapability.h
new file mode 100644
index 0000000..27bb0e5
--- /dev/null
+++ b/src/sdk/objc/api/peerconnection/RTCRtpHeaderExtensionCapability.h
@@ -0,0 +1,37 @@
+/*
+ * Copyright 2023 LiveKit
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#import <Foundation/Foundation.h>
+
+#import "RTCMacros.h"
+
+NS_ASSUME_NONNULL_BEGIN
+
+RTC_OBJC_EXPORT
+@interface RTC_OBJC_TYPE (RTCRtpHeaderExtensionCapability) : NSObject
+
+// URI of this extension, as defined in RFC8285.
+@property(nonatomic, readonly) NSString *uri;
+
+// Preferred value of ID that goes in the packet.
+@property(nonatomic, assign) NSNumber *preferred_id;
+
+// If true, it's preferred that the value in the header is encrypted.
+@property(nonatomic, assign) BOOL preferred_encrypt;
+
+@end
+
+NS_ASSUME_NONNULL_END
\ No newline at end of file
diff --git a/src/sdk/objc/api/peerconnection/RTCRtpHeaderExtensionCapability.mm b/src/sdk/objc/api/peerconnection/RTCRtpHeaderExtensionCapability.mm
new file mode 100644
index 0000000..e36d2b4
--- /dev/null
+++ b/src/sdk/objc/api/peerconnection/RTCRtpHeaderExtensionCapability.mm
@@ -0,0 +1,54 @@
+/*
+ * Copyright 2023 LiveKit
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#import "RTCRtpHeaderExtensionCapability+Private.h"
+
+#import "helpers/NSString+StdString.h"
+
+#include "media/base/media_constants.h"
+#include "rtc_base/checks.h"
+
+@implementation RTC_OBJC_TYPE (RTCRtpHeaderExtensionCapability)
+
+@synthesize nativeHeaderExtensionCapability = _nativeHeaderExtensionCapability;
+
+- (instancetype)init {
+  return [self initWithNativeHeaderExtensionCapability:webrtc::RtpHeaderExtensionCapability()];
+}
+
+- (instancetype)initWithNativeHeaderExtensionCapability:
+    (const webrtc::RtpHeaderExtensionCapability &)nativeHeaderExtensionCapability {
+  if (self = [super init]) {
+    _nativeHeaderExtensionCapability = nativeHeaderExtensionCapability;
+  }
+
+  return self;
+}
+
+- (NSString *)uri {
+  return [NSString stringWithUTF8String:_nativeHeaderExtensionCapability.uri.c_str()];
+}
+
+- (NSNumber *)preferredId {
+  return [NSNumber numberWithInt:*_nativeHeaderExtensionCapability.preferred_id];
+
+}
+
+- (BOOL)preferredEncrypt {
+  return _nativeHeaderExtensionCapability.preferred_encrypt;
+}
+
+@end
\ No newline at end of file
