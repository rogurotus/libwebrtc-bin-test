diff --git a/src/p2p/base/connection.cc b/src/p2p/base/connection.cc
index 1ef42cc..2d7a26b 100644
--- a/src/p2p/base/connection.cc
+++ b/src/p2p/base/connection.cc
@@ -34,6 +34,7 @@
 #include "rtc_base/string_utils.h"
 #include "rtc_base/strings/string_builder.h"
 #include "rtc_base/third_party/base64/base64.h"
+#include <android/log.h>
 
 namespace cricket {
 namespace {
@@ -450,6 +451,12 @@ void Connection::OnReadPacket(const char* data,
   std::string remote_ufrag;
   const rtc::SocketAddress& addr(remote_candidate_.address());
   if (!port_->GetStunMessage(data, size, addr, &msg, &remote_ufrag)) {
+    __android_log_print(ANDROID_LOG_ERROR, "BUGDE1", "%s", "AA");
+    if (msg.get() != nullptr) {
+      __android_log_print(ANDROID_LOG_ERROR, "BUGDE1", "%s", StunMethodToString(msg->type()).c_str());
+      __android_log_print(ANDROID_LOG_ERROR, "BUGDE1", "%s", msg->transaction_id().c_str());
+      __android_log_print(ANDROID_LOG_ERROR, "BUGDE1", "%s", remote_ufrag.c_str());
+    }
     // The packet did not parse as a valid STUN message
     // This is a data packet, pass it along.
     last_data_received_ = rtc::TimeMillis();
@@ -460,6 +467,8 @@ void Connection::OnReadPacket(const char* data,
 
     // If timed out sending writability checks, start up again
     if (!pruned_ && (write_state_ == STATE_WRITE_TIMEOUT)) {
+    __android_log_print(ANDROID_LOG_ERROR, "BUGDE2", "%s", "RZ");
+
       RTC_LOG(LS_WARNING)
           << "Received a data packet on a timed-out Connection. "
              "Resetting state to STATE_WRITE_INIT.";
@@ -467,6 +476,8 @@ void Connection::OnReadPacket(const char* data,
     }
     return;
   } else if (!msg) {
+    __android_log_print(ANDROID_LOG_ERROR, "BUGDE3", "%s", "RZ");
+
     // The packet was STUN, but failed a check and was handled internally.
     return;
   }
@@ -481,7 +492,14 @@ void Connection::OnReadPacket(const char* data,
   // RESPONSEs  have msg->integrity() checked below.
   // INDICATION does not have any integrity.
   if (IsStunRequestType(msg->type())) {
+    __android_log_print(ANDROID_LOG_ERROR, "BUGDE4", "%s", "RZ");
+
     if (msg->integrity() != StunMessage::IntegrityStatus::kIntegrityOk) {
+          if (msg.get() != nullptr) {
+    __android_log_print(ANDROID_LOG_ERROR, "BUGDE5", "%s", StunMethodToString(msg->type()).c_str());
+    __android_log_print(ANDROID_LOG_ERROR, "BUGDE6", "%s", msg->transaction_id().c_str());
+    }
+
       // "silently" discard the request.
       RTC_LOG(LS_VERBOSE) << ToString() << ": Discarding "
                           << StunMethodToString(msg->type())
@@ -493,9 +511,17 @@ void Connection::OnReadPacket(const char* data,
     // fall-through
   } else if (IsStunSuccessResponseType(msg->type()) ||
              IsStunErrorResponseType(msg->type())) {
+    __android_log_print(ANDROID_LOG_ERROR, "BUGDE8", "%s", "RZ");
+
     RTC_DCHECK(msg->integrity() == StunMessage::IntegrityStatus::kNotSet);
     if (msg->ValidateMessageIntegrity(remote_candidate().password()) !=
         StunMessage::IntegrityStatus::kIntegrityOk) {
+                    if (msg.get() != nullptr) {
+              __android_log_print(ANDROID_LOG_ERROR, "BUGDE9", "%s", StunMethodToString(msg->type()).c_str());
+    __android_log_print(ANDROID_LOG_ERROR, "BUGDE10", "%s", msg->transaction_id().c_str());
+    }
+
+
       // "silently" discard the response.
       RTC_LOG(LS_VERBOSE) << ToString() << ": Discarding "
                           << StunMethodToString(msg->type())
@@ -505,6 +531,7 @@ void Connection::OnReadPacket(const char* data,
       return;
     }
   } else {
+    __android_log_print(ANDROID_LOG_ERROR, "BUGDE12", "%s", "RZ");
     RTC_DCHECK(IsStunIndicationType(msg->type()));
     // No message integrity.
   }
@@ -512,14 +539,18 @@ void Connection::OnReadPacket(const char* data,
   rtc::LoggingSeverity sev = (!writable() ? rtc::LS_INFO : rtc::LS_VERBOSE);
   switch (msg->type()) {
     case STUN_BINDING_REQUEST:
+    __android_log_print(ANDROID_LOG_ERROR, "BUGDE13", "%s", "RZ");
+
       RTC_LOG_V(sev) << ToString() << ": Received "
                      << StunMethodToString(msg->type())
                      << ", id=" << rtc::hex_encode(msg->transaction_id());
       if (remote_ufrag == remote_candidate_.username()) {
+    __android_log_print(ANDROID_LOG_ERROR, "BUGDE14", "%s", "RZ");
         HandleStunBindingOrGoogPingRequest(msg.get());
       } else {
         // The packet had the right local username, but the remote username
         // was not the right one for the remote address.
+    __android_log_print(ANDROID_LOG_ERROR, "BUGDE15", "%s", remote_ufrag.c_str());
         RTC_LOG(LS_ERROR) << ToString()
                           << ": Received STUN request with bad remote username "
                           << remote_ufrag;
@@ -534,6 +565,7 @@ void Connection::OnReadPacket(const char* data,
       // id's match.
     case STUN_BINDING_RESPONSE:
     case STUN_BINDING_ERROR_RESPONSE:
+    __android_log_print(ANDROID_LOG_ERROR, "BUGDE16", "%s", "RZ");
       requests_.CheckResponse(msg.get());
       break;
 
@@ -541,14 +573,17 @@ void Connection::OnReadPacket(const char* data,
       // request. In this case `last_ping_received_` will be updated but no
       // response will be sent.
     case STUN_BINDING_INDICATION:
+    __android_log_print(ANDROID_LOG_ERROR, "BUGDE17", "%s", "RZ");
       ReceivedPing(msg->transaction_id());
       break;
     case GOOG_PING_REQUEST:
+    __android_log_print(ANDROID_LOG_ERROR, "BUGDE18", "%s", "RZ");
       // Checked in Port::GetStunMessage.
       HandleStunBindingOrGoogPingRequest(msg.get());
       break;
     case GOOG_PING_RESPONSE:
     case GOOG_PING_ERROR_RESPONSE:
+    __android_log_print(ANDROID_LOG_ERROR, "BUGDE19", "%s", "RZ");
       requests_.CheckResponse(msg.get());
       break;
     default:
@@ -562,12 +597,18 @@ void Connection::HandleStunBindingOrGoogPingRequest(IceMessage* msg) {
   // This connection should now be receiving.
   ReceivedPing(msg->transaction_id());
   if (field_trials_->extra_ice_ping && last_ping_response_received_ == 0) {
+    __android_log_print(ANDROID_LOG_ERROR, "BUGDE D", "%s", "RZ");
+
     if (local_candidate().type() == RELAY_PORT_TYPE ||
         local_candidate().type() == PRFLX_PORT_TYPE ||
         remote_candidate().type() == RELAY_PORT_TYPE ||
         remote_candidate().type() == PRFLX_PORT_TYPE) {
+    __android_log_print(ANDROID_LOG_ERROR, "BUGDE D2", "%s", "RZ");
+
       const int64_t now = rtc::TimeMillis();
       if (last_ping_sent_ + kMinExtraPingDelayMs <= now) {
+    __android_log_print(ANDROID_LOG_ERROR, "BUGDE D3", "%s", ToString().c_str());
+
         RTC_LOG(LS_INFO) << ToString()
                          << "WebRTC-ExtraICEPing/Sending extra ping"
                             " last_ping_sent_: "
@@ -575,6 +616,7 @@ void Connection::HandleStunBindingOrGoogPingRequest(IceMessage* msg) {
                          << " (diff: " << (now - last_ping_sent_) << ")";
         Ping(now);
       } else {
+    __android_log_print(ANDROID_LOG_ERROR, "BUGDE D4", "%s", ToString().c_str());
         RTC_LOG(LS_INFO) << ToString()
                          << "WebRTC-ExtraICEPing/Not sending extra ping"
                             " last_ping_sent_: "
@@ -586,9 +628,13 @@ void Connection::HandleStunBindingOrGoogPingRequest(IceMessage* msg) {
 
   const rtc::SocketAddress& remote_addr = remote_candidate_.address();
   if (msg->type() == STUN_BINDING_REQUEST) {
+
     // Check for role conflicts.
     const std::string& remote_ufrag = remote_candidate_.username();
+    __android_log_print(ANDROID_LOG_ERROR, "BUGDE D5", "%s", remote_ufrag.c_str());
     if (!port_->MaybeIceRoleConflict(remote_addr, msg, remote_ufrag)) {
+    __android_log_print(ANDROID_LOG_ERROR, "BUGDE D6", "%s", "RZ");
+
       // Received conflicting role from the peer.
       RTC_LOG(LS_INFO) << "Received conflicting role from the peer.";
       return;
@@ -601,35 +647,46 @@ void Connection::HandleStunBindingOrGoogPingRequest(IceMessage* msg) {
 
   // This is a validated stun request from remote peer.
   if (msg->type() == STUN_BINDING_REQUEST) {
+    __android_log_print(ANDROID_LOG_ERROR, "BUGDE D7", "%s", "RZ");
+
     SendStunBindingResponse(msg);
   } else {
+    __android_log_print(ANDROID_LOG_ERROR, "BUGDE D8", "%s", "RZ");
     RTC_DCHECK(msg->type() == GOOG_PING_REQUEST);
     SendGoogPingResponse(msg);
   }
 
   // If it timed out on writing check, start up again
   if (!pruned_ && write_state_ == STATE_WRITE_TIMEOUT) {
+    __android_log_print(ANDROID_LOG_ERROR, "BUGDE D9", "%s", "RZ");
     set_write_state(STATE_WRITE_INIT);
   }
 
   if (port_->GetIceRole() == ICEROLE_CONTROLLED) {
+    __android_log_print(ANDROID_LOG_ERROR, "BUGDE D10", "%s", "RZ");
+
     const StunUInt32Attribute* nomination_attr =
         msg->GetUInt32(STUN_ATTR_NOMINATION);
     uint32_t nomination = 0;
     if (nomination_attr) {
+    __android_log_print(ANDROID_LOG_ERROR, "BUGDE D11", "%s", "RZ");
       nomination = nomination_attr->value();
       if (nomination == 0) {
+    __android_log_print(ANDROID_LOG_ERROR, "BUGDE D12", "%s", "RZ");
         RTC_LOG(LS_ERROR) << "Invalid nomination: " << nomination;
       }
     } else {
+    __android_log_print(ANDROID_LOG_ERROR, "BUGDE D13", "%s", "RZ");
       const StunByteStringAttribute* use_candidate_attr =
           msg->GetByteString(STUN_ATTR_USE_CANDIDATE);
       if (use_candidate_attr) {
+    __android_log_print(ANDROID_LOG_ERROR, "BUGDE D14", "%s", "RZ");
         nomination = 1;
       }
     }
     // We don't un-nominate a connection, so we only keep a larger nomination.
     if (nomination > remote_nomination_) {
+    __android_log_print(ANDROID_LOG_ERROR, "BUGDE D15", "%s", "RZ");
       set_remote_nomination(nomination);
       SignalNominated(this);
     }
@@ -640,9 +697,12 @@ void Connection::HandleStunBindingOrGoogPingRequest(IceMessage* msg) {
   const StunUInt32Attribute* network_attr =
       msg->GetUInt32(STUN_ATTR_GOOG_NETWORK_INFO);
   if (network_attr) {
+    __android_log_print(ANDROID_LOG_ERROR, "BUGDE D16", "%s", "RZ");
+
     uint32_t network_info = network_attr->value();
     uint16_t network_cost = static_cast<uint16_t>(network_info);
     if (network_cost != remote_candidate_.network_cost()) {
+    __android_log_print(ANDROID_LOG_ERROR, "BUGDE D17", "%s", "RZ");
       remote_candidate_.set_network_cost(network_cost);
       // Network cost change will affect the connection ranking, so signal
       // state change to force a re-sort in P2PTransportChannel.
@@ -651,6 +711,7 @@ void Connection::HandleStunBindingOrGoogPingRequest(IceMessage* msg) {
   }
 
   if (field_trials_->piggyback_ice_check_acknowledgement) {
+    __android_log_print(ANDROID_LOG_ERROR, "BUGDE D18", "%s", "RZ");
     HandlePiggybackCheckAcknowledgementIfAny(msg);
   }
 }
@@ -659,11 +720,13 @@ void Connection::SendStunBindingResponse(const StunMessage* message) {
   RTC_DCHECK_RUN_ON(network_thread_);
   RTC_DCHECK_EQ(message->type(), STUN_BINDING_REQUEST);
 
+__android_log_print(ANDROID_LOG_ERROR, "BUGDE DDD1", "%s", "RZ");
   // Retrieve the username from the `message`.
   const StunByteStringAttribute* username_attr =
       message->GetByteString(STUN_ATTR_USERNAME);
   RTC_DCHECK(username_attr != NULL);
   if (username_attr == NULL) {
+__android_log_print(ANDROID_LOG_ERROR, "BUGDE DDD2", "%s", "RZ");
     // No valid username, skip the response.
     return;
   }
@@ -673,12 +736,16 @@ void Connection::SendStunBindingResponse(const StunMessage* message) {
   const StunUInt32Attribute* retransmit_attr =
       message->GetUInt32(STUN_ATTR_RETRANSMIT_COUNT);
   if (retransmit_attr) {
+__android_log_print(ANDROID_LOG_ERROR, "BUGDE DDD3", "%s", "RZ");
+
     // Inherit the incoming retransmit value in the response so the other side
     // can see our view of lost pings.
     response.AddAttribute(std::make_unique<StunUInt32Attribute>(
         STUN_ATTR_RETRANSMIT_COUNT, retransmit_attr->value()));
 
     if (retransmit_attr->value() > CONNECTION_WRITE_CONNECT_FAILURES) {
+__android_log_print(ANDROID_LOG_ERROR, "BUGDE DDD4", "%s", "RZ");
+
       RTC_LOG(LS_INFO)
           << ToString()
           << ": Received a remote ping with high retransmit count: "
@@ -690,12 +757,16 @@ void Connection::SendStunBindingResponse(const StunMessage* message) {
       STUN_ATTR_XOR_MAPPED_ADDRESS, remote_candidate_.address()));
 
   if (field_trials_->announce_goog_ping) {
+__android_log_print(ANDROID_LOG_ERROR, "BUGDE DDD5", "%s", "RZ");
+
     // Check if message contains a announce-request.
     auto goog_misc = message->GetUInt16List(STUN_ATTR_GOOG_MISC_INFO);
     if (goog_misc != nullptr &&
         goog_misc->Size() >= kSupportGoogPingVersionRequestIndex &&
         // Which version can we handle...currently any >= 1
         goog_misc->GetType(kSupportGoogPingVersionRequestIndex) >= 1) {
+__android_log_print(ANDROID_LOG_ERROR, "BUGDE DDD6", "%s", "RZ");
+
       auto list =
           StunAttribute::CreateUInt16ListAttribute(STUN_ATTR_GOOG_MISC_INFO);
       list->AddTypeAtIndex(kSupportGoogPingVersionResponseIndex,
@@ -707,16 +778,22 @@ void Connection::SendStunBindingResponse(const StunMessage* message) {
   const StunByteStringAttribute* delta =
       message->GetByteString(STUN_ATTR_GOOG_DELTA);
   if (delta) {
+__android_log_print(ANDROID_LOG_ERROR, "BUGDE DDD7", "%s", "RZ");
+
     if (field_trials_->answer_goog_delta && goog_delta_consumer_) {
+__android_log_print(ANDROID_LOG_ERROR, "BUGDE DDD8", "%s", "RZ");
       auto ack = (*goog_delta_consumer_)(delta);
       if (ack) {
+__android_log_print(ANDROID_LOG_ERROR, "BUGDE DDD9", "%s", "RZ");
         RTC_LOG(LS_INFO) << "Sending GOOG_DELTA_ACK"
                          << " delta len: " << delta->length();
         response.AddAttribute(std::move(ack));
       } else {
+__android_log_print(ANDROID_LOG_ERROR, "BUGDE DDD10", "%s", "RZ");
         RTC_LOG(LS_ERROR) << "GOOG_DELTA consumer did not return ack!";
       }
     } else {
+__android_log_print(ANDROID_LOG_ERROR, "BUGDE DDD11", "%s", "RZ");
       RTC_LOG(LS_WARNING) << "Ignore GOOG_DELTA"
                           << " len: " << delta->length()
                           << " answer_goog_delta = "
@@ -728,6 +805,7 @@ void Connection::SendStunBindingResponse(const StunMessage* message) {
 
   response.AddMessageIntegrity(local_candidate().password());
   response.AddFingerprint();
+__android_log_print(ANDROID_LOG_ERROR, "BUGDE DDD12", "%s", "RZ");
 
   SendResponseMessage(response);
 }
@@ -743,6 +821,9 @@ void Connection::SendGoogPingResponse(const StunMessage* message) {
 }
 
 void Connection::SendResponseMessage(const StunMessage& response) {
+
+__android_log_print(ANDROID_LOG_ERROR, "BUGDE CC1", "%s", "RZ");
+
   RTC_DCHECK_RUN_ON(network_thread_);
   // Where I send the response.
   const rtc::SocketAddress& addr = remote_candidate_.address();
@@ -753,13 +834,18 @@ void Connection::SendResponseMessage(const StunMessage& response) {
   rtc::PacketOptions options(port_->StunDscpValue());
   options.info_signaled_after_sent.packet_type =
       rtc::PacketType::kIceConnectivityCheckResponse;
+  __android_log_print(ANDROID_LOG_ERROR, "BUGDE CC2-0", "%s", addr.ToSensitiveString().c_str());
   auto err = port_->SendTo(buf.Data(), buf.Length(), addr, options, false);
   if (err < 0) {
+__android_log_print(ANDROID_LOG_ERROR, "BUGDE CC2", "%i", (int)err);
+
     RTC_LOG(LS_ERROR) << ToString() << ": Failed to send "
                       << StunMethodToString(response.type())
                       << ", to=" << addr.ToSensitiveString() << ", err=" << err
                       << ", id=" << rtc::hex_encode(response.transaction_id());
   } else {
+__android_log_print(ANDROID_LOG_ERROR, "BUGDE CC3", "%s", response.transaction_id().c_str());
+
     // Log at LS_INFO if we send a stun ping response on an unwritable
     // connection.
     rtc::LoggingSeverity sev = (!writable()) ? rtc::LS_INFO : rtc::LS_VERBOSE;
diff --git a/src/p2p/base/stun_port.cc b/src/p2p/base/stun_port.cc
index 3b024bd..eb98440 100644
--- a/src/p2p/base/stun_port.cc
+++ b/src/p2p/base/stun_port.cc
@@ -26,6 +26,7 @@
 #include "rtc_base/ip_address.h"
 #include "rtc_base/logging.h"
 #include "rtc_base/strings/string_builder.h"
+#include <android/log.h>
 
 namespace cricket {
 
@@ -294,21 +295,28 @@ int UDPPort::SendTo(const void* data,
                     const rtc::SocketAddress& addr,
                     const rtc::PacketOptions& options,
                     bool payload) {
+    __android_log_print(ANDROID_LOG_ERROR, "BUGDE SENDAUDP", "%s %i", "1", (int)0);
+
   rtc::PacketOptions modified_options(options);
   CopyPortInformationToPacketInfo(&modified_options.info_signaled_after_sent);
   int sent = socket_->SendTo(data, size, addr, modified_options);
   if (sent < 0) {
     error_ = socket_->GetError();
+    __android_log_print(ANDROID_LOG_ERROR, "BUGDE SENDAUDP", "%s %i", "2", (int)error_);
+
     // Rate limiting added for crbug.com/856088.
     // TODO(webrtc:9622): Use general rate limiting mechanism once it exists.
     if (send_error_count_ < kSendErrorLogLimit) {
       ++send_error_count_;
+    __android_log_print(ANDROID_LOG_ERROR, "BUGDE SENDAUDP", "%s %s %i-%i<%i", "3", addr.ToSensitiveNameAndAddressString().c_str(), (int)error_, (int)send_error_count_, (int)kSendErrorLogLimit);
+
       RTC_LOG(LS_ERROR) << ToString() << ": UDP send of " << size
                         << " bytes to host "
                         << addr.ToSensitiveNameAndAddressString()
                         << " failed with error " << error_;
     }
   } else {
+    __android_log_print(ANDROID_LOG_ERROR, "BUGDE SENDAUDP UWU", "%s", "2");
     send_error_count_ = 0;
   }
   return sent;
diff --git a/src/p2p/base/turn_port.cc b/src/p2p/base/turn_port.cc
index 88c9a45..9edf586 100644
--- a/src/p2p/base/turn_port.cc
+++ b/src/p2p/base/turn_port.cc
@@ -31,6 +31,7 @@
 #include "rtc_base/net_helpers.h"
 #include "rtc_base/socket_address.h"
 #include "rtc_base/strings/string_builder.h"
+#include <android/log.h>
 
 namespace cricket {
 
@@ -646,6 +647,7 @@ int TurnPort::SendTo(const void* data,
 
   if (!ready()) {
     error_ = ENOTCONN;
+    __android_log_print(ANDROID_LOG_ERROR, "BUGDE SENDA", "%s %i", "1", (int)error_);
     return SOCKET_ERROR;
   }
 
@@ -655,6 +657,7 @@ int TurnPort::SendTo(const void* data,
   int sent = entry->Send(data, size, payload, modified_options);
   if (sent <= 0) {
     error_ = socket_->GetError();
+    __android_log_print(ANDROID_LOG_ERROR, "BUGDE SENDA", "%s %i", "2", (int)error_);
     return SOCKET_ERROR;
   }
 
