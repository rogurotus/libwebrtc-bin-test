diff --git a/src/p2p/base/connection.cc b/src/p2p/base/connection.cc
index 1ef42cc..6e8bc20 100644
--- a/src/p2p/base/connection.cc
+++ b/src/p2p/base/connection.cc
@@ -34,6 +34,7 @@
 #include "rtc_base/string_utils.h"
 #include "rtc_base/strings/string_builder.h"
 #include "rtc_base/third_party/base64/base64.h"
+#include <android/log.h>
 
 namespace cricket {
 namespace {
@@ -445,11 +446,13 @@ void Connection::OnSendStunPacket(const void* data,
 void Connection::OnReadPacket(const char* data,
                               size_t size,
                               int64_t packet_time_us) {
+  __android_log_print(ANDROID_LOG_ERROR, "BUGDE", "%s", data);
   RTC_DCHECK_RUN_ON(network_thread_);
   std::unique_ptr<IceMessage> msg;
   std::string remote_ufrag;
   const rtc::SocketAddress& addr(remote_candidate_.address());
   if (!port_->GetStunMessage(data, size, addr, &msg, &remote_ufrag)) {
+    __android_log_print(ANDROID_LOG_ERROR, "BUGDE1", "%s", "RZ");
     // The packet did not parse as a valid STUN message
     // This is a data packet, pass it along.
     last_data_received_ = rtc::TimeMillis();
@@ -460,6 +463,8 @@ void Connection::OnReadPacket(const char* data,
 
     // If timed out sending writability checks, start up again
     if (!pruned_ && (write_state_ == STATE_WRITE_TIMEOUT)) {
+    __android_log_print(ANDROID_LOG_ERROR, "BUGDE2", "%s", "RZ");
+
       RTC_LOG(LS_WARNING)
           << "Received a data packet on a timed-out Connection. "
              "Resetting state to STATE_WRITE_INIT.";
@@ -467,6 +472,8 @@ void Connection::OnReadPacket(const char* data,
     }
     return;
   } else if (!msg) {
+    __android_log_print(ANDROID_LOG_ERROR, "BUGDE3", "%s", "RZ");
+
     // The packet was STUN, but failed a check and was handled internally.
     return;
   }
@@ -481,7 +488,12 @@ void Connection::OnReadPacket(const char* data,
   // RESPONSEs  have msg->integrity() checked below.
   // INDICATION does not have any integrity.
   if (IsStunRequestType(msg->type())) {
+    __android_log_print(ANDROID_LOG_ERROR, "BUGDE4", "%s", "RZ");
+
     if (msg->integrity() != StunMessage::IntegrityStatus::kIntegrityOk) {
+    __android_log_print(ANDROID_LOG_ERROR, "BUGDE5", "%s", StunMethodToString(msg->type()).c_str());
+    __android_log_print(ANDROID_LOG_ERROR, "BUGDE6", "%s", msg->transaction_id().c_str());
+    __android_log_print(ANDROID_LOG_ERROR, "BUGDE7", "%s", "msg->integrity().c_str()");
       // "silently" discard the request.
       RTC_LOG(LS_VERBOSE) << ToString() << ": Discarding "
                           << StunMethodToString(msg->type())
@@ -493,9 +505,15 @@ void Connection::OnReadPacket(const char* data,
     // fall-through
   } else if (IsStunSuccessResponseType(msg->type()) ||
              IsStunErrorResponseType(msg->type())) {
+    __android_log_print(ANDROID_LOG_ERROR, "BUGDE8", "%s", "RZ");
+
     RTC_DCHECK(msg->integrity() == StunMessage::IntegrityStatus::kNotSet);
     if (msg->ValidateMessageIntegrity(remote_candidate().password()) !=
         StunMessage::IntegrityStatus::kIntegrityOk) {
+              __android_log_print(ANDROID_LOG_ERROR, "BUGDE9", "%s", StunMethodToString(msg->type()).c_str());
+    __android_log_print(ANDROID_LOG_ERROR, "BUGDE10", "%s", msg->transaction_id().c_str());
+    __android_log_print(ANDROID_LOG_ERROR, "BUGDE11", "%s", "msg->integrity().c_str()");
+
       // "silently" discard the response.
       RTC_LOG(LS_VERBOSE) << ToString() << ": Discarding "
                           << StunMethodToString(msg->type())
@@ -505,6 +523,7 @@ void Connection::OnReadPacket(const char* data,
       return;
     }
   } else {
+    __android_log_print(ANDROID_LOG_ERROR, "BUGDE12", "%s", "RZ");
     RTC_DCHECK(IsStunIndicationType(msg->type()));
     // No message integrity.
   }
@@ -512,14 +531,18 @@ void Connection::OnReadPacket(const char* data,
   rtc::LoggingSeverity sev = (!writable() ? rtc::LS_INFO : rtc::LS_VERBOSE);
   switch (msg->type()) {
     case STUN_BINDING_REQUEST:
+    __android_log_print(ANDROID_LOG_ERROR, "BUGDE13", "%s", "RZ");
+
       RTC_LOG_V(sev) << ToString() << ": Received "
                      << StunMethodToString(msg->type())
                      << ", id=" << rtc::hex_encode(msg->transaction_id());
       if (remote_ufrag == remote_candidate_.username()) {
+    __android_log_print(ANDROID_LOG_ERROR, "BUGDE14", "%s", "RZ");
         HandleStunBindingOrGoogPingRequest(msg.get());
       } else {
         // The packet had the right local username, but the remote username
         // was not the right one for the remote address.
+    __android_log_print(ANDROID_LOG_ERROR, "BUGDE15", "%s", remote_ufrag.c_str());
         RTC_LOG(LS_ERROR) << ToString()
                           << ": Received STUN request with bad remote username "
                           << remote_ufrag;
@@ -534,6 +557,7 @@ void Connection::OnReadPacket(const char* data,
       // id's match.
     case STUN_BINDING_RESPONSE:
     case STUN_BINDING_ERROR_RESPONSE:
+    __android_log_print(ANDROID_LOG_ERROR, "BUGDE16", "%s", "RZ");
       requests_.CheckResponse(msg.get());
       break;
 
@@ -541,14 +565,17 @@ void Connection::OnReadPacket(const char* data,
       // request. In this case `last_ping_received_` will be updated but no
       // response will be sent.
     case STUN_BINDING_INDICATION:
+    __android_log_print(ANDROID_LOG_ERROR, "BUGDE17", "%s", "RZ");
       ReceivedPing(msg->transaction_id());
       break;
     case GOOG_PING_REQUEST:
+    __android_log_print(ANDROID_LOG_ERROR, "BUGDE18", "%s", "RZ");
       // Checked in Port::GetStunMessage.
       HandleStunBindingOrGoogPingRequest(msg.get());
       break;
     case GOOG_PING_RESPONSE:
     case GOOG_PING_ERROR_RESPONSE:
+    __android_log_print(ANDROID_LOG_ERROR, "BUGDE19", "%s", "RZ");
       requests_.CheckResponse(msg.get());
       break;
     default:
