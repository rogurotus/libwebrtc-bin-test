diff --git a/src/api/transport/stun.cc b/src/api/transport/stun.cc
index 7ef6852..9bc13ca 100644
--- a/src/api/transport/stun.cc
+++ b/src/api/transport/stun.cc
@@ -511,16 +511,25 @@ bool StunMessage::AddMessageIntegrityOfType(int attr_type,
 // in section 15.5.
 bool StunMessage::ValidateFingerprint(const char* data, size_t size) {
   // Check the message length.
+
   size_t fingerprint_attr_size =
       kStunAttributeHeaderSize + StunUInt32Attribute::SIZE;
-  if (size % 4 != 0 || size < kStunHeaderSize + fingerprint_attr_size)
+  if (size % 4 != 0 || size < kStunHeaderSize + fingerprint_attr_size) {
+    RTC_LOG(LS_ERROR) << "vbgfgfg " << (size % 4 != 0) << " "
+                      << (size < kStunHeaderSize + fingerprint_attr_size);
+
     return false;
+  }
 
   // Skip the rest if the magic cookie isn't present.
   const char* magic_cookie =
       data + kStunTransactionIdOffset - kStunMagicCookieLength;
-  if (rtc::GetBE32(magic_cookie) != kStunMagicCookie)
+  auto aa = rtc::GetBE32(magic_cookie);
+  if (aa != kStunMagicCookie) {
+    RTC_LOG(LS_ERROR) << "vbgfgfg222 " << aa;
+
     return false;
+  }
 
   // Check the fingerprint type and length.
   const char* fingerprint_attr_data = data + size - fingerprint_attr_size;
@@ -545,17 +554,27 @@ bool StunMessage::IsStunMethod(rtc::ArrayView<int> methods,
                                const char* data,
                                size_t size) {
   // Check the message length.
-  if (size % 4 != 0 || size < kStunHeaderSize)
+  if (size % 4 != 0 || size < kStunHeaderSize) {
+    RTC_LOG(LS_ERROR) << "PRE1DATTT " << (size % 4 != 0) << " "
+                      << (size < kStunHeaderSize);
+
     return false;
+  }
 
   // Skip the rest if the magic cookie isn't present.
   const char* magic_cookie =
       data + kStunTransactionIdOffset - kStunMagicCookieLength;
-  if (rtc::GetBE32(magic_cookie) != kStunMagicCookie)
+  auto a = rtc::GetBE32(magic_cookie);
+  if (a != kStunMagicCookie) {
+    RTC_LOG(LS_ERROR) << "PRE1DATTT " << a;
+
     return false;
+  }
 
   int method = rtc::GetBE16(data);
   for (int m : methods) {
+    RTC_LOG(LS_ERROR) << "PRE1DA " << method;
+
     if (m == method) {
       return true;
     }
@@ -590,26 +609,31 @@ bool StunMessage::Read(ByteBufferReader* buf) {
   buffer_.assign(buf->Data(), buf->Length());
 
   if (!buf->ReadUInt16(&type_)) {
+    RTC_LOG(LS_ERROR) << "EARLY 1";
     return false;
   }
 
   if (type_ & 0x8000) {
     // RTP and RTCP set the MSB of first byte, since first two bits are version,
     // and version is always 2 (10). If set, this is not a STUN packet.
+    RTC_LOG(LS_ERROR) << "EARLY 2";
     return false;
   }
 
   if (!buf->ReadUInt16(&length_)) {
+    RTC_LOG(LS_ERROR) << "EARLY 3";
     return false;
   }
 
   std::string magic_cookie;
   if (!buf->ReadString(&magic_cookie, kStunMagicCookieLength)) {
+    RTC_LOG(LS_ERROR) << "EARLY 4";
     return false;
   }
 
   std::string transaction_id;
   if (!buf->ReadString(&transaction_id, kStunTransactionIdLength)) {
+    RTC_LOG(LS_ERROR) << "EARLY 5";
     return false;
   }
 
@@ -618,6 +642,8 @@ bool StunMessage::Read(ByteBufferReader* buf) {
                 "Integer size mismatch: magic_cookie_int and kStunMagicCookie");
   std::memcpy(&magic_cookie_int, magic_cookie.data(), sizeof(magic_cookie_int));
   if (rtc::NetworkToHost32(magic_cookie_int) != kStunMagicCookie) {
+    RTC_LOG(LS_ERROR) << "EARLY 6 " << kStunMagicCookie << " "
+                      << rtc::NetworkToHost32(magic_cookie_int);
     // If magic cookie is invalid it means that the peer implements
     // RFC3489 instead of RFC5389.
     transaction_id.insert(0, magic_cookie);
@@ -627,6 +653,7 @@ bool StunMessage::Read(ByteBufferReader* buf) {
   reduced_transaction_id_ = ReduceTransactionId(transaction_id_);
 
   if (length_ != buf->Length()) {
+    RTC_LOG(LS_ERROR) << "EARLY 7" << length_ << " - " << buf->Length();
     return false;
   }
 
@@ -635,10 +662,16 @@ bool StunMessage::Read(ByteBufferReader* buf) {
   size_t rest = buf->Length() - length_;
   while (buf->Length() > rest) {
     uint16_t attr_type, attr_length;
-    if (!buf->ReadUInt16(&attr_type))
+    if (!buf->ReadUInt16(&attr_type)) {
+      RTC_LOG(LS_ERROR) << "EARLY 8";
+
       return false;
-    if (!buf->ReadUInt16(&attr_length))
+    }
+    if (!buf->ReadUInt16(&attr_length)) {
+      RTC_LOG(LS_ERROR) << "EARLY 9";
+
       return false;
+    }
 
     std::unique_ptr<StunAttribute> attr(
         CreateAttribute(attr_type, attr_length));
@@ -648,10 +681,12 @@ bool StunMessage::Read(ByteBufferReader* buf) {
         attr_length += (4 - (attr_length % 4));
       }
       if (!buf->Consume(attr_length)) {
+        RTC_LOG(LS_ERROR) << "EARLY 10";
         return false;
       }
     } else {
       if (!attr->Read(buf)) {
+        RTC_LOG(LS_ERROR) << "EARLY 11";
         return false;
       }
       attrs_.push_back(std::move(attr));
@@ -949,10 +984,14 @@ bool StunAddressAttribute::Write(ByteBufferWriter* buf) const {
   switch (address_.family()) {
     case AF_INET: {
       in_addr v4addr = address_.ipaddr().ipv4_address();
+      RTC_LOG(LS_ERROR) << "HMDTF 1";
+
       buf->WriteBytes(reinterpret_cast<char*>(&v4addr), sizeof(v4addr));
       break;
     }
     case AF_INET6: {
+      RTC_LOG(LS_ERROR) << "HMDTF 2";
+
       in6_addr v6addr = address_.ipaddr().ipv6_address();
       buf->WriteBytes(reinterpret_cast<char*>(&v6addr), sizeof(v6addr));
       break;
@@ -1039,10 +1078,14 @@ bool StunXorAddressAttribute::Write(ByteBufferWriter* buf) const {
   switch (xored_ip.family()) {
     case AF_INET: {
       in_addr v4addr = xored_ip.ipv4_address();
+      RTC_LOG(LS_ERROR) << "DUM DUM";
+
       buf->WriteBytes(reinterpret_cast<const char*>(&v4addr), sizeof(v4addr));
       break;
     }
     case AF_INET6: {
+      RTC_LOG(LS_ERROR) << "DUM DUM2";
+
       in6_addr v6addr = xored_ip.ipv6_address();
       buf->WriteBytes(reinterpret_cast<const char*>(&v6addr), sizeof(v6addr));
       break;
diff --git a/src/p2p/base/connection.cc b/src/p2p/base/connection.cc
index d0e6f1b..48fd175 100644
--- a/src/p2p/base/connection.cc
+++ b/src/p2p/base/connection.cc
@@ -474,11 +474,16 @@ void Connection::OnReadPacket(const rtc::ReceivedPacket& packet) {
   std::unique_ptr<IceMessage> msg;
   std::string remote_ufrag;
   const rtc::SocketAddress& addr(remote_candidate_.address());
+  RTC_LOG(LS_ERROR) << "JUMP " << ToString();
   if (!port_->GetStunMessage(
           reinterpret_cast<const char*>(packet.payload().data()),
           packet.payload().size(), addr, &msg, &remote_ufrag)) {
     // The packet did not parse as a valid STUN message
     // This is a data packet, pass it along.
+
+  RTC_LOG(LS_ERROR) << "JUMP2 " << ToString();
+
+
     last_data_received_ = rtc::TimeMillis();
     UpdateReceiving(last_data_received_);
     recv_rate_tracker_.AddSamples(packet.payload().size());
diff --git a/src/p2p/base/port.cc b/src/p2p/base/port.cc
index 3069799..15a9ed2 100644
--- a/src/p2p/base/port.cc
+++ b/src/p2p/base/port.cc
@@ -448,6 +448,7 @@ bool Port::GetStunMessage(const char* data,
                  GOOG_PING_ERROR_RESPONSE};
   if (!StunMessage::IsStunMethod(types, data, size) &&
       !StunMessage::ValidateFingerprint(data, size)) {
+              RTC_LOG(LS_ERROR) << "PRE1 " << !StunMessage::IsStunMethod(types, data, size) << " " << !StunMessage::ValidateFingerprint(data, size);
     return false;
   }
 
@@ -457,6 +458,8 @@ bool Port::GetStunMessage(const char* data,
   rtc::ByteBufferReader buf(
       rtc::MakeArrayView(reinterpret_cast<const uint8_t*>(data), size));
   if (!stun_msg->Read(&buf) || (buf.Length() > 0)) {
+              RTC_LOG(LS_ERROR) << "PRE2 " << !stun_msg->Read(&buf) << " " << (buf.Length() > 0);
+
     return false;
   }
 
diff --git a/src/p2p/base/turn_port.cc b/src/p2p/base/turn_port.cc
index e6f5e77..3dc67f4 100644
--- a/src/p2p/base/turn_port.cc
+++ b/src/p2p/base/turn_port.cc
@@ -375,6 +375,7 @@ void TurnPort::PrepareAddress() {
     // Insert the current address to prevent redirection pingpong.
     attempted_server_addresses_.insert(server_address_.address);
 
+    // here
     RTC_LOG(LS_INFO)
         << ToString() << ": Trying to connect to TURN server via "
         << ProtoToString(server_address_.proto) << " @ "
@@ -388,6 +389,10 @@ void TurnPort::PrepareAddress() {
     if (server_address_.proto == PROTO_UDP) {
       // If its UDP, send AllocateRequest now.
       // For TCP and TLS AllcateRequest will be sent by OnSocketConnect.
+
+      // mb here
+      RTC_LOG(LS_ERROR) << "ALLOD IDK" << server_address_.address.ToString();
+
       SendRequest(new TurnAllocateRequest(this), 0);
     }
   }
@@ -520,6 +525,9 @@ void TurnPort::OnSocketConnect(rtc::AsyncPacketSocket* socket) {
   RTC_LOG(LS_INFO) << "TurnPort connected to "
                    << socket->GetRemoteAddress().ToSensitiveString()
                    << " using tcp.";
+
+  RTC_LOG(LS_ERROR) << "ALLOD NOPE ";
+
   SendRequest(new TurnAllocateRequest(this), 0);
 }
 
@@ -965,9 +973,15 @@ bool TurnPort::AllowedTurnPort(int port,
 }
 
 void TurnPort::TryAlternateServer() {
+  RTC_LOG(LS_ERROR) << "ALLOD 3 " << server_address().address.ToString();
+
   if (server_address().proto == PROTO_UDP) {
     // Send another allocate request to alternate server, with the received
     // realm and nonce values.
+
+    //mb here
+  RTC_LOG(LS_ERROR) << "ALLOD 2";
+
     SendRequest(new TurnAllocateRequest(this), 0);
   } else {
     // Since it's TCP, we have to delete the connected socket and reconnect
@@ -1313,18 +1327,31 @@ TurnAllocateRequest::TurnAllocateRequest(TurnPort* port)
     : StunRequest(port->request_manager(),
                   std::make_unique<TurnMessage>(TURN_ALLOCATE_REQUEST)),
       port_(port) {
+
+      RTC_LOG(LS_ERROR) << "ALLOD IDK AGA " << port->server_address().ToString() << " " << TURN_ALLOCATE_REQUEST << " " << port->connected();
+      RTC_LOG(LS_ERROR) << "ALLOD IDK AGA " << port->credentials().username << " " << port->credentials().password;
+  
   StunMessage* message = mutable_msg();
   // Create the request as indicated in RFC 5766, Section 6.1.
+      RTC_LOG(LS_ERROR) << "ALLOD IDK AGA " << port->address.ToString() << " " << TURN_ALLOCATE_REQUEST;
+
   RTC_DCHECK_EQ(message->type(), TURN_ALLOCATE_REQUEST);
   auto transport_attr =
       StunAttribute::CreateUInt32(STUN_ATTR_REQUESTED_TRANSPORT);
   transport_attr->SetValue(IPPROTO_UDP << 24);
   message->AddAttribute(std::move(transport_attr));
+    RTC_LOG(LS_ERROR) << "ALLOD IDK AGA 21 " << port_->hash();
+
   if (!port_->hash().empty()) {
+    RTC_LOG(LS_ERROR) << "ALLOD IDK AGA 22";
     port_->AddRequestAuthInfo(message);
   } else {
+    RTC_LOG(LS_ERROR) << "ALLOD IDK AGA 23";
+
     SetAuthenticationRequired(false);
   }
+    RTC_LOG(LS_ERROR) << "ALLOD IDK AGA 24";
+
   port_->MaybeAddTurnLoggingId(message);
   port_->TurnCustomizerMaybeModifyOutgoingStunMessage(message);
 }
@@ -1450,6 +1477,9 @@ void TurnAllocateRequest::OnAuthChallenge(StunMessage* response, int code) {
   port_->set_nonce(nonce_attr->string_view());
 
   // Send another allocate request, with the received realm and nonce values.
+
+  // mb here
+  RTC_LOG(LS_ERROR) << "ALLOD 1";
   port_->SendRequest(new TurnAllocateRequest(port_), 0);
 }
 
diff --git a/src/p2p/base/turn_port.h b/src/p2p/base/turn_port.h
index 686edaf..e959d08 100644
--- a/src/p2p/base/turn_port.h
+++ b/src/p2p/base/turn_port.h
@@ -132,7 +132,7 @@ class TurnPort : public Port {
   // Sets state to STATE_RECEIVEONLY.
   void Release();
 
-  void PrepareAddress() override;
+  void PrepareAddress() override; //hmm
   Connection* CreateConnection(const Candidate& c,
                                PortInterface::CandidateOrigin origin) override;
   int SendTo(const void* data,
