diff --git a/src/api/video_codecs/video_encoder_factory_template_libvpx_vp8_adapter.h b/src/api/video_codecs/video_encoder_factory_template_libvpx_vp8_adapter.h
index 0f0a9ba..a2d608b 100644
--- a/src/api/video_codecs/video_encoder_factory_template_libvpx_vp8_adapter.h
+++ b/src/api/video_codecs/video_encoder_factory_template_libvpx_vp8_adapter.h
@@ -18,6 +18,7 @@
 #include "api/video_codecs/sdp_video_format.h"
 #include "modules/video_coding/codecs/vp8/include/vp8.h"
 #include "modules/video_coding/codecs/vp8/vp8_scalability.h"
+#include <android/log.h>
 
 namespace webrtc {
 struct LibvpxVp8EncoderTemplateAdapter {
@@ -26,6 +27,9 @@ struct LibvpxVp8EncoderTemplateAdapter {
         scalability_modes;
     for (const auto scalability_mode : kVP8SupportedScalabilityModes) {
       scalability_modes.push_back(scalability_mode);
+        auto sv2 = ScalabilityModeToString(scalability_mode);
+        std::string s2 = {sv2.begin(), sv2.end()};
+        __android_log_print(ANDROID_LOG_ERROR, "LibvpxVp8EncoderTemplateAdapter", "%s", s2.c_str());
     }
 
     return {
diff --git a/src/media/base/media_engine.cc b/src/media/base/media_engine.cc
index 7304ab0..e69e712 100644
--- a/src/media/base/media_engine.cc
+++ b/src/media/base/media_engine.cc
@@ -15,6 +15,9 @@
 #include <cstdint>
 #include <string>
 #include <utility>
+#include <sstream>
+#include <iostream>
+#include <android/log.h>
 
 #include "absl/algorithm/container.h"
 #include "api/video/video_bitrate_allocation.h"
@@ -95,10 +98,22 @@ webrtc::RTCError CheckScalabilityModeValues(
       }
     }
     if (rtp_parameters.encodings[i].scalability_mode) {
+        std::stringstream ss;
       if (!send_codec) {
-        bool scalabilityModeFound = false;
-        for (const cricket::VideoCodec& codec : codec_preferences) {
-          for (const auto& scalability_mode : codec.scalability_modes) {
+         bool scalabilityModeFound = false;
+        __android_log_print(ANDROID_LOG_ERROR, "codec_preferences", "%lu", (unsigned long) codec_preferences.size());
+         for (const cricket::VideoCodec& codec : codec_preferences) {
+        __android_log_print(ANDROID_LOG_ERROR, "codec", "|%s|", codec.name.c_str());
+        __android_log_print(ANDROID_LOG_ERROR, "codec_preferences.scalability_modes", "%lu", (unsigned long) codec.scalability_modes.size());
+           for (const auto& scalability_mode : codec.scalability_modes) {
+        auto sv = *rtp_parameters.encodings[i].scalability_mode; auto sv2 = ScalabilityModeToString(scalability_mode);
+        std::string s = {sv.begin(), sv.end()}; std::string s2 = {sv2.begin(), sv2.end()};
+        __android_log_print(ANDROID_LOG_ERROR, "scalability_mode", "|%s|", s2.c_str());
+        __android_log_print(ANDROID_LOG_ERROR, "scalability_mode2", "|%s|", s.c_str());
+
+
+          ss << "\nscalability_mode" << ScalabilityModeToString(scalability_mode) << "-" << *rtp_parameters.encodings[i].scalability_mode;
+
             if (ScalabilityModeToString(scalability_mode) ==
                 *rtp_parameters.encodings[i].scalability_mode) {
               scalabilityModeFound = true;
@@ -110,14 +125,24 @@ webrtc::RTCError CheckScalabilityModeValues(
         }
 
         if (!scalabilityModeFound) {
+        __android_log_print(ANDROID_LOG_ERROR, "AAAAA42", "%s", ss.str().c_str());
+          std::cout << ss.str() << std::endl;
           LOG_AND_RETURN_ERROR(
               RTCErrorType::INVALID_MODIFICATION,
               "Attempted to set RtpParameters scalabilityMode "
               "to an unsupported value for the current codecs.");
         }
       } else {
+          ss << "\nsend_codec";
+
         bool scalabilityModeFound = false;
         for (const auto& scalability_mode : send_codec->scalability_modes) {
+          ss << "\nscalability_mode" << ScalabilityModeToString(scalability_mode) << "-" << *rtp_parameters.encodings[i].scalability_mode;
+        auto sv = *rtp_parameters.encodings[i].scalability_mode; auto sv2 = ScalabilityModeToString(scalability_mode);
+        std::string s = {sv.begin(), sv.end()}; std::string s2 = {sv2.begin(), sv2.end()};
+        __android_log_print(ANDROID_LOG_ERROR, "scalability_mode", "|%s|", s2.c_str());
+        __android_log_print(ANDROID_LOG_ERROR, "scalability_mode2", "|%s|", s.c_str());
+
           if (ScalabilityModeToString(scalability_mode) ==
               *rtp_parameters.encodings[i].scalability_mode) {
             scalabilityModeFound = true;
@@ -125,6 +150,8 @@ webrtc::RTCError CheckScalabilityModeValues(
           }
         }
         if (!scalabilityModeFound) {
+        __android_log_print(ANDROID_LOG_ERROR, "AAAAA422", "%s", ss.str().c_str());
+          std::cout << ss.str() << std::endl;
           LOG_AND_RETURN_ERROR(
               RTCErrorType::INVALID_MODIFICATION,
               "Attempted to set RtpParameters scalabilityMode "
diff --git a/src/media/engine/webrtc_video_engine.cc b/src/media/engine/webrtc_video_engine.cc
index 91750b8..c63ced1 100644
--- a/src/media/engine/webrtc_video_engine.cc
+++ b/src/media/engine/webrtc_video_engine.cc
@@ -19,6 +19,7 @@
 #include <string>
 #include <type_traits>
 #include <utility>
+#include <android/log.h>
 
 #include "absl/algorithm/container.h"
 #include "absl/container/inlined_vector.h"
@@ -179,7 +180,10 @@ std::vector<VideoCodec> GetPayloadTypesAndDefaultCodecs(
     bool is_decoder_factory,
     bool include_rtx,
     const webrtc::FieldTrialsView& trials) {
+
+  __android_log_print(ANDROID_LOG_ERROR, "GetPayloadTypesAndDefaultCodecs", "%s", "GetPayloadTypesAndDefaultCodecs");
   if (!factory) {
+  __android_log_print(ANDROID_LOG_ERROR, "GetPayloadTypesAndDefaultCodecs", "%s", "NOPE");
     return {};
   }
 
@@ -219,6 +223,8 @@ std::vector<VideoCodec> GetPayloadTypesAndDefaultCodecs(
 
   std::vector<VideoCodec> output_codecs;
   for (const webrtc::SdpVideoFormat& format : supported_formats) {
+  __android_log_print(ANDROID_LOG_ERROR, "GetPayloadTypesAndDefaultCodecs", "%s %lu", format.name.c_str(), (unsigned long) format.scalability_modes.size());
+
     VideoCodec codec = cricket::CreateVideoCodec(format);
     bool isFecCodec = absl::EqualsIgnoreCase(codec.name, kUlpfecCodecName) ||
                       absl::EqualsIgnoreCase(codec.name, kFlexfecCodecName);
diff --git a/src/modules/video_coding/codecs/av1/av1_svc_config.cc b/src/modules/video_coding/codecs/av1/av1_svc_config.cc
index 30c0f30..325bc4e 100644
--- a/src/modules/video_coding/codecs/av1/av1_svc_config.cc
+++ b/src/modules/video_coding/codecs/av1/av1_svc_config.cc
@@ -20,6 +20,7 @@
 #include "rtc_base/checks.h"
 #include "rtc_base/logging.h"
 #include "rtc_base/strings/string_builder.h"
+#include <android/log.h>
 
 namespace webrtc {
 namespace {
@@ -58,6 +59,9 @@ LibaomAv1EncoderSupportedScalabilityModes() {
   for (ScalabilityMode scalability_mode : kAllScalabilityModes) {
     if (ScalabilityStructureConfig(scalability_mode) != absl::nullopt) {
       scalability_modes.push_back(scalability_mode);
+              auto sv2 = ScalabilityModeToString(scalability_mode);
+        std::string s2 = {sv2.begin(), sv2.end()};
+        __android_log_print(ANDROID_LOG_ERROR, "LibaomAv1EncoderSupportedScalabilityModes", "%s", s2.c_str());
     }
   }
   return scalability_modes;
diff --git a/src/modules/video_coding/codecs/h264/h264.cc b/src/modules/video_coding/codecs/h264/h264.cc
index 5b9f033..177b8e3 100644
--- a/src/modules/video_coding/codecs/h264/h264.cc
+++ b/src/modules/video_coding/codecs/h264/h264.cc
@@ -19,6 +19,7 @@
 #include "api/video_codecs/sdp_video_format.h"
 #include "media/base/media_constants.h"
 #include "rtc_base/trace_event.h"
+#include <android/log.h>
 
 #if defined(WEBRTC_USE_H264)
 #include "modules/video_coding/codecs/h264/h264_decoder_impl.h"
@@ -61,6 +62,9 @@ SdpVideoFormat CreateH264Format(H264Profile profile,
   if (add_scalability_modes) {
     for (const auto scalability_mode : kSupportedScalabilityModes) {
       scalability_modes.push_back(scalability_mode);
+              auto sv2 = ScalabilityModeToString(scalability_mode);
+        std::string s2 = {sv2.begin(), sv2.end()};
+        __android_log_print(ANDROID_LOG_ERROR, "H264ProfileLevelIdToString", "%s", s2.c_str());
     }
   }
   return SdpVideoFormat(
diff --git a/src/modules/video_coding/codecs/vp9/vp9.cc b/src/modules/video_coding/codecs/vp9/vp9.cc
index c1dbf3a..2a810be 100644
--- a/src/modules/video_coding/codecs/vp9/vp9.cc
+++ b/src/modules/video_coding/codecs/vp9/vp9.cc
@@ -25,6 +25,7 @@
 #include "vpx/vp8cx.h"
 #include "vpx/vp8dx.h"
 #include "vpx/vpx_codec.h"
+#include <android/log.h>
 
 namespace webrtc {
 
@@ -43,6 +44,9 @@ std::vector<SdpVideoFormat> SupportedVP9Codecs(bool add_scalability_modes) {
     for (const auto scalability_mode : kAllScalabilityModes) {
       if (ScalabilityStructureConfig(scalability_mode).has_value()) {
         scalability_modes.push_back(scalability_mode);
+                auto sv2 = ScalabilityModeToString(scalability_mode);
+        std::string s2 = {sv2.begin(), sv2.end()};
+        __android_log_print(ANDROID_LOG_ERROR, "SupportedVP9Codecs", "%s", s2.c_str());
       }
     }
   }
diff --git a/src/pc/rtp_sender.cc b/src/pc/rtp_sender.cc
index cdae159..f7827da 100644
--- a/src/pc/rtp_sender.cc
+++ b/src/pc/rtp_sender.cc
@@ -237,6 +237,7 @@ void RtpSenderBase::SetParametersInternal(const RtpParameters& parameters,
   RTC_DCHECK_RUN_ON(signaling_thread_);
   RTC_DCHECK(!stopped_);
 
+  // nope2
   if (UnimplementedRtpParameterHasValue(parameters)) {
     RTCError error(
         RTCErrorType::UNSUPPORTED_PARAMETER,
@@ -247,6 +248,7 @@ void RtpSenderBase::SetParametersInternal(const RtpParameters& parameters,
     return;
   }
   if (!media_channel_ || !ssrc_) {
+    // nope3
     auto result = cricket::CheckRtpParametersInvalidModificationAndValues(
         init_parameters_, parameters, codec_preferences_, absl::nullopt);
     if (result.ok()) {
@@ -265,6 +267,7 @@ void RtpSenderBase::SetParametersInternal(const RtpParameters& parameters,
                                              old_parameters.encodings);
     }
 
+    // nope4
     RTCError result = cricket::CheckRtpParametersInvalidModificationAndValues(
         old_parameters, rtp_parameters);
     if (!result.ok()) {
@@ -272,6 +275,8 @@ void RtpSenderBase::SetParametersInternal(const RtpParameters& parameters,
       return;
     }
 
+    // nope ?
+
     result = CheckCodecParameters(rtp_parameters);
     if (!result.ok()) {
       webrtc::InvokeSetParametersCallback(callback, result);
@@ -353,7 +358,8 @@ RTCError RtpSenderBase::CheckCodecParameters(const RtpParameters& parameters) {
       send_codec_with_svc_info = *codec_match;
     }
   }
-
+  
+  // here
   return cricket::CheckScalabilityModeValues(parameters, codec_preferences_,
                                              send_codec_with_svc_info);
 }
@@ -364,6 +370,7 @@ RTCError RtpSenderBase::SetParameters(const RtpParameters& parameters) {
   RTCError result = CheckSetParameters(parameters);
   if (!result.ok())
     return result;
+  // nope
 
   // Some tests rely on working in single thread mode without a run loop and a
   // blocking call is required to keep them working. The encoder configuration
diff --git a/src/pc/rtp_sender.h b/src/pc/rtp_sender.h
index d29c376..1a7c34c 100644
--- a/src/pc/rtp_sender.h
+++ b/src/pc/rtp_sender.h
@@ -21,6 +21,7 @@
 #include <memory>
 #include <string>
 #include <vector>
+#include <android/log.h>
 
 #include "absl/types/optional.h"
 #include "api/crypto/frame_encryptor_interface.h"
@@ -225,6 +226,22 @@ class RtpSenderBase : public RtpSenderInternal, public ObserverInterface {
 
   void SetCodecPreferences(
       std::vector<cricket::Codec> codec_preferences) override {
+    __android_log_print(ANDROID_LOG_ERROR, "SetCodecPreferences", "%lu",
+                        (unsigned long)codec_preferences.size());
+    for (size_t i = 0; i < codec_preferences.size(); ++i) {
+      __android_log_print(
+          ANDROID_LOG_ERROR, "SetCodecPreferences scalability_modes", "%lu",
+          (unsigned long)codec_preferences[i].scalability_modes.size());
+
+      for (size_t j = 0; j < codec_preferences[i].scalability_modes.size(); ++j) {
+        auto sv =
+            ScalabilityModeToString(codec_preferences[i].scalability_modes[j]);
+        std::string s = {sv.begin(), sv.end()};
+
+        __android_log_print(ANDROID_LOG_ERROR, "SetCodecPreferences MOD", "%s",
+                            s.c_str());
+      }
+    }
     codec_preferences_ = codec_preferences;
   }
 
diff --git a/src/pc/rtp_transceiver.cc b/src/pc/rtp_transceiver.cc
index 815ec9d..381ba9f 100644
--- a/src/pc/rtp_transceiver.cc
+++ b/src/pc/rtp_transceiver.cc
@@ -17,6 +17,7 @@
 #include <string>
 #include <utility>
 #include <vector>
+#include <android/log.h>
 
 #include "absl/algorithm/container.h"
 #include "absl/memory/memory.h"
@@ -171,6 +172,28 @@ RtpTransceiver::RtpTransceiver(
   RTC_DCHECK(media_type_ == cricket::MEDIA_TYPE_AUDIO ||
              media_type_ == cricket::MEDIA_TYPE_VIDEO);
   RTC_DCHECK_EQ(sender->media_type(), receiver->media_type());
+
+{
+  auto aa = media_engine()->video().send_codecs(false);
+
+      __android_log_print(ANDROID_LOG_ERROR, "RtpTransceiver", "%lu",
+                        (unsigned long)aa.size());
+    for (int i = 0; i < aa.size(); ++i) {
+      __android_log_print(
+          ANDROID_LOG_ERROR, "RtpTransceiver scalability_modes", "%lu",
+          (unsigned long)aa[i].scalability_modes.size());
+
+      for (int j = 0; j < aa[i].scalability_modes.size(); ++j) {
+        auto sv =
+            ScalabilityModeToString(aa[i].scalability_modes[j]);
+        std::string s = {sv.begin(), sv.end()};
+
+        __android_log_print(ANDROID_LOG_ERROR, "RtpTransceiver MOD", "%s",
+                            s.c_str());
+      }
+    }
+}
+
   sender->internal()->SetCodecPreferences(
       sender->media_type() == cricket::MEDIA_TYPE_VIDEO
           ? media_engine()->video().send_codecs(false)
diff --git a/src/sdk/BUILD.gn b/src/sdk/BUILD.gn
index 4f5ceb5..a743579 100644
--- a/src/sdk/BUILD.gn
+++ b/src/sdk/BUILD.gn
@@ -991,6 +991,15 @@ if (is_ios || is_mac) {
         "objc/api/peerconnection/RTCRtcpParameters+Private.h",
         "objc/api/peerconnection/RTCRtcpParameters.h",
         "objc/api/peerconnection/RTCRtcpParameters.mm",
+        "objc/api/peerconnection/RTCRtpCapabilities.h",
+        "objc/api/peerconnection/RTCRtpCapabilities.mm",
+        "objc/api/peerconnection/RTCRtpCapabilities+Private.h",
+        "objc/api/peerconnection/RTCRtpCodecCapability.h",
+        "objc/api/peerconnection/RTCRtpCodecCapability.mm",
+        "objc/api/peerconnection/RTCRtpCodecCapability+Private.h",
+        "objc/api/peerconnection/RTCRtpHeaderExtensionCapability.h",
+        "objc/api/peerconnection/RTCRtpHeaderExtensionCapability.mm",
+        "objc/api/peerconnection/RTCRtpHeaderExtensionCapability+Private.h",
         "objc/api/peerconnection/RTCRtpCodecParameters+Private.h",
         "objc/api/peerconnection/RTCRtpCodecParameters.h",
         "objc/api/peerconnection/RTCRtpCodecParameters.mm",
@@ -1309,6 +1318,9 @@ if (is_ios || is_mac) {
           "objc/api/peerconnection/RTCPeerConnectionFactory.h",
           "objc/api/peerconnection/RTCPeerConnectionFactoryOptions.h",
           "objc/api/peerconnection/RTCRtcpParameters.h",
+          "objc/api/peerconnection/RTCRtpCapabilities.h",
+          "objc/api/peerconnection/RTCRtpCodecCapability.h",
+          "objc/api/peerconnection/RTCRtpHeaderExtensionCapability.h",
           "objc/api/peerconnection/RTCRtpCodecParameters.h",
           "objc/api/peerconnection/RTCRtpEncodingParameters.h",
           "objc/api/peerconnection/RTCRtpHeaderExtension.h",
@@ -1423,6 +1435,9 @@ if (is_ios || is_mac) {
           "objc/api/peerconnection/RTCPeerConnectionFactory.h",
           "objc/api/peerconnection/RTCPeerConnectionFactoryOptions.h",
           "objc/api/peerconnection/RTCRtcpParameters.h",
+          "objc/api/peerconnection/RTCRtpCapabilities.h",
+          "objc/api/peerconnection/RTCRtpCodecCapability.h",
+          "objc/api/peerconnection/RTCRtpHeaderExtensionCapability.h",
           "objc/api/peerconnection/RTCRtpCodecParameters.h",
           "objc/api/peerconnection/RTCRtpEncodingParameters.h",
           "objc/api/peerconnection/RTCRtpHeaderExtension.h",
diff --git a/src/sdk/android/api/org/webrtc/RtpParameters.java b/src/sdk/android/api/org/webrtc/RtpParameters.java
index 9ca8311..1fcffe7 100644
--- a/src/sdk/android/api/org/webrtc/RtpParameters.java
+++ b/src/sdk/android/api/org/webrtc/RtpParameters.java
@@ -73,6 +73,8 @@ public class RtpParameters {
     @Nullable public Integer maxFramerate;
     // The number of temporal layers for video.
     @Nullable public Integer numTemporalLayers;
+    // https://w3c.github.io/webrtc-svc/#rtcrtpencodingparameters
+    @Nullable public String scalabilityMode;
     // If non-null, scale the width and height down by this factor for video. If null,
     // implementation default scaling factor will be used.
     @Nullable public Double scaleResolutionDownBy;
@@ -93,7 +95,7 @@ public class RtpParameters {
     @CalledByNative("Encoding")
     Encoding(String rid, boolean active, double bitratePriority, @Priority int networkPriority,
         Integer maxBitrateBps, Integer minBitrateBps, Integer maxFramerate,
-        Integer numTemporalLayers, Double scaleResolutionDownBy, Long ssrc,
+        Integer numTemporalLayers, String scalabilityMode, Double scaleResolutionDownBy, Long ssrc,
         boolean adaptiveAudioPacketTime) {
       this.rid = rid;
       this.active = active;
@@ -103,6 +105,7 @@ public class RtpParameters {
       this.minBitrateBps = minBitrateBps;
       this.maxFramerate = maxFramerate;
       this.numTemporalLayers = numTemporalLayers;
+      this.scalabilityMode = scalabilityMode;
       this.scaleResolutionDownBy = scaleResolutionDownBy;
       this.ssrc = ssrc;
       this.adaptiveAudioPacketTime = adaptiveAudioPacketTime;
@@ -154,6 +157,12 @@ public class RtpParameters {
       return numTemporalLayers;
     }
 
+    @Nullable
+    @CalledByNative("Encoding")
+    String getScalabilityMode() {
+      return scalabilityMode;
+    }
+
     @Nullable
     @CalledByNative("Encoding")
     Double getScaleResolutionDownBy() {
diff --git a/src/sdk/android/src/jni/pc/rtp_parameters.cc b/src/sdk/android/src/jni/pc/rtp_parameters.cc
index 4bd9ee0..1f5957b 100644
--- a/src/sdk/android/src/jni/pc/rtp_parameters.cc
+++ b/src/sdk/android/src/jni/pc/rtp_parameters.cc
@@ -52,6 +52,7 @@ ScopedJavaLocalRef<jobject> NativeToJavaRtpEncodingParameter(
       NativeToJavaInteger(env, encoding.min_bitrate_bps),
       NativeToJavaInteger(env, encoding.max_framerate),
       NativeToJavaInteger(env, encoding.num_temporal_layers),
+      NativeToJavaString(env, encoding.scalability_mode),
       NativeToJavaDouble(env, encoding.scale_resolution_down_by),
       encoding.ssrc ? NativeToJavaLong(env, *encoding.ssrc) : nullptr,
       encoding.adaptive_ptime);
@@ -112,6 +113,11 @@ RtpEncodingParameters JavaToNativeRtpEncodingParameters(
       Java_Encoding_getNumTemporalLayers(jni, j_encoding_parameters);
   encoding.num_temporal_layers =
       JavaToNativeOptionalInt(jni, j_num_temporal_layers);
+  ScopedJavaLocalRef<jstring> j_scalability_mode =
+      Java_Encoding_getScalabilityMode(jni, j_encoding_parameters);
+  if (!IsNull(jni, j_scalability_mode)) {
+    encoding.scalability_mode = JavaToNativeString(jni, j_scalability_mode);
+  }
   ScopedJavaLocalRef<jobject> j_scale_resolution_down_by =
       Java_Encoding_getScaleResolutionDownBy(jni, j_encoding_parameters);
   encoding.scale_resolution_down_by =
diff --git a/src/sdk/android/src/jni/pc/rtp_sender.cc b/src/sdk/android/src/jni/pc/rtp_sender.cc
index ddb53f6..533d0e9 100644
--- a/src/sdk/android/src/jni/pc/rtp_sender.cc
+++ b/src/sdk/android/src/jni/pc/rtp_sender.cc
@@ -70,7 +70,7 @@ jlong JNI_RtpSender_GetDtmfSender(JNIEnv* jni, jlong j_rtp_sender_pointer) {
           ->GetDtmfSender()
           .release());
 }
-
+ // here
 jboolean JNI_RtpSender_SetParameters(
     JNIEnv* jni,
     jlong j_rtp_sender_pointer,
diff --git a/src/sdk/objc/api/peerconnection/RTCPeerConnectionFactory.h b/src/sdk/objc/api/peerconnection/RTCPeerConnectionFactory.h
index 5575af9..f8dfae1 100644
--- a/src/sdk/objc/api/peerconnection/RTCPeerConnectionFactory.h
+++ b/src/sdk/objc/api/peerconnection/RTCPeerConnectionFactory.h
@@ -23,6 +23,10 @@ NS_ASSUME_NONNULL_BEGIN
 @class RTC_OBJC_TYPE(RTCVideoSource);
 @class RTC_OBJC_TYPE(RTCVideoTrack);
 @class RTC_OBJC_TYPE(RTCPeerConnectionFactoryOptions);
+@class RTC_OBJC_TYPE(RTCRtpCapabilities);
+
+typedef NS_ENUM(NSInteger, RTCRtpMediaType);
+
 @protocol RTC_OBJC_TYPE
 (RTCPeerConnectionDelegate);
 @protocol RTC_OBJC_TYPE
@@ -51,6 +55,10 @@ RTC_OBJC_EXPORT
             decoderFactory:(nullable id<RTC_OBJC_TYPE(RTCVideoDecoderFactory)>)decoderFactory
                audioDevice:(nullable id<RTC_OBJC_TYPE(RTCAudioDevice)>)audioDevice;
 
+- (RTC_OBJC_TYPE(RTCRtpCapabilities) *)rtpSenderCapabilitiesFor:(RTCRtpMediaType)mediaType;
+
+- (RTC_OBJC_TYPE(RTCRtpCapabilities) *)rtpReceiverCapabilitiesFor:(RTCRtpMediaType)mediaType;
+
 /** Initialize an RTCAudioSource with constraints. */
 - (RTC_OBJC_TYPE(RTCAudioSource) *)audioSourceWithConstraints:
     (nullable RTC_OBJC_TYPE(RTCMediaConstraints) *)constraints;
diff --git a/src/sdk/objc/api/peerconnection/RTCPeerConnectionFactory.mm b/src/sdk/objc/api/peerconnection/RTCPeerConnectionFactory.mm
index 62b5554..e63104d 100644
--- a/src/sdk/objc/api/peerconnection/RTCPeerConnectionFactory.mm
+++ b/src/sdk/objc/api/peerconnection/RTCPeerConnectionFactory.mm
@@ -21,6 +21,9 @@
 #import "RTCPeerConnection+Private.h"
 #import "RTCVideoSource+Private.h"
 #import "RTCVideoTrack+Private.h"
+#import "RTCRtpReceiver+Private.h"
+#import "RTCRtpCapabilities+Private.h"
+#import "RTCRtpCodecCapability+Private.h"
 #import "base/RTCLogging.h"
 #import "base/RTCVideoDecoderFactory.h"
 #import "base/RTCVideoEncoderFactory.h"
@@ -116,6 +119,20 @@
 #endif
 }
 
+- (RTC_OBJC_TYPE(RTCRtpCapabilities) *)rtpSenderCapabilitiesFor:(RTCRtpMediaType)mediaType {
+
+  webrtc::RtpCapabilities capabilities = _nativeFactory->GetRtpSenderCapabilities([RTCRtpReceiver nativeMediaTypeForMediaType: mediaType]);
+
+  return [[RTCRtpCapabilities alloc] initWithNativeCapabilities: capabilities];
+}
+
+- (RTC_OBJC_TYPE(RTCRtpCapabilities) *)rtpReceiverCapabilitiesFor:(RTCRtpMediaType)mediaType {
+
+  webrtc::RtpCapabilities capabilities = _nativeFactory->GetRtpReceiverCapabilities([RTCRtpReceiver nativeMediaTypeForMediaType: mediaType]);
+
+  return [[RTCRtpCapabilities alloc] initWithNativeCapabilities: capabilities];
+}
+
 - (instancetype)initNative {
   if (self = [super init]) {
     _networkThread = rtc::Thread::CreateWithSocketServer();
diff --git a/src/sdk/objc/api/peerconnection/RTCRtpCapabilities+Private.h b/src/sdk/objc/api/peerconnection/RTCRtpCapabilities+Private.h
new file mode 100644
index 0000000..15c8fe3
--- /dev/null
+++ b/src/sdk/objc/api/peerconnection/RTCRtpCapabilities+Private.h
@@ -0,0 +1,33 @@
+/*
+ * Copyright 2023 LiveKit
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#import "RTCRtpCapabilities.h"
+
+#include "api/rtp_parameters.h"
+
+NS_ASSUME_NONNULL_BEGIN
+
+@interface RTC_OBJC_TYPE (RTCRtpCapabilities)
+()
+
+    @property(nonatomic, readonly) webrtc::RtpCapabilities nativeCapabilities;
+
+- (instancetype)initWithNativeCapabilities:(const webrtc::RtpCapabilities &)nativeCapabilities
+    NS_DESIGNATED_INITIALIZER;
+
+@end
+
+NS_ASSUME_NONNULL_END
\ No newline at end of file
diff --git a/src/sdk/objc/api/peerconnection/RTCRtpCapabilities.h b/src/sdk/objc/api/peerconnection/RTCRtpCapabilities.h
new file mode 100644
index 0000000..2dea41a
--- /dev/null
+++ b/src/sdk/objc/api/peerconnection/RTCRtpCapabilities.h
@@ -0,0 +1,37 @@
+/*
+ * Copyright 2023 LiveKit
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#import <Foundation/Foundation.h>
+
+#import "RTCMacros.h"
+
+@class RTC_OBJC_TYPE(RTCRtpCodecCapability);
+@class RTC_OBJC_TYPE(RTCRtpHeaderExtensionCapability);
+
+NS_ASSUME_NONNULL_BEGIN
+
+RTC_OBJC_EXPORT
+@interface RTC_OBJC_TYPE (RTCRtpCapabilities) : NSObject
+
+- (instancetype)init NS_UNAVAILABLE;
+
+@property(nonatomic, readonly) NSArray<RTC_OBJC_TYPE(RTCRtpCodecCapability) *> *codecs;
+
+@property(nonatomic, readonly) NSArray<RTC_OBJC_TYPE(RTCRtpHeaderExtensionCapability) *> *header_extensions;
+
+@end
+
+NS_ASSUME_NONNULL_END
\ No newline at end of file
diff --git a/src/sdk/objc/api/peerconnection/RTCRtpCapabilities.mm b/src/sdk/objc/api/peerconnection/RTCRtpCapabilities.mm
new file mode 100644
index 0000000..7f73108
--- /dev/null
+++ b/src/sdk/objc/api/peerconnection/RTCRtpCapabilities.mm
@@ -0,0 +1,63 @@
+/*
+ * Copyright 2023 LiveKit
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#import "RTCRtpCapabilities+Private.h"
+#import "RTCRtpCodecCapability+Private.h"
+#import "RTCRtpHeaderExtensionCapability+Private.h"
+
+#import "RTCMediaStreamTrack.h"
+#import "helpers/NSString+StdString.h"
+
+#include "media/base/media_constants.h"
+#include "rtc_base/checks.h"
+
+@implementation RTC_OBJC_TYPE (RTCRtpCapabilities)
+
+@synthesize nativeCapabilities = _nativeCapabilities;
+
+- (instancetype)initWithNativeCapabilities:(const webrtc::RtpCapabilities &)nativeCapabilities {
+  if (self = [super init]) {
+    _nativeCapabilities = nativeCapabilities;
+  }
+
+  return self;
+}
+
+- (NSArray<RTC_OBJC_TYPE(RTCRtpCodecCapability) *> *)codecs {
+  NSMutableArray *result = [NSMutableArray array];
+
+  for (auto &element : _nativeCapabilities.codecs) {
+    RTCRtpCodecCapability *object =
+        [[RTCRtpCodecCapability alloc] initWithNativeCodecCapability:element];
+    [result addObject:object];
+  }
+
+  return result;
+}
+
+- (NSArray<RTC_OBJC_TYPE(RTCRtpHeaderExtensionCapability) *> *)header_extensions {
+  NSMutableArray *result = [NSMutableArray array];
+
+  for (auto &element : _nativeCapabilities.header_extensions) {
+    RTCRtpHeaderExtensionCapability *object =
+        [[RTCRtpHeaderExtensionCapability alloc] initWithNativeHeaderExtensionCapability:element];
+    [result addObject:object];
+  }
+
+  return result;
+}
+
+@end
\ No newline at end of file
diff --git a/src/sdk/objc/api/peerconnection/RTCRtpCodecCapability+Private.h b/src/sdk/objc/api/peerconnection/RTCRtpCodecCapability+Private.h
new file mode 100644
index 0000000..b36d26c
--- /dev/null
+++ b/src/sdk/objc/api/peerconnection/RTCRtpCodecCapability+Private.h
@@ -0,0 +1,33 @@
+/*
+ * Copyright 2023 LiveKit
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#import "RTCRtpCodecCapability.h"
+
+#include "api/rtp_parameters.h"
+
+NS_ASSUME_NONNULL_BEGIN
+
+@interface RTC_OBJC_TYPE (RTCRtpCodecCapability)
+()
+
+    @property(nonatomic, readonly) webrtc::RtpCodecCapability nativeCodecCapability;
+
+- (instancetype)initWithNativeCodecCapability:
+    (const webrtc::RtpCodecCapability &)nativeCodecCapability NS_DESIGNATED_INITIALIZER;
+
+@end
+
+NS_ASSUME_NONNULL_END
\ No newline at end of file
diff --git a/src/sdk/objc/api/peerconnection/RTCRtpCodecCapability.h b/src/sdk/objc/api/peerconnection/RTCRtpCodecCapability.h
new file mode 100644
index 0000000..0daf40e
--- /dev/null
+++ b/src/sdk/objc/api/peerconnection/RTCRtpCodecCapability.h
@@ -0,0 +1,63 @@
+/*
+ * Copyright 2023 LiveKit
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#import <Foundation/Foundation.h>
+
+#import "RTCMacros.h"
+
+typedef NS_ENUM(NSInteger, RTCRtpMediaType);
+
+NS_ASSUME_NONNULL_BEGIN
+
+RTC_OBJC_EXPORT
+@interface RTC_OBJC_TYPE (RTCRtpCodecCapability) : NSObject
+
+// Build MIME "type/subtype" string from `name` and `kind`.
+@property(nonatomic, readonly) NSString *mimeType;
+
+// Used to identify the codec. Equivalent to MIME subtype.
+@property(nonatomic, copy) NSString *name;
+
+// The media type of this codec. Equivalent to MIME top-level type.
+@property(nonatomic, assign) RTCRtpMediaType kind;
+
+// Clock rate in Hertz. If unset, the codec is applicable to any clock rate.
+@property(nonatomic, copy, nullable) NSNumber *clockRate;
+
+// Default payload type for this codec. Mainly needed for codecs that use
+// that have statically assigned payload types.
+@property(nonatomic, copy, nullable) NSNumber *preferredPayloadType;
+
+// The number of audio channels supported. Unused for video codecs.
+@property(nonatomic, copy, nullable) NSNumber *numChannels;
+
+// Codec-specific parameters that must be signaled to the remote party.
+//
+// Corresponds to "a=fmtp" parameters in SDP.
+//
+// Contrary to ORTC, these parameters are named using all lowercase strings.
+// This helps make the mapping to SDP simpler, if an application is using SDP.
+// Boolean values are represented by the string "1".
+// std::map<std::string, std::string> parameters;
+@property(nonatomic, copy) NSDictionary<NSString *, NSString *> *parameters;
+
+// Feedback mechanisms supported for this codec.
+// std::vector<RtcpFeedback> rtcp_feedback;
+// Not implemented.
+
+@end
+
+NS_ASSUME_NONNULL_END
\ No newline at end of file
diff --git a/src/sdk/objc/api/peerconnection/RTCRtpCodecCapability.mm b/src/sdk/objc/api/peerconnection/RTCRtpCodecCapability.mm
new file mode 100644
index 0000000..341cde4
--- /dev/null
+++ b/src/sdk/objc/api/peerconnection/RTCRtpCodecCapability.mm
@@ -0,0 +1,138 @@
+/*
+ * Copyright 2023 LiveKit
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#import "RTCRtpCodecCapability+Private.h"
+
+#import "RTCRtpReceiver+Private.h"
+
+#import "RTCMediaStreamTrack.h"
+#import "helpers/NSString+StdString.h"
+
+#include "media/base/media_constants.h"
+#include "rtc_base/checks.h"
+
+@implementation RTC_OBJC_TYPE (RTCRtpCodecCapability)
+
+@synthesize nativeCodecCapability = _nativeCodecCapability;
+
+- (instancetype)init {
+  return [self initWithNativeCodecCapability:webrtc::RtpCodecCapability()];
+}
+
+- (instancetype)initWithNativeCodecCapability:
+    (const webrtc::RtpCodecCapability &)nativeCodecCapability {
+  if (self = [super init]) {
+    _nativeCodecCapability = nativeCodecCapability;
+  }
+
+  return self;
+}
+
+- (NSString *)mimeType {
+  return [NSString stringWithUTF8String:_nativeCodecCapability.mime_type().c_str()];
+}
+
+- (NSString *)name {
+  return [NSString stringWithUTF8String:_nativeCodecCapability.name.c_str()];
+}
+
+- (void)setName:(NSString *)name {
+  _nativeCodecCapability.name = std::string([name UTF8String]);
+}
+
+- (RTCRtpMediaType)kind {
+  return [RTCRtpReceiver mediaTypeForNativeMediaType:_nativeCodecCapability.kind];
+}
+
+- (void)setKind:(RTCRtpMediaType)kind {
+  _nativeCodecCapability.kind = [RTCRtpReceiver nativeMediaTypeForMediaType:kind];
+}
+
+- (NSNumber *)clockRate {
+  if (!_nativeCodecCapability.clock_rate) {
+    return nil;
+  }
+
+  return [NSNumber numberWithInt:*_nativeCodecCapability.clock_rate];
+}
+
+- (void)setClockRate:(NSNumber *)clockRate {
+  if (clockRate == nil) {
+    _nativeCodecCapability.clock_rate = absl::optional<int>();
+    return;
+  }
+
+  _nativeCodecCapability.clock_rate = absl::optional<int>(clockRate.intValue);
+}
+
+- (NSNumber *)preferredPayloadType {
+  if (!_nativeCodecCapability.preferred_payload_type) {
+    return nil;
+  }
+
+  return [NSNumber numberWithInt:*_nativeCodecCapability.preferred_payload_type];
+}
+
+- (void)setPreferredPayloadType:(NSNumber *)preferredPayloadType {
+  if (preferredPayloadType == nil) {
+    _nativeCodecCapability.preferred_payload_type = absl::optional<int>();
+    return;
+  }
+
+  _nativeCodecCapability.preferred_payload_type =
+      absl::optional<int>(preferredPayloadType.intValue);
+}
+
+- (NSNumber *)numChannels {
+  if (!_nativeCodecCapability.num_channels) {
+    return nil;
+  }
+
+  return [NSNumber numberWithInt:*_nativeCodecCapability.num_channels];
+}
+
+- (void)setNumChannels:(NSNumber *)numChannels {
+  if (numChannels == nil) {
+    _nativeCodecCapability.num_channels = absl::optional<int>();
+    return;
+  }
+
+  _nativeCodecCapability.num_channels = absl::optional<int>(numChannels.intValue);
+}
+
+- (NSDictionary<NSString *, NSString *> *)parameters {
+  NSMutableDictionary *result = [NSMutableDictionary dictionary];
+  auto _parameters = _nativeCodecCapability.parameters;
+  for (auto it = _parameters.begin(); it != _parameters.end(); ++it) {
+    [result setObject:[NSString stringForStdString:it->second]
+               forKey:[NSString stringForStdString:it->first]];
+  }
+
+  return result;
+}
+
+- (void)setParameters:(NSDictionary<NSString *, NSString *> *)parameters {
+  std::map<std::string, std::string> _parameters;
+  for (NSString *paramKey in parameters.allKeys) {
+    std::string key = [NSString stdStringForString:paramKey];
+    std::string value = [NSString stdStringForString:parameters[paramKey]];
+    _parameters[key] = value;
+  }
+
+  _nativeCodecCapability.parameters = _parameters;
+}
+
+@end
\ No newline at end of file
diff --git a/src/sdk/objc/api/peerconnection/RTCRtpEncodingParameters.h b/src/sdk/objc/api/peerconnection/RTCRtpEncodingParameters.h
index 07f6b7a..d055115 100644
--- a/src/sdk/objc/api/peerconnection/RTCRtpEncodingParameters.h
+++ b/src/sdk/objc/api/peerconnection/RTCRtpEncodingParameters.h
@@ -51,6 +51,10 @@ RTC_OBJC_EXPORT
  */
 @property(nonatomic, copy, nullable) NSNumber *numTemporalLayers;
 
+/** A case-sensitive identifier of the scalability mode to be used for this stream.
+  https://w3c.github.io/webrtc-svc/#rtcrtpencodingparameters */
+@property(nonatomic, copy, nullable) NSString *scalabilityMode;
+
 /** Scale the width and height down by this factor for video. If nil,
  * implementation default scaling factor will be used.
  */
diff --git a/src/sdk/objc/api/peerconnection/RTCRtpEncodingParameters.mm b/src/sdk/objc/api/peerconnection/RTCRtpEncodingParameters.mm
index d6087da..e2020bb 100644
--- a/src/sdk/objc/api/peerconnection/RTCRtpEncodingParameters.mm
+++ b/src/sdk/objc/api/peerconnection/RTCRtpEncodingParameters.mm
@@ -20,6 +20,7 @@
 @synthesize minBitrateBps = _minBitrateBps;
 @synthesize maxFramerate = _maxFramerate;
 @synthesize numTemporalLayers = _numTemporalLayers;
+@synthesize scalabilityMode = _scalabilityMode;
 @synthesize scaleResolutionDownBy = _scaleResolutionDownBy;
 @synthesize ssrc = _ssrc;
 @synthesize bitratePriority = _bitratePriority;
@@ -52,6 +53,9 @@
     if (nativeParameters.num_temporal_layers) {
       _numTemporalLayers = [NSNumber numberWithInt:*nativeParameters.num_temporal_layers];
     }
+    if (nativeParameters.scalability_mode) {
+      _scalabilityMode = [NSString stringWithUTF8String:nativeParameters.scalability_mode->c_str()];
+    }
     if (nativeParameters.scale_resolution_down_by) {
       _scaleResolutionDownBy =
           [NSNumber numberWithDouble:*nativeParameters.scale_resolution_down_by];
@@ -85,6 +89,9 @@
   if (_numTemporalLayers != nil) {
     parameters.num_temporal_layers = absl::optional<int>(_numTemporalLayers.intValue);
   }
+  if (_scalabilityMode != nil) {
+    parameters.scalability_mode = absl::optional<std::string>(std::string([_scalabilityMode UTF8String]));
+  }
   if (_scaleResolutionDownBy != nil) {
     parameters.scale_resolution_down_by =
         absl::optional<double>(_scaleResolutionDownBy.doubleValue);
diff --git a/src/sdk/objc/api/peerconnection/RTCRtpHeaderExtensionCapability+Private.h b/src/sdk/objc/api/peerconnection/RTCRtpHeaderExtensionCapability+Private.h
new file mode 100644
index 0000000..2fa8c25
--- /dev/null
+++ b/src/sdk/objc/api/peerconnection/RTCRtpHeaderExtensionCapability+Private.h
@@ -0,0 +1,33 @@
+/*
+ * Copyright 2023 LiveKit
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#import "RTCRtpHeaderExtensionCapability.h"
+
+#include "api/rtp_parameters.h"
+
+NS_ASSUME_NONNULL_BEGIN
+
+@interface RTC_OBJC_TYPE (RTCRtpHeaderExtensionCapability)
+()
+
+    @property(nonatomic, readonly) webrtc::RtpHeaderExtensionCapability nativeHeaderExtensionCapability;
+
+- (instancetype)initWithNativeHeaderExtensionCapability:
+    (const webrtc::RtpHeaderExtensionCapability &)nativeHeaderExtensionCapability NS_DESIGNATED_INITIALIZER;
+
+@end
+
+NS_ASSUME_NONNULL_END
\ No newline at end of file
diff --git a/src/sdk/objc/api/peerconnection/RTCRtpHeaderExtensionCapability.h b/src/sdk/objc/api/peerconnection/RTCRtpHeaderExtensionCapability.h
new file mode 100644
index 0000000..27bb0e5
--- /dev/null
+++ b/src/sdk/objc/api/peerconnection/RTCRtpHeaderExtensionCapability.h
@@ -0,0 +1,37 @@
+/*
+ * Copyright 2023 LiveKit
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#import <Foundation/Foundation.h>
+
+#import "RTCMacros.h"
+
+NS_ASSUME_NONNULL_BEGIN
+
+RTC_OBJC_EXPORT
+@interface RTC_OBJC_TYPE (RTCRtpHeaderExtensionCapability) : NSObject
+
+// URI of this extension, as defined in RFC8285.
+@property(nonatomic, readonly) NSString *uri;
+
+// Preferred value of ID that goes in the packet.
+@property(nonatomic, assign) NSNumber *preferred_id;
+
+// If true, it's preferred that the value in the header is encrypted.
+@property(nonatomic, assign) BOOL preferred_encrypt;
+
+@end
+
+NS_ASSUME_NONNULL_END
\ No newline at end of file
diff --git a/src/sdk/objc/api/peerconnection/RTCRtpHeaderExtensionCapability.mm b/src/sdk/objc/api/peerconnection/RTCRtpHeaderExtensionCapability.mm
new file mode 100644
index 0000000..e36d2b4
--- /dev/null
+++ b/src/sdk/objc/api/peerconnection/RTCRtpHeaderExtensionCapability.mm
@@ -0,0 +1,54 @@
+/*
+ * Copyright 2023 LiveKit
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#import "RTCRtpHeaderExtensionCapability+Private.h"
+
+#import "helpers/NSString+StdString.h"
+
+#include "media/base/media_constants.h"
+#include "rtc_base/checks.h"
+
+@implementation RTC_OBJC_TYPE (RTCRtpHeaderExtensionCapability)
+
+@synthesize nativeHeaderExtensionCapability = _nativeHeaderExtensionCapability;
+
+- (instancetype)init {
+  return [self initWithNativeHeaderExtensionCapability:webrtc::RtpHeaderExtensionCapability()];
+}
+
+- (instancetype)initWithNativeHeaderExtensionCapability:
+    (const webrtc::RtpHeaderExtensionCapability &)nativeHeaderExtensionCapability {
+  if (self = [super init]) {
+    _nativeHeaderExtensionCapability = nativeHeaderExtensionCapability;
+  }
+
+  return self;
+}
+
+- (NSString *)uri {
+  return [NSString stringWithUTF8String:_nativeHeaderExtensionCapability.uri.c_str()];
+}
+
+- (NSNumber *)preferredId {
+  return [NSNumber numberWithInt:*_nativeHeaderExtensionCapability.preferred_id];
+
+}
+
+- (BOOL)preferredEncrypt {
+  return _nativeHeaderExtensionCapability.preferred_encrypt;
+}
+
+@end
\ No newline at end of file
diff --git a/src/api/video_codecs/builtin_video_encoder_factory.cc b/src/api/video_codecs/builtin_video_encoder_factory.cc
index 573eb47..fada36f 100644
--- a/src/api/video_codecs/builtin_video_encoder_factory.cc
+++ b/src/api/video_codecs/builtin_video_encoder_factory.cc
@@ -13,6 +13,7 @@
 #include <memory>
 #include <string>
 #include <vector>
+#include <android/log.h>
 
 #include "absl/strings/match.h"
 #include "absl/types/optional.h"
@@ -50,6 +51,7 @@ class BuiltinVideoEncoderFactory : public VideoEncoderFactory {
   }
 
   std::vector<SdpVideoFormat> GetSupportedFormats() const override {
+  __android_log_print(ANDROID_LOG_ERROR, "HORSE", "%s", "NOPE");
     return internal_encoder_factory_->GetSupportedFormats();
   }
 
diff --git a/src/api/video_codecs/video_decoder_factory_template.h b/src/api/video_codecs/video_decoder_factory_template.h
index 703ae11..227ec0b 100644
--- a/src/api/video_codecs/video_decoder_factory_template.h
+++ b/src/api/video_codecs/video_decoder_factory_template.h
@@ -39,6 +39,7 @@ template <typename... Ts>
 class VideoDecoderFactoryTemplate : public VideoDecoderFactory {
  public:
   std::vector<SdpVideoFormat> GetSupportedFormats() const override {
+    __android_log_print(ANDROID_LOG_ERROR, "HORSE2", "%s", "NOPE");
     return GetSupportedFormatsInternal<Ts...>();
   }
 
@@ -60,12 +61,14 @@ class VideoDecoderFactoryTemplate : public VideoDecoderFactory {
 
   template <typename V, typename... Vs>
   std::vector<SdpVideoFormat> GetSupportedFormatsInternal() const {
+    __android_log_print(ANDROID_LOG_ERROR, "HORSE3", "%s", "NOPE")
     auto supported_formats = V::SupportedFormats();
 
     if constexpr (sizeof...(Vs) > 0) {
       // Supported formats may overlap between implementations, so duplicates
       // should be filtered out.
       for (const auto& other_format : GetSupportedFormatsInternal<Vs...>()) {
+        __android_log_print(ANDROID_LOG_ERROR, "HORSE4", "%s", "NOPE")
         if (!IsFormatInList(other_format, supported_formats)) {
           supported_formats.push_back(other_format);
         }
diff --git a/src/api/video_codecs/video_encoder_factory_template.h b/src/api/video_codecs/video_encoder_factory_template.h
index 10212ac..44f61a7 100644
--- a/src/api/video_codecs/video_encoder_factory_template.h
+++ b/src/api/video_codecs/video_encoder_factory_template.h
@@ -14,6 +14,7 @@
 #include <memory>
 #include <string>
 #include <vector>
+#include <android/log.h>
 
 #include "absl/algorithm/container.h"
 #include "api/array_view.h"
@@ -47,6 +48,7 @@ template <typename... Ts>
 class VideoEncoderFactoryTemplate : public VideoEncoderFactory {
  public:
   std::vector<SdpVideoFormat> GetSupportedFormats() const override {
+    __android_log_print(ANDROID_LOG_ERROR, "HOPE", "%s", "NOPE")
     return GetSupportedFormatsInternal<Ts...>();
   }
 
@@ -95,12 +97,14 @@ class VideoEncoderFactoryTemplate : public VideoEncoderFactory {
 
   template <typename V, typename... Vs>
   std::vector<SdpVideoFormat> GetSupportedFormatsInternal() const {
+    __android_log_print(ANDROID_LOG_ERROR, "HOPE2", "%s", "NOPE")
     auto supported_formats = V::SupportedFormats();
 
     if constexpr (sizeof...(Vs) > 0) {
       // Supported formats may overlap between implementations, so duplicates
       // should be filtered out.
       for (const auto& other_format : GetSupportedFormatsInternal<Vs...>()) {
+    __android_log_print(ANDROID_LOG_ERROR, "HOPE3", "%s", "NOPE")
         if (!IsFormatInList(other_format, supported_formats)) {
           supported_formats.push_back(other_format);
         }
diff --git a/src/api/video_codecs/video_encoder_factory_template_libvpx_vp8_adapter.h b/src/api/video_codecs/video_encoder_factory_template_libvpx_vp8_adapter.h
index 0f0a9ba..a2d608b 100644
--- a/src/api/video_codecs/video_encoder_factory_template_libvpx_vp8_adapter.h
+++ b/src/api/video_codecs/video_encoder_factory_template_libvpx_vp8_adapter.h
@@ -18,6 +18,7 @@
 #include "api/video_codecs/sdp_video_format.h"
 #include "modules/video_coding/codecs/vp8/include/vp8.h"
 #include "modules/video_coding/codecs/vp8/vp8_scalability.h"
+#include <android/log.h>
 
 namespace webrtc {
 struct LibvpxVp8EncoderTemplateAdapter {
@@ -26,6 +27,9 @@ struct LibvpxVp8EncoderTemplateAdapter {
         scalability_modes;
     for (const auto scalability_mode : kVP8SupportedScalabilityModes) {
       scalability_modes.push_back(scalability_mode);
+        auto sv2 = ScalabilityModeToString(scalability_mode);
+        std::string s2 = {sv2.begin(), sv2.end()};
+        __android_log_print(ANDROID_LOG_ERROR, "LibvpxVp8EncoderTemplateAdapter", "%s", s2.c_str());
     }
 
     return {
diff --git a/src/media/base/media_engine.cc b/src/media/base/media_engine.cc
index 7304ab0..e69e712 100644
--- a/src/media/base/media_engine.cc
+++ b/src/media/base/media_engine.cc
@@ -15,6 +15,9 @@
 #include <cstdint>
 #include <string>
 #include <utility>
+#include <sstream>
+#include <iostream>
+#include <android/log.h>
 
 #include "absl/algorithm/container.h"
 #include "api/video/video_bitrate_allocation.h"
@@ -95,10 +98,22 @@ webrtc::RTCError CheckScalabilityModeValues(
       }
     }
     if (rtp_parameters.encodings[i].scalability_mode) {
+        std::stringstream ss;
       if (!send_codec) {
-        bool scalabilityModeFound = false;
-        for (const cricket::VideoCodec& codec : codec_preferences) {
-          for (const auto& scalability_mode : codec.scalability_modes) {
+         bool scalabilityModeFound = false;
+        __android_log_print(ANDROID_LOG_ERROR, "codec_preferences", "%lu", (unsigned long) codec_preferences.size());
+         for (const cricket::VideoCodec& codec : codec_preferences) {
+        __android_log_print(ANDROID_LOG_ERROR, "codec", "|%s|", codec.name.c_str());
+        __android_log_print(ANDROID_LOG_ERROR, "codec_preferences.scalability_modes", "%lu", (unsigned long) codec.scalability_modes.size());
+           for (const auto& scalability_mode : codec.scalability_modes) {
+        auto sv = *rtp_parameters.encodings[i].scalability_mode; auto sv2 = ScalabilityModeToString(scalability_mode);
+        std::string s = {sv.begin(), sv.end()}; std::string s2 = {sv2.begin(), sv2.end()};
+        __android_log_print(ANDROID_LOG_ERROR, "scalability_mode", "|%s|", s2.c_str());
+        __android_log_print(ANDROID_LOG_ERROR, "scalability_mode2", "|%s|", s.c_str());
+
+
+          ss << "\nscalability_mode" << ScalabilityModeToString(scalability_mode) << "-" << *rtp_parameters.encodings[i].scalability_mode;
+
             if (ScalabilityModeToString(scalability_mode) ==
                 *rtp_parameters.encodings[i].scalability_mode) {
               scalabilityModeFound = true;
@@ -110,14 +125,24 @@ webrtc::RTCError CheckScalabilityModeValues(
         }
 
         if (!scalabilityModeFound) {
+        __android_log_print(ANDROID_LOG_ERROR, "AAAAA42", "%s", ss.str().c_str());
+          std::cout << ss.str() << std::endl;
           LOG_AND_RETURN_ERROR(
               RTCErrorType::INVALID_MODIFICATION,
               "Attempted to set RtpParameters scalabilityMode "
               "to an unsupported value for the current codecs.");
         }
       } else {
+          ss << "\nsend_codec";
+
         bool scalabilityModeFound = false;
         for (const auto& scalability_mode : send_codec->scalability_modes) {
+          ss << "\nscalability_mode" << ScalabilityModeToString(scalability_mode) << "-" << *rtp_parameters.encodings[i].scalability_mode;
+        auto sv = *rtp_parameters.encodings[i].scalability_mode; auto sv2 = ScalabilityModeToString(scalability_mode);
+        std::string s = {sv.begin(), sv.end()}; std::string s2 = {sv2.begin(), sv2.end()};
+        __android_log_print(ANDROID_LOG_ERROR, "scalability_mode", "|%s|", s2.c_str());
+        __android_log_print(ANDROID_LOG_ERROR, "scalability_mode2", "|%s|", s.c_str());
+
           if (ScalabilityModeToString(scalability_mode) ==
               *rtp_parameters.encodings[i].scalability_mode) {
             scalabilityModeFound = true;
@@ -125,6 +150,8 @@ webrtc::RTCError CheckScalabilityModeValues(
           }
         }
         if (!scalabilityModeFound) {
+        __android_log_print(ANDROID_LOG_ERROR, "AAAAA422", "%s", ss.str().c_str());
+          std::cout << ss.str() << std::endl;
           LOG_AND_RETURN_ERROR(
               RTCErrorType::INVALID_MODIFICATION,
               "Attempted to set RtpParameters scalabilityMode "
diff --git a/src/media/engine/webrtc_video_engine.cc b/src/media/engine/webrtc_video_engine.cc
index 91750b8..c63ced1 100644
--- a/src/media/engine/webrtc_video_engine.cc
+++ b/src/media/engine/webrtc_video_engine.cc
@@ -19,6 +19,7 @@
 #include <string>
 #include <type_traits>
 #include <utility>
+#include <android/log.h>
 
 #include "absl/algorithm/container.h"
 #include "absl/container/inlined_vector.h"
@@ -179,7 +180,10 @@ std::vector<VideoCodec> GetPayloadTypesAndDefaultCodecs(
     bool is_decoder_factory,
     bool include_rtx,
     const webrtc::FieldTrialsView& trials) {
+
+  __android_log_print(ANDROID_LOG_ERROR, "GetPayloadTypesAndDefaultCodecs", "%s", "GetPayloadTypesAndDefaultCodecs");
   if (!factory) {
+  __android_log_print(ANDROID_LOG_ERROR, "GetPayloadTypesAndDefaultCodecs", "%s", "NOPE");
     return {};
   }
 
@@ -219,6 +223,8 @@ std::vector<VideoCodec> GetPayloadTypesAndDefaultCodecs(
 
   std::vector<VideoCodec> output_codecs;
   for (const webrtc::SdpVideoFormat& format : supported_formats) {
+  __android_log_print(ANDROID_LOG_ERROR, "GetPayloadTypesAndDefaultCodecs", "%s %lu", format.name.c_str(), (unsigned long) format.scalability_modes.size());
+
     VideoCodec codec = cricket::CreateVideoCodec(format);
     bool isFecCodec = absl::EqualsIgnoreCase(codec.name, kUlpfecCodecName) ||
                       absl::EqualsIgnoreCase(codec.name, kFlexfecCodecName);
diff --git a/src/modules/video_coding/codecs/av1/av1_svc_config.cc b/src/modules/video_coding/codecs/av1/av1_svc_config.cc
index 30c0f30..325bc4e 100644
--- a/src/modules/video_coding/codecs/av1/av1_svc_config.cc
+++ b/src/modules/video_coding/codecs/av1/av1_svc_config.cc
@@ -20,6 +20,7 @@
 #include "rtc_base/checks.h"
 #include "rtc_base/logging.h"
 #include "rtc_base/strings/string_builder.h"
+#include <android/log.h>
 
 namespace webrtc {
 namespace {
@@ -58,6 +59,9 @@ LibaomAv1EncoderSupportedScalabilityModes() {
   for (ScalabilityMode scalability_mode : kAllScalabilityModes) {
     if (ScalabilityStructureConfig(scalability_mode) != absl::nullopt) {
       scalability_modes.push_back(scalability_mode);
+              auto sv2 = ScalabilityModeToString(scalability_mode);
+        std::string s2 = {sv2.begin(), sv2.end()};
+        __android_log_print(ANDROID_LOG_ERROR, "LibaomAv1EncoderSupportedScalabilityModes", "%s", s2.c_str());
     }
   }
   return scalability_modes;
diff --git a/src/modules/video_coding/codecs/h264/h264.cc b/src/modules/video_coding/codecs/h264/h264.cc
index 5b9f033..177b8e3 100644
--- a/src/modules/video_coding/codecs/h264/h264.cc
+++ b/src/modules/video_coding/codecs/h264/h264.cc
@@ -19,6 +19,7 @@
 #include "api/video_codecs/sdp_video_format.h"
 #include "media/base/media_constants.h"
 #include "rtc_base/trace_event.h"
+#include <android/log.h>
 
 #if defined(WEBRTC_USE_H264)
 #include "modules/video_coding/codecs/h264/h264_decoder_impl.h"
@@ -61,6 +62,9 @@ SdpVideoFormat CreateH264Format(H264Profile profile,
   if (add_scalability_modes) {
     for (const auto scalability_mode : kSupportedScalabilityModes) {
       scalability_modes.push_back(scalability_mode);
+              auto sv2 = ScalabilityModeToString(scalability_mode);
+        std::string s2 = {sv2.begin(), sv2.end()};
+        __android_log_print(ANDROID_LOG_ERROR, "H264ProfileLevelIdToString", "%s", s2.c_str());
     }
   }
   return SdpVideoFormat(
diff --git a/src/modules/video_coding/codecs/vp9/vp9.cc b/src/modules/video_coding/codecs/vp9/vp9.cc
index c1dbf3a..2a810be 100644
--- a/src/modules/video_coding/codecs/vp9/vp9.cc
+++ b/src/modules/video_coding/codecs/vp9/vp9.cc
@@ -25,6 +25,7 @@
 #include "vpx/vp8cx.h"
 #include "vpx/vp8dx.h"
 #include "vpx/vpx_codec.h"
+#include <android/log.h>
 
 namespace webrtc {
 
@@ -43,6 +44,9 @@ std::vector<SdpVideoFormat> SupportedVP9Codecs(bool add_scalability_modes) {
     for (const auto scalability_mode : kAllScalabilityModes) {
       if (ScalabilityStructureConfig(scalability_mode).has_value()) {
         scalability_modes.push_back(scalability_mode);
+                auto sv2 = ScalabilityModeToString(scalability_mode);
+        std::string s2 = {sv2.begin(), sv2.end()};
+        __android_log_print(ANDROID_LOG_ERROR, "SupportedVP9Codecs", "%s", s2.c_str());
       }
     }
   }
diff --git a/src/pc/rtp_sender.cc b/src/pc/rtp_sender.cc
index cdae159..f7827da 100644
--- a/src/pc/rtp_sender.cc
+++ b/src/pc/rtp_sender.cc
@@ -237,6 +237,7 @@ void RtpSenderBase::SetParametersInternal(const RtpParameters& parameters,
   RTC_DCHECK_RUN_ON(signaling_thread_);
   RTC_DCHECK(!stopped_);
 
+  // nope2
   if (UnimplementedRtpParameterHasValue(parameters)) {
     RTCError error(
         RTCErrorType::UNSUPPORTED_PARAMETER,
@@ -247,6 +248,7 @@ void RtpSenderBase::SetParametersInternal(const RtpParameters& parameters,
     return;
   }
   if (!media_channel_ || !ssrc_) {
+    // nope3
     auto result = cricket::CheckRtpParametersInvalidModificationAndValues(
         init_parameters_, parameters, codec_preferences_, absl::nullopt);
     if (result.ok()) {
@@ -265,6 +267,7 @@ void RtpSenderBase::SetParametersInternal(const RtpParameters& parameters,
                                              old_parameters.encodings);
     }
 
+    // nope4
     RTCError result = cricket::CheckRtpParametersInvalidModificationAndValues(
         old_parameters, rtp_parameters);
     if (!result.ok()) {
@@ -272,6 +275,8 @@ void RtpSenderBase::SetParametersInternal(const RtpParameters& parameters,
       return;
     }
 
+    // nope ?
+
     result = CheckCodecParameters(rtp_parameters);
     if (!result.ok()) {
       webrtc::InvokeSetParametersCallback(callback, result);
@@ -353,7 +358,8 @@ RTCError RtpSenderBase::CheckCodecParameters(const RtpParameters& parameters) {
       send_codec_with_svc_info = *codec_match;
     }
   }
-
+  
+  // here
   return cricket::CheckScalabilityModeValues(parameters, codec_preferences_,
                                              send_codec_with_svc_info);
 }
@@ -364,6 +370,7 @@ RTCError RtpSenderBase::SetParameters(const RtpParameters& parameters) {
   RTCError result = CheckSetParameters(parameters);
   if (!result.ok())
     return result;
+  // nope
 
   // Some tests rely on working in single thread mode without a run loop and a
   // blocking call is required to keep them working. The encoder configuration
diff --git a/src/pc/rtp_sender.h b/src/pc/rtp_sender.h
index d29c376..1a7c34c 100644
--- a/src/pc/rtp_sender.h
+++ b/src/pc/rtp_sender.h
@@ -21,6 +21,7 @@
 #include <memory>
 #include <string>
 #include <vector>
+#include <android/log.h>
 
 #include "absl/types/optional.h"
 #include "api/crypto/frame_encryptor_interface.h"
@@ -225,6 +226,22 @@ class RtpSenderBase : public RtpSenderInternal, public ObserverInterface {
 
   void SetCodecPreferences(
       std::vector<cricket::Codec> codec_preferences) override {
+    __android_log_print(ANDROID_LOG_ERROR, "SetCodecPreferences", "%lu",
+                        (unsigned long)codec_preferences.size());
+    for (size_t i = 0; i < codec_preferences.size(); ++i) {
+      __android_log_print(
+          ANDROID_LOG_ERROR, "SetCodecPreferences scalability_modes", "%lu",
+          (unsigned long)codec_preferences[i].scalability_modes.size());
+
+      for (size_t j = 0; j < codec_preferences[i].scalability_modes.size(); ++j) {
+        auto sv =
+            ScalabilityModeToString(codec_preferences[i].scalability_modes[j]);
+        std::string s = {sv.begin(), sv.end()};
+
+        __android_log_print(ANDROID_LOG_ERROR, "SetCodecPreferences MOD", "%s",
+                            s.c_str());
+      }
+    }
     codec_preferences_ = codec_preferences;
   }
 
diff --git a/src/pc/rtp_transceiver.cc b/src/pc/rtp_transceiver.cc
index 815ec9d..381ba9f 100644
--- a/src/pc/rtp_transceiver.cc
+++ b/src/pc/rtp_transceiver.cc
@@ -17,6 +17,7 @@
 #include <string>
 #include <utility>
 #include <vector>
+#include <android/log.h>
 
 #include "absl/algorithm/container.h"
 #include "absl/memory/memory.h"
@@ -171,6 +172,28 @@ RtpTransceiver::RtpTransceiver(
   RTC_DCHECK(media_type_ == cricket::MEDIA_TYPE_AUDIO ||
              media_type_ == cricket::MEDIA_TYPE_VIDEO);
   RTC_DCHECK_EQ(sender->media_type(), receiver->media_type());
+
+{
+  auto aa = media_engine()->video().send_codecs(false);
+
+      __android_log_print(ANDROID_LOG_ERROR, "RtpTransceiver", "%lu",
+                        (unsigned long)aa.size());
+    for (int i = 0; i < aa.size(); ++i) {
+      __android_log_print(
+          ANDROID_LOG_ERROR, "RtpTransceiver scalability_modes", "%lu",
+          (unsigned long)aa[i].scalability_modes.size());
+
+      for (int j = 0; j < aa[i].scalability_modes.size(); ++j) {
+        auto sv =
+            ScalabilityModeToString(aa[i].scalability_modes[j]);
+        std::string s = {sv.begin(), sv.end()};
+
+        __android_log_print(ANDROID_LOG_ERROR, "RtpTransceiver MOD", "%s",
+                            s.c_str());
+      }
+    }
+}
+
   sender->internal()->SetCodecPreferences(
       sender->media_type() == cricket::MEDIA_TYPE_VIDEO
           ? media_engine()->video().send_codecs(false)
diff --git a/src/scala b/src/scala
new file mode 100644
index 0000000..00eae6c
--- /dev/null
+++ b/src/scala
@@ -0,0 +1,1487 @@
+diff --git a/src/api/video_codecs/video_encoder_factory_template_libvpx_vp8_adapter.h b/src/api/video_codecs/video_encoder_factory_template_libvpx_vp8_adapter.h
+index 0f0a9ba..a2d608b 100644
+--- a/src/api/video_codecs/video_encoder_factory_template_libvpx_vp8_adapter.h
++++ b/src/api/video_codecs/video_encoder_factory_template_libvpx_vp8_adapter.h
+@@ -18,6 +18,7 @@
+ #include "api/video_codecs/sdp_video_format.h"
+ #include "modules/video_coding/codecs/vp8/include/vp8.h"
+ #include "modules/video_coding/codecs/vp8/vp8_scalability.h"
++#include <android/log.h>
+ 
+ namespace webrtc {
+ struct LibvpxVp8EncoderTemplateAdapter {
+@@ -26,6 +27,9 @@ struct LibvpxVp8EncoderTemplateAdapter {
+         scalability_modes;
+     for (const auto scalability_mode : kVP8SupportedScalabilityModes) {
+       scalability_modes.push_back(scalability_mode);
++        auto sv2 = ScalabilityModeToString(scalability_mode);
++        std::string s2 = {sv2.begin(), sv2.end()};
++        __android_log_print(ANDROID_LOG_ERROR, "LibvpxVp8EncoderTemplateAdapter", "%s", s2.c_str());
+     }
+ 
+     return {
+diff --git a/src/media/base/media_engine.cc b/src/media/base/media_engine.cc
+index 7304ab0..e69e712 100644
+--- a/src/media/base/media_engine.cc
++++ b/src/media/base/media_engine.cc
+@@ -15,6 +15,9 @@
+ #include <cstdint>
+ #include <string>
+ #include <utility>
++#include <sstream>
++#include <iostream>
++#include <android/log.h>
+ 
+ #include "absl/algorithm/container.h"
+ #include "api/video/video_bitrate_allocation.h"
+@@ -95,10 +98,22 @@ webrtc::RTCError CheckScalabilityModeValues(
+       }
+     }
+     if (rtp_parameters.encodings[i].scalability_mode) {
++        std::stringstream ss;
+       if (!send_codec) {
+-        bool scalabilityModeFound = false;
+-        for (const cricket::VideoCodec& codec : codec_preferences) {
+-          for (const auto& scalability_mode : codec.scalability_modes) {
++         bool scalabilityModeFound = false;
++        __android_log_print(ANDROID_LOG_ERROR, "codec_preferences", "%lu", (unsigned long) codec_preferences.size());
++         for (const cricket::VideoCodec& codec : codec_preferences) {
++        __android_log_print(ANDROID_LOG_ERROR, "codec", "|%s|", codec.name.c_str());
++        __android_log_print(ANDROID_LOG_ERROR, "codec_preferences.scalability_modes", "%lu", (unsigned long) codec.scalability_modes.size());
++           for (const auto& scalability_mode : codec.scalability_modes) {
++        auto sv = *rtp_parameters.encodings[i].scalability_mode; auto sv2 = ScalabilityModeToString(scalability_mode);
++        std::string s = {sv.begin(), sv.end()}; std::string s2 = {sv2.begin(), sv2.end()};
++        __android_log_print(ANDROID_LOG_ERROR, "scalability_mode", "|%s|", s2.c_str());
++        __android_log_print(ANDROID_LOG_ERROR, "scalability_mode2", "|%s|", s.c_str());
++
++
++          ss << "\nscalability_mode" << ScalabilityModeToString(scalability_mode) << "-" << *rtp_parameters.encodings[i].scalability_mode;
++
+             if (ScalabilityModeToString(scalability_mode) ==
+                 *rtp_parameters.encodings[i].scalability_mode) {
+               scalabilityModeFound = true;
+@@ -110,14 +125,24 @@ webrtc::RTCError CheckScalabilityModeValues(
+         }
+ 
+         if (!scalabilityModeFound) {
++        __android_log_print(ANDROID_LOG_ERROR, "AAAAA42", "%s", ss.str().c_str());
++          std::cout << ss.str() << std::endl;
+           LOG_AND_RETURN_ERROR(
+               RTCErrorType::INVALID_MODIFICATION,
+               "Attempted to set RtpParameters scalabilityMode "
+               "to an unsupported value for the current codecs.");
+         }
+       } else {
++          ss << "\nsend_codec";
++
+         bool scalabilityModeFound = false;
+         for (const auto& scalability_mode : send_codec->scalability_modes) {
++          ss << "\nscalability_mode" << ScalabilityModeToString(scalability_mode) << "-" << *rtp_parameters.encodings[i].scalability_mode;
++        auto sv = *rtp_parameters.encodings[i].scalability_mode; auto sv2 = ScalabilityModeToString(scalability_mode);
++        std::string s = {sv.begin(), sv.end()}; std::string s2 = {sv2.begin(), sv2.end()};
++        __android_log_print(ANDROID_LOG_ERROR, "scalability_mode", "|%s|", s2.c_str());
++        __android_log_print(ANDROID_LOG_ERROR, "scalability_mode2", "|%s|", s.c_str());
++
+           if (ScalabilityModeToString(scalability_mode) ==
+               *rtp_parameters.encodings[i].scalability_mode) {
+             scalabilityModeFound = true;
+@@ -125,6 +150,8 @@ webrtc::RTCError CheckScalabilityModeValues(
+           }
+         }
+         if (!scalabilityModeFound) {
++        __android_log_print(ANDROID_LOG_ERROR, "AAAAA422", "%s", ss.str().c_str());
++          std::cout << ss.str() << std::endl;
+           LOG_AND_RETURN_ERROR(
+               RTCErrorType::INVALID_MODIFICATION,
+               "Attempted to set RtpParameters scalabilityMode "
+diff --git a/src/media/engine/webrtc_video_engine.cc b/src/media/engine/webrtc_video_engine.cc
+index 91750b8..c63ced1 100644
+--- a/src/media/engine/webrtc_video_engine.cc
++++ b/src/media/engine/webrtc_video_engine.cc
+@@ -19,6 +19,7 @@
+ #include <string>
+ #include <type_traits>
+ #include <utility>
++#include <android/log.h>
+ 
+ #include "absl/algorithm/container.h"
+ #include "absl/container/inlined_vector.h"
+@@ -179,7 +180,10 @@ std::vector<VideoCodec> GetPayloadTypesAndDefaultCodecs(
+     bool is_decoder_factory,
+     bool include_rtx,
+     const webrtc::FieldTrialsView& trials) {
++
++  __android_log_print(ANDROID_LOG_ERROR, "GetPayloadTypesAndDefaultCodecs", "%s", "GetPayloadTypesAndDefaultCodecs");
+   if (!factory) {
++  __android_log_print(ANDROID_LOG_ERROR, "GetPayloadTypesAndDefaultCodecs", "%s", "NOPE");
+     return {};
+   }
+ 
+@@ -219,6 +223,8 @@ std::vector<VideoCodec> GetPayloadTypesAndDefaultCodecs(
+ 
+   std::vector<VideoCodec> output_codecs;
+   for (const webrtc::SdpVideoFormat& format : supported_formats) {
++  __android_log_print(ANDROID_LOG_ERROR, "GetPayloadTypesAndDefaultCodecs", "%s %lu", format.name.c_str(), (unsigned long) format.scalability_modes.size());
++
+     VideoCodec codec = cricket::CreateVideoCodec(format);
+     bool isFecCodec = absl::EqualsIgnoreCase(codec.name, kUlpfecCodecName) ||
+                       absl::EqualsIgnoreCase(codec.name, kFlexfecCodecName);
+diff --git a/src/modules/video_coding/codecs/av1/av1_svc_config.cc b/src/modules/video_coding/codecs/av1/av1_svc_config.cc
+index 30c0f30..325bc4e 100644
+--- a/src/modules/video_coding/codecs/av1/av1_svc_config.cc
++++ b/src/modules/video_coding/codecs/av1/av1_svc_config.cc
+@@ -20,6 +20,7 @@
+ #include "rtc_base/checks.h"
+ #include "rtc_base/logging.h"
+ #include "rtc_base/strings/string_builder.h"
++#include <android/log.h>
+ 
+ namespace webrtc {
+ namespace {
+@@ -58,6 +59,9 @@ LibaomAv1EncoderSupportedScalabilityModes() {
+   for (ScalabilityMode scalability_mode : kAllScalabilityModes) {
+     if (ScalabilityStructureConfig(scalability_mode) != absl::nullopt) {
+       scalability_modes.push_back(scalability_mode);
++              auto sv2 = ScalabilityModeToString(scalability_mode);
++        std::string s2 = {sv2.begin(), sv2.end()};
++        __android_log_print(ANDROID_LOG_ERROR, "LibaomAv1EncoderSupportedScalabilityModes", "%s", s2.c_str());
+     }
+   }
+   return scalability_modes;
+diff --git a/src/modules/video_coding/codecs/h264/h264.cc b/src/modules/video_coding/codecs/h264/h264.cc
+index 5b9f033..177b8e3 100644
+--- a/src/modules/video_coding/codecs/h264/h264.cc
++++ b/src/modules/video_coding/codecs/h264/h264.cc
+@@ -19,6 +19,7 @@
+ #include "api/video_codecs/sdp_video_format.h"
+ #include "media/base/media_constants.h"
+ #include "rtc_base/trace_event.h"
++#include <android/log.h>
+ 
+ #if defined(WEBRTC_USE_H264)
+ #include "modules/video_coding/codecs/h264/h264_decoder_impl.h"
+@@ -61,6 +62,9 @@ SdpVideoFormat CreateH264Format(H264Profile profile,
+   if (add_scalability_modes) {
+     for (const auto scalability_mode : kSupportedScalabilityModes) {
+       scalability_modes.push_back(scalability_mode);
++              auto sv2 = ScalabilityModeToString(scalability_mode);
++        std::string s2 = {sv2.begin(), sv2.end()};
++        __android_log_print(ANDROID_LOG_ERROR, "H264ProfileLevelIdToString", "%s", s2.c_str());
+     }
+   }
+   return SdpVideoFormat(
+diff --git a/src/modules/video_coding/codecs/vp9/vp9.cc b/src/modules/video_coding/codecs/vp9/vp9.cc
+index c1dbf3a..2a810be 100644
+--- a/src/modules/video_coding/codecs/vp9/vp9.cc
++++ b/src/modules/video_coding/codecs/vp9/vp9.cc
+@@ -25,6 +25,7 @@
+ #include "vpx/vp8cx.h"
+ #include "vpx/vp8dx.h"
+ #include "vpx/vpx_codec.h"
++#include <android/log.h>
+ 
+ namespace webrtc {
+ 
+@@ -43,6 +44,9 @@ std::vector<SdpVideoFormat> SupportedVP9Codecs(bool add_scalability_modes) {
+     for (const auto scalability_mode : kAllScalabilityModes) {
+       if (ScalabilityStructureConfig(scalability_mode).has_value()) {
+         scalability_modes.push_back(scalability_mode);
++                auto sv2 = ScalabilityModeToString(scalability_mode);
++        std::string s2 = {sv2.begin(), sv2.end()};
++        __android_log_print(ANDROID_LOG_ERROR, "SupportedVP9Codecs", "%s", s2.c_str());
+       }
+     }
+   }
+diff --git a/src/pc/rtp_sender.cc b/src/pc/rtp_sender.cc
+index cdae159..f7827da 100644
+--- a/src/pc/rtp_sender.cc
++++ b/src/pc/rtp_sender.cc
+@@ -237,6 +237,7 @@ void RtpSenderBase::SetParametersInternal(const RtpParameters& parameters,
+   RTC_DCHECK_RUN_ON(signaling_thread_);
+   RTC_DCHECK(!stopped_);
+ 
++  // nope2
+   if (UnimplementedRtpParameterHasValue(parameters)) {
+     RTCError error(
+         RTCErrorType::UNSUPPORTED_PARAMETER,
+@@ -247,6 +248,7 @@ void RtpSenderBase::SetParametersInternal(const RtpParameters& parameters,
+     return;
+   }
+   if (!media_channel_ || !ssrc_) {
++    // nope3
+     auto result = cricket::CheckRtpParametersInvalidModificationAndValues(
+         init_parameters_, parameters, codec_preferences_, absl::nullopt);
+     if (result.ok()) {
+@@ -265,6 +267,7 @@ void RtpSenderBase::SetParametersInternal(const RtpParameters& parameters,
+                                              old_parameters.encodings);
+     }
+ 
++    // nope4
+     RTCError result = cricket::CheckRtpParametersInvalidModificationAndValues(
+         old_parameters, rtp_parameters);
+     if (!result.ok()) {
+@@ -272,6 +275,8 @@ void RtpSenderBase::SetParametersInternal(const RtpParameters& parameters,
+       return;
+     }
+ 
++    // nope ?
++
+     result = CheckCodecParameters(rtp_parameters);
+     if (!result.ok()) {
+       webrtc::InvokeSetParametersCallback(callback, result);
+@@ -353,7 +358,8 @@ RTCError RtpSenderBase::CheckCodecParameters(const RtpParameters& parameters) {
+       send_codec_with_svc_info = *codec_match;
+     }
+   }
+-
++  
++  // here
+   return cricket::CheckScalabilityModeValues(parameters, codec_preferences_,
+                                              send_codec_with_svc_info);
+ }
+@@ -364,6 +370,7 @@ RTCError RtpSenderBase::SetParameters(const RtpParameters& parameters) {
+   RTCError result = CheckSetParameters(parameters);
+   if (!result.ok())
+     return result;
++  // nope
+ 
+   // Some tests rely on working in single thread mode without a run loop and a
+   // blocking call is required to keep them working. The encoder configuration
+diff --git a/src/pc/rtp_sender.h b/src/pc/rtp_sender.h
+index d29c376..1a7c34c 100644
+--- a/src/pc/rtp_sender.h
++++ b/src/pc/rtp_sender.h
+@@ -21,6 +21,7 @@
+ #include <memory>
+ #include <string>
+ #include <vector>
++#include <android/log.h>
+ 
+ #include "absl/types/optional.h"
+ #include "api/crypto/frame_encryptor_interface.h"
+@@ -225,6 +226,22 @@ class RtpSenderBase : public RtpSenderInternal, public ObserverInterface {
+ 
+   void SetCodecPreferences(
+       std::vector<cricket::Codec> codec_preferences) override {
++    __android_log_print(ANDROID_LOG_ERROR, "SetCodecPreferences", "%lu",
++                        (unsigned long)codec_preferences.size());
++    for (size_t i = 0; i < codec_preferences.size(); ++i) {
++      __android_log_print(
++          ANDROID_LOG_ERROR, "SetCodecPreferences scalability_modes", "%lu",
++          (unsigned long)codec_preferences[i].scalability_modes.size());
++
++      for (size_t j = 0; j < codec_preferences[i].scalability_modes.size(); ++j) {
++        auto sv =
++            ScalabilityModeToString(codec_preferences[i].scalability_modes[j]);
++        std::string s = {sv.begin(), sv.end()};
++
++        __android_log_print(ANDROID_LOG_ERROR, "SetCodecPreferences MOD", "%s",
++                            s.c_str());
++      }
++    }
+     codec_preferences_ = codec_preferences;
+   }
+ 
+diff --git a/src/pc/rtp_transceiver.cc b/src/pc/rtp_transceiver.cc
+index 815ec9d..381ba9f 100644
+--- a/src/pc/rtp_transceiver.cc
++++ b/src/pc/rtp_transceiver.cc
+@@ -17,6 +17,7 @@
+ #include <string>
+ #include <utility>
+ #include <vector>
++#include <android/log.h>
+ 
+ #include "absl/algorithm/container.h"
+ #include "absl/memory/memory.h"
+@@ -171,6 +172,28 @@ RtpTransceiver::RtpTransceiver(
+   RTC_DCHECK(media_type_ == cricket::MEDIA_TYPE_AUDIO ||
+              media_type_ == cricket::MEDIA_TYPE_VIDEO);
+   RTC_DCHECK_EQ(sender->media_type(), receiver->media_type());
++
++{
++  auto aa = media_engine()->video().send_codecs(false);
++
++      __android_log_print(ANDROID_LOG_ERROR, "RtpTransceiver", "%lu",
++                        (unsigned long)aa.size());
++    for (int i = 0; i < aa.size(); ++i) {
++      __android_log_print(
++          ANDROID_LOG_ERROR, "RtpTransceiver scalability_modes", "%lu",
++          (unsigned long)aa[i].scalability_modes.size());
++
++      for (int j = 0; j < aa[i].scalability_modes.size(); ++j) {
++        auto sv =
++            ScalabilityModeToString(aa[i].scalability_modes[j]);
++        std::string s = {sv.begin(), sv.end()};
++
++        __android_log_print(ANDROID_LOG_ERROR, "RtpTransceiver MOD", "%s",
++                            s.c_str());
++      }
++    }
++}
++
+   sender->internal()->SetCodecPreferences(
+       sender->media_type() == cricket::MEDIA_TYPE_VIDEO
+           ? media_engine()->video().send_codecs(false)
+diff --git a/src/sdk/BUILD.gn b/src/sdk/BUILD.gn
+index 4f5ceb5..a743579 100644
+--- a/src/sdk/BUILD.gn
++++ b/src/sdk/BUILD.gn
+@@ -991,6 +991,15 @@ if (is_ios || is_mac) {
+         "objc/api/peerconnection/RTCRtcpParameters+Private.h",
+         "objc/api/peerconnection/RTCRtcpParameters.h",
+         "objc/api/peerconnection/RTCRtcpParameters.mm",
++        "objc/api/peerconnection/RTCRtpCapabilities.h",
++        "objc/api/peerconnection/RTCRtpCapabilities.mm",
++        "objc/api/peerconnection/RTCRtpCapabilities+Private.h",
++        "objc/api/peerconnection/RTCRtpCodecCapability.h",
++        "objc/api/peerconnection/RTCRtpCodecCapability.mm",
++        "objc/api/peerconnection/RTCRtpCodecCapability+Private.h",
++        "objc/api/peerconnection/RTCRtpHeaderExtensionCapability.h",
++        "objc/api/peerconnection/RTCRtpHeaderExtensionCapability.mm",
++        "objc/api/peerconnection/RTCRtpHeaderExtensionCapability+Private.h",
+         "objc/api/peerconnection/RTCRtpCodecParameters+Private.h",
+         "objc/api/peerconnection/RTCRtpCodecParameters.h",
+         "objc/api/peerconnection/RTCRtpCodecParameters.mm",
+@@ -1309,6 +1318,9 @@ if (is_ios || is_mac) {
+           "objc/api/peerconnection/RTCPeerConnectionFactory.h",
+           "objc/api/peerconnection/RTCPeerConnectionFactoryOptions.h",
+           "objc/api/peerconnection/RTCRtcpParameters.h",
++          "objc/api/peerconnection/RTCRtpCapabilities.h",
++          "objc/api/peerconnection/RTCRtpCodecCapability.h",
++          "objc/api/peerconnection/RTCRtpHeaderExtensionCapability.h",
+           "objc/api/peerconnection/RTCRtpCodecParameters.h",
+           "objc/api/peerconnection/RTCRtpEncodingParameters.h",
+           "objc/api/peerconnection/RTCRtpHeaderExtension.h",
+@@ -1423,6 +1435,9 @@ if (is_ios || is_mac) {
+           "objc/api/peerconnection/RTCPeerConnectionFactory.h",
+           "objc/api/peerconnection/RTCPeerConnectionFactoryOptions.h",
+           "objc/api/peerconnection/RTCRtcpParameters.h",
++          "objc/api/peerconnection/RTCRtpCapabilities.h",
++          "objc/api/peerconnection/RTCRtpCodecCapability.h",
++          "objc/api/peerconnection/RTCRtpHeaderExtensionCapability.h",
+           "objc/api/peerconnection/RTCRtpCodecParameters.h",
+           "objc/api/peerconnection/RTCRtpEncodingParameters.h",
+           "objc/api/peerconnection/RTCRtpHeaderExtension.h",
+diff --git a/src/sdk/android/api/org/webrtc/RtpParameters.java b/src/sdk/android/api/org/webrtc/RtpParameters.java
+index 9ca8311..1fcffe7 100644
+--- a/src/sdk/android/api/org/webrtc/RtpParameters.java
++++ b/src/sdk/android/api/org/webrtc/RtpParameters.java
+@@ -73,6 +73,8 @@ public class RtpParameters {
+     @Nullable public Integer maxFramerate;
+     // The number of temporal layers for video.
+     @Nullable public Integer numTemporalLayers;
++    // https://w3c.github.io/webrtc-svc/#rtcrtpencodingparameters
++    @Nullable public String scalabilityMode;
+     // If non-null, scale the width and height down by this factor for video. If null,
+     // implementation default scaling factor will be used.
+     @Nullable public Double scaleResolutionDownBy;
+@@ -93,7 +95,7 @@ public class RtpParameters {
+     @CalledByNative("Encoding")
+     Encoding(String rid, boolean active, double bitratePriority, @Priority int networkPriority,
+         Integer maxBitrateBps, Integer minBitrateBps, Integer maxFramerate,
+-        Integer numTemporalLayers, Double scaleResolutionDownBy, Long ssrc,
++        Integer numTemporalLayers, String scalabilityMode, Double scaleResolutionDownBy, Long ssrc,
+         boolean adaptiveAudioPacketTime) {
+       this.rid = rid;
+       this.active = active;
+@@ -103,6 +105,7 @@ public class RtpParameters {
+       this.minBitrateBps = minBitrateBps;
+       this.maxFramerate = maxFramerate;
+       this.numTemporalLayers = numTemporalLayers;
++      this.scalabilityMode = scalabilityMode;
+       this.scaleResolutionDownBy = scaleResolutionDownBy;
+       this.ssrc = ssrc;
+       this.adaptiveAudioPacketTime = adaptiveAudioPacketTime;
+@@ -154,6 +157,12 @@ public class RtpParameters {
+       return numTemporalLayers;
+     }
+ 
++    @Nullable
++    @CalledByNative("Encoding")
++    String getScalabilityMode() {
++      return scalabilityMode;
++    }
++
+     @Nullable
+     @CalledByNative("Encoding")
+     Double getScaleResolutionDownBy() {
+diff --git a/src/sdk/android/src/jni/pc/rtp_parameters.cc b/src/sdk/android/src/jni/pc/rtp_parameters.cc
+index 4bd9ee0..1f5957b 100644
+--- a/src/sdk/android/src/jni/pc/rtp_parameters.cc
++++ b/src/sdk/android/src/jni/pc/rtp_parameters.cc
+@@ -52,6 +52,7 @@ ScopedJavaLocalRef<jobject> NativeToJavaRtpEncodingParameter(
+       NativeToJavaInteger(env, encoding.min_bitrate_bps),
+       NativeToJavaInteger(env, encoding.max_framerate),
+       NativeToJavaInteger(env, encoding.num_temporal_layers),
++      NativeToJavaString(env, encoding.scalability_mode),
+       NativeToJavaDouble(env, encoding.scale_resolution_down_by),
+       encoding.ssrc ? NativeToJavaLong(env, *encoding.ssrc) : nullptr,
+       encoding.adaptive_ptime);
+@@ -112,6 +113,11 @@ RtpEncodingParameters JavaToNativeRtpEncodingParameters(
+       Java_Encoding_getNumTemporalLayers(jni, j_encoding_parameters);
+   encoding.num_temporal_layers =
+       JavaToNativeOptionalInt(jni, j_num_temporal_layers);
++  ScopedJavaLocalRef<jstring> j_scalability_mode =
++      Java_Encoding_getScalabilityMode(jni, j_encoding_parameters);
++  if (!IsNull(jni, j_scalability_mode)) {
++    encoding.scalability_mode = JavaToNativeString(jni, j_scalability_mode);
++  }
+   ScopedJavaLocalRef<jobject> j_scale_resolution_down_by =
+       Java_Encoding_getScaleResolutionDownBy(jni, j_encoding_parameters);
+   encoding.scale_resolution_down_by =
+diff --git a/src/sdk/android/src/jni/pc/rtp_sender.cc b/src/sdk/android/src/jni/pc/rtp_sender.cc
+index ddb53f6..533d0e9 100644
+--- a/src/sdk/android/src/jni/pc/rtp_sender.cc
++++ b/src/sdk/android/src/jni/pc/rtp_sender.cc
+@@ -70,7 +70,7 @@ jlong JNI_RtpSender_GetDtmfSender(JNIEnv* jni, jlong j_rtp_sender_pointer) {
+           ->GetDtmfSender()
+           .release());
+ }
+-
++ // here
+ jboolean JNI_RtpSender_SetParameters(
+     JNIEnv* jni,
+     jlong j_rtp_sender_pointer,
+diff --git a/src/sdk/objc/api/peerconnection/RTCPeerConnectionFactory.h b/src/sdk/objc/api/peerconnection/RTCPeerConnectionFactory.h
+index 5575af9..f8dfae1 100644
+--- a/src/sdk/objc/api/peerconnection/RTCPeerConnectionFactory.h
++++ b/src/sdk/objc/api/peerconnection/RTCPeerConnectionFactory.h
+@@ -23,6 +23,10 @@ NS_ASSUME_NONNULL_BEGIN
+ @class RTC_OBJC_TYPE(RTCVideoSource);
+ @class RTC_OBJC_TYPE(RTCVideoTrack);
+ @class RTC_OBJC_TYPE(RTCPeerConnectionFactoryOptions);
++@class RTC_OBJC_TYPE(RTCRtpCapabilities);
++
++typedef NS_ENUM(NSInteger, RTCRtpMediaType);
++
+ @protocol RTC_OBJC_TYPE
+ (RTCPeerConnectionDelegate);
+ @protocol RTC_OBJC_TYPE
+@@ -51,6 +55,10 @@ RTC_OBJC_EXPORT
+             decoderFactory:(nullable id<RTC_OBJC_TYPE(RTCVideoDecoderFactory)>)decoderFactory
+                audioDevice:(nullable id<RTC_OBJC_TYPE(RTCAudioDevice)>)audioDevice;
+ 
++- (RTC_OBJC_TYPE(RTCRtpCapabilities) *)rtpSenderCapabilitiesFor:(RTCRtpMediaType)mediaType;
++
++- (RTC_OBJC_TYPE(RTCRtpCapabilities) *)rtpReceiverCapabilitiesFor:(RTCRtpMediaType)mediaType;
++
+ /** Initialize an RTCAudioSource with constraints. */
+ - (RTC_OBJC_TYPE(RTCAudioSource) *)audioSourceWithConstraints:
+     (nullable RTC_OBJC_TYPE(RTCMediaConstraints) *)constraints;
+diff --git a/src/sdk/objc/api/peerconnection/RTCPeerConnectionFactory.mm b/src/sdk/objc/api/peerconnection/RTCPeerConnectionFactory.mm
+index 62b5554..e63104d 100644
+--- a/src/sdk/objc/api/peerconnection/RTCPeerConnectionFactory.mm
++++ b/src/sdk/objc/api/peerconnection/RTCPeerConnectionFactory.mm
+@@ -21,6 +21,9 @@
+ #import "RTCPeerConnection+Private.h"
+ #import "RTCVideoSource+Private.h"
+ #import "RTCVideoTrack+Private.h"
++#import "RTCRtpReceiver+Private.h"
++#import "RTCRtpCapabilities+Private.h"
++#import "RTCRtpCodecCapability+Private.h"
+ #import "base/RTCLogging.h"
+ #import "base/RTCVideoDecoderFactory.h"
+ #import "base/RTCVideoEncoderFactory.h"
+@@ -116,6 +119,20 @@
+ #endif
+ }
+ 
++- (RTC_OBJC_TYPE(RTCRtpCapabilities) *)rtpSenderCapabilitiesFor:(RTCRtpMediaType)mediaType {
++
++  webrtc::RtpCapabilities capabilities = _nativeFactory->GetRtpSenderCapabilities([RTCRtpReceiver nativeMediaTypeForMediaType: mediaType]);
++
++  return [[RTCRtpCapabilities alloc] initWithNativeCapabilities: capabilities];
++}
++
++- (RTC_OBJC_TYPE(RTCRtpCapabilities) *)rtpReceiverCapabilitiesFor:(RTCRtpMediaType)mediaType {
++
++  webrtc::RtpCapabilities capabilities = _nativeFactory->GetRtpReceiverCapabilities([RTCRtpReceiver nativeMediaTypeForMediaType: mediaType]);
++
++  return [[RTCRtpCapabilities alloc] initWithNativeCapabilities: capabilities];
++}
++
+ - (instancetype)initNative {
+   if (self = [super init]) {
+     _networkThread = rtc::Thread::CreateWithSocketServer();
+diff --git a/src/sdk/objc/api/peerconnection/RTCRtpCapabilities+Private.h b/src/sdk/objc/api/peerconnection/RTCRtpCapabilities+Private.h
+new file mode 100644
+index 0000000..15c8fe3
+--- /dev/null
++++ b/src/sdk/objc/api/peerconnection/RTCRtpCapabilities+Private.h
+@@ -0,0 +1,33 @@
++/*
++ * Copyright 2023 LiveKit
++ *
++ * Licensed under the Apache License, Version 2.0 (the "License");
++ * you may not use this file except in compliance with the License.
++ * You may obtain a copy of the License at
++ *
++ *     http://www.apache.org/licenses/LICENSE-2.0
++ *
++ * Unless required by applicable law or agreed to in writing, software
++ * distributed under the License is distributed on an "AS IS" BASIS,
++ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++ * See the License for the specific language governing permissions and
++ * limitations under the License.
++ */
++
++#import "RTCRtpCapabilities.h"
++
++#include "api/rtp_parameters.h"
++
++NS_ASSUME_NONNULL_BEGIN
++
++@interface RTC_OBJC_TYPE (RTCRtpCapabilities)
++()
++
++    @property(nonatomic, readonly) webrtc::RtpCapabilities nativeCapabilities;
++
++- (instancetype)initWithNativeCapabilities:(const webrtc::RtpCapabilities &)nativeCapabilities
++    NS_DESIGNATED_INITIALIZER;
++
++@end
++
++NS_ASSUME_NONNULL_END
+\ No newline at end of file
+diff --git a/src/sdk/objc/api/peerconnection/RTCRtpCapabilities.h b/src/sdk/objc/api/peerconnection/RTCRtpCapabilities.h
+new file mode 100644
+index 0000000..2dea41a
+--- /dev/null
++++ b/src/sdk/objc/api/peerconnection/RTCRtpCapabilities.h
+@@ -0,0 +1,37 @@
++/*
++ * Copyright 2023 LiveKit
++ *
++ * Licensed under the Apache License, Version 2.0 (the "License");
++ * you may not use this file except in compliance with the License.
++ * You may obtain a copy of the License at
++ *
++ *     http://www.apache.org/licenses/LICENSE-2.0
++ *
++ * Unless required by applicable law or agreed to in writing, software
++ * distributed under the License is distributed on an "AS IS" BASIS,
++ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++ * See the License for the specific language governing permissions and
++ * limitations under the License.
++ */
++
++#import <Foundation/Foundation.h>
++
++#import "RTCMacros.h"
++
++@class RTC_OBJC_TYPE(RTCRtpCodecCapability);
++@class RTC_OBJC_TYPE(RTCRtpHeaderExtensionCapability);
++
++NS_ASSUME_NONNULL_BEGIN
++
++RTC_OBJC_EXPORT
++@interface RTC_OBJC_TYPE (RTCRtpCapabilities) : NSObject
++
++- (instancetype)init NS_UNAVAILABLE;
++
++@property(nonatomic, readonly) NSArray<RTC_OBJC_TYPE(RTCRtpCodecCapability) *> *codecs;
++
++@property(nonatomic, readonly) NSArray<RTC_OBJC_TYPE(RTCRtpHeaderExtensionCapability) *> *header_extensions;
++
++@end
++
++NS_ASSUME_NONNULL_END
+\ No newline at end of file
+diff --git a/src/sdk/objc/api/peerconnection/RTCRtpCapabilities.mm b/src/sdk/objc/api/peerconnection/RTCRtpCapabilities.mm
+new file mode 100644
+index 0000000..7f73108
+--- /dev/null
++++ b/src/sdk/objc/api/peerconnection/RTCRtpCapabilities.mm
+@@ -0,0 +1,63 @@
++/*
++ * Copyright 2023 LiveKit
++ *
++ * Licensed under the Apache License, Version 2.0 (the "License");
++ * you may not use this file except in compliance with the License.
++ * You may obtain a copy of the License at
++ *
++ *     http://www.apache.org/licenses/LICENSE-2.0
++ *
++ * Unless required by applicable law or agreed to in writing, software
++ * distributed under the License is distributed on an "AS IS" BASIS,
++ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++ * See the License for the specific language governing permissions and
++ * limitations under the License.
++ */
++
++#import "RTCRtpCapabilities+Private.h"
++#import "RTCRtpCodecCapability+Private.h"
++#import "RTCRtpHeaderExtensionCapability+Private.h"
++
++#import "RTCMediaStreamTrack.h"
++#import "helpers/NSString+StdString.h"
++
++#include "media/base/media_constants.h"
++#include "rtc_base/checks.h"
++
++@implementation RTC_OBJC_TYPE (RTCRtpCapabilities)
++
++@synthesize nativeCapabilities = _nativeCapabilities;
++
++- (instancetype)initWithNativeCapabilities:(const webrtc::RtpCapabilities &)nativeCapabilities {
++  if (self = [super init]) {
++    _nativeCapabilities = nativeCapabilities;
++  }
++
++  return self;
++}
++
++- (NSArray<RTC_OBJC_TYPE(RTCRtpCodecCapability) *> *)codecs {
++  NSMutableArray *result = [NSMutableArray array];
++
++  for (auto &element : _nativeCapabilities.codecs) {
++    RTCRtpCodecCapability *object =
++        [[RTCRtpCodecCapability alloc] initWithNativeCodecCapability:element];
++    [result addObject:object];
++  }
++
++  return result;
++}
++
++- (NSArray<RTC_OBJC_TYPE(RTCRtpHeaderExtensionCapability) *> *)header_extensions {
++  NSMutableArray *result = [NSMutableArray array];
++
++  for (auto &element : _nativeCapabilities.header_extensions) {
++    RTCRtpHeaderExtensionCapability *object =
++        [[RTCRtpHeaderExtensionCapability alloc] initWithNativeHeaderExtensionCapability:element];
++    [result addObject:object];
++  }
++
++  return result;
++}
++
++@end
+\ No newline at end of file
+diff --git a/src/sdk/objc/api/peerconnection/RTCRtpCodecCapability+Private.h b/src/sdk/objc/api/peerconnection/RTCRtpCodecCapability+Private.h
+new file mode 100644
+index 0000000..b36d26c
+--- /dev/null
++++ b/src/sdk/objc/api/peerconnection/RTCRtpCodecCapability+Private.h
+@@ -0,0 +1,33 @@
++/*
++ * Copyright 2023 LiveKit
++ *
++ * Licensed under the Apache License, Version 2.0 (the "License");
++ * you may not use this file except in compliance with the License.
++ * You may obtain a copy of the License at
++ *
++ *     http://www.apache.org/licenses/LICENSE-2.0
++ *
++ * Unless required by applicable law or agreed to in writing, software
++ * distributed under the License is distributed on an "AS IS" BASIS,
++ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++ * See the License for the specific language governing permissions and
++ * limitations under the License.
++ */
++
++#import "RTCRtpCodecCapability.h"
++
++#include "api/rtp_parameters.h"
++
++NS_ASSUME_NONNULL_BEGIN
++
++@interface RTC_OBJC_TYPE (RTCRtpCodecCapability)
++()
++
++    @property(nonatomic, readonly) webrtc::RtpCodecCapability nativeCodecCapability;
++
++- (instancetype)initWithNativeCodecCapability:
++    (const webrtc::RtpCodecCapability &)nativeCodecCapability NS_DESIGNATED_INITIALIZER;
++
++@end
++
++NS_ASSUME_NONNULL_END
+\ No newline at end of file
+diff --git a/src/sdk/objc/api/peerconnection/RTCRtpCodecCapability.h b/src/sdk/objc/api/peerconnection/RTCRtpCodecCapability.h
+new file mode 100644
+index 0000000..0daf40e
+--- /dev/null
++++ b/src/sdk/objc/api/peerconnection/RTCRtpCodecCapability.h
+@@ -0,0 +1,63 @@
++/*
++ * Copyright 2023 LiveKit
++ *
++ * Licensed under the Apache License, Version 2.0 (the "License");
++ * you may not use this file except in compliance with the License.
++ * You may obtain a copy of the License at
++ *
++ *     http://www.apache.org/licenses/LICENSE-2.0
++ *
++ * Unless required by applicable law or agreed to in writing, software
++ * distributed under the License is distributed on an "AS IS" BASIS,
++ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++ * See the License for the specific language governing permissions and
++ * limitations under the License.
++ */
++
++#import <Foundation/Foundation.h>
++
++#import "RTCMacros.h"
++
++typedef NS_ENUM(NSInteger, RTCRtpMediaType);
++
++NS_ASSUME_NONNULL_BEGIN
++
++RTC_OBJC_EXPORT
++@interface RTC_OBJC_TYPE (RTCRtpCodecCapability) : NSObject
++
++// Build MIME "type/subtype" string from `name` and `kind`.
++@property(nonatomic, readonly) NSString *mimeType;
++
++// Used to identify the codec. Equivalent to MIME subtype.
++@property(nonatomic, copy) NSString *name;
++
++// The media type of this codec. Equivalent to MIME top-level type.
++@property(nonatomic, assign) RTCRtpMediaType kind;
++
++// Clock rate in Hertz. If unset, the codec is applicable to any clock rate.
++@property(nonatomic, copy, nullable) NSNumber *clockRate;
++
++// Default payload type for this codec. Mainly needed for codecs that use
++// that have statically assigned payload types.
++@property(nonatomic, copy, nullable) NSNumber *preferredPayloadType;
++
++// The number of audio channels supported. Unused for video codecs.
++@property(nonatomic, copy, nullable) NSNumber *numChannels;
++
++// Codec-specific parameters that must be signaled to the remote party.
++//
++// Corresponds to "a=fmtp" parameters in SDP.
++//
++// Contrary to ORTC, these parameters are named using all lowercase strings.
++// This helps make the mapping to SDP simpler, if an application is using SDP.
++// Boolean values are represented by the string "1".
++// std::map<std::string, std::string> parameters;
++@property(nonatomic, copy) NSDictionary<NSString *, NSString *> *parameters;
++
++// Feedback mechanisms supported for this codec.
++// std::vector<RtcpFeedback> rtcp_feedback;
++// Not implemented.
++
++@end
++
++NS_ASSUME_NONNULL_END
+\ No newline at end of file
+diff --git a/src/sdk/objc/api/peerconnection/RTCRtpCodecCapability.mm b/src/sdk/objc/api/peerconnection/RTCRtpCodecCapability.mm
+new file mode 100644
+index 0000000..341cde4
+--- /dev/null
++++ b/src/sdk/objc/api/peerconnection/RTCRtpCodecCapability.mm
+@@ -0,0 +1,138 @@
++/*
++ * Copyright 2023 LiveKit
++ *
++ * Licensed under the Apache License, Version 2.0 (the "License");
++ * you may not use this file except in compliance with the License.
++ * You may obtain a copy of the License at
++ *
++ *     http://www.apache.org/licenses/LICENSE-2.0
++ *
++ * Unless required by applicable law or agreed to in writing, software
++ * distributed under the License is distributed on an "AS IS" BASIS,
++ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++ * See the License for the specific language governing permissions and
++ * limitations under the License.
++ */
++
++#import "RTCRtpCodecCapability+Private.h"
++
++#import "RTCRtpReceiver+Private.h"
++
++#import "RTCMediaStreamTrack.h"
++#import "helpers/NSString+StdString.h"
++
++#include "media/base/media_constants.h"
++#include "rtc_base/checks.h"
++
++@implementation RTC_OBJC_TYPE (RTCRtpCodecCapability)
++
++@synthesize nativeCodecCapability = _nativeCodecCapability;
++
++- (instancetype)init {
++  return [self initWithNativeCodecCapability:webrtc::RtpCodecCapability()];
++}
++
++- (instancetype)initWithNativeCodecCapability:
++    (const webrtc::RtpCodecCapability &)nativeCodecCapability {
++  if (self = [super init]) {
++    _nativeCodecCapability = nativeCodecCapability;
++  }
++
++  return self;
++}
++
++- (NSString *)mimeType {
++  return [NSString stringWithUTF8String:_nativeCodecCapability.mime_type().c_str()];
++}
++
++- (NSString *)name {
++  return [NSString stringWithUTF8String:_nativeCodecCapability.name.c_str()];
++}
++
++- (void)setName:(NSString *)name {
++  _nativeCodecCapability.name = std::string([name UTF8String]);
++}
++
++- (RTCRtpMediaType)kind {
++  return [RTCRtpReceiver mediaTypeForNativeMediaType:_nativeCodecCapability.kind];
++}
++
++- (void)setKind:(RTCRtpMediaType)kind {
++  _nativeCodecCapability.kind = [RTCRtpReceiver nativeMediaTypeForMediaType:kind];
++}
++
++- (NSNumber *)clockRate {
++  if (!_nativeCodecCapability.clock_rate) {
++    return nil;
++  }
++
++  return [NSNumber numberWithInt:*_nativeCodecCapability.clock_rate];
++}
++
++- (void)setClockRate:(NSNumber *)clockRate {
++  if (clockRate == nil) {
++    _nativeCodecCapability.clock_rate = absl::optional<int>();
++    return;
++  }
++
++  _nativeCodecCapability.clock_rate = absl::optional<int>(clockRate.intValue);
++}
++
++- (NSNumber *)preferredPayloadType {
++  if (!_nativeCodecCapability.preferred_payload_type) {
++    return nil;
++  }
++
++  return [NSNumber numberWithInt:*_nativeCodecCapability.preferred_payload_type];
++}
++
++- (void)setPreferredPayloadType:(NSNumber *)preferredPayloadType {
++  if (preferredPayloadType == nil) {
++    _nativeCodecCapability.preferred_payload_type = absl::optional<int>();
++    return;
++  }
++
++  _nativeCodecCapability.preferred_payload_type =
++      absl::optional<int>(preferredPayloadType.intValue);
++}
++
++- (NSNumber *)numChannels {
++  if (!_nativeCodecCapability.num_channels) {
++    return nil;
++  }
++
++  return [NSNumber numberWithInt:*_nativeCodecCapability.num_channels];
++}
++
++- (void)setNumChannels:(NSNumber *)numChannels {
++  if (numChannels == nil) {
++    _nativeCodecCapability.num_channels = absl::optional<int>();
++    return;
++  }
++
++  _nativeCodecCapability.num_channels = absl::optional<int>(numChannels.intValue);
++}
++
++- (NSDictionary<NSString *, NSString *> *)parameters {
++  NSMutableDictionary *result = [NSMutableDictionary dictionary];
++  auto _parameters = _nativeCodecCapability.parameters;
++  for (auto it = _parameters.begin(); it != _parameters.end(); ++it) {
++    [result setObject:[NSString stringForStdString:it->second]
++               forKey:[NSString stringForStdString:it->first]];
++  }
++
++  return result;
++}
++
++- (void)setParameters:(NSDictionary<NSString *, NSString *> *)parameters {
++  std::map<std::string, std::string> _parameters;
++  for (NSString *paramKey in parameters.allKeys) {
++    std::string key = [NSString stdStringForString:paramKey];
++    std::string value = [NSString stdStringForString:parameters[paramKey]];
++    _parameters[key] = value;
++  }
++
++  _nativeCodecCapability.parameters = _parameters;
++}
++
++@end
+\ No newline at end of file
+diff --git a/src/sdk/objc/api/peerconnection/RTCRtpEncodingParameters.h b/src/sdk/objc/api/peerconnection/RTCRtpEncodingParameters.h
+index 07f6b7a..d055115 100644
+--- a/src/sdk/objc/api/peerconnection/RTCRtpEncodingParameters.h
++++ b/src/sdk/objc/api/peerconnection/RTCRtpEncodingParameters.h
+@@ -51,6 +51,10 @@ RTC_OBJC_EXPORT
+  */
+ @property(nonatomic, copy, nullable) NSNumber *numTemporalLayers;
+ 
++/** A case-sensitive identifier of the scalability mode to be used for this stream.
++  https://w3c.github.io/webrtc-svc/#rtcrtpencodingparameters */
++@property(nonatomic, copy, nullable) NSString *scalabilityMode;
++
+ /** Scale the width and height down by this factor for video. If nil,
+  * implementation default scaling factor will be used.
+  */
+diff --git a/src/sdk/objc/api/peerconnection/RTCRtpEncodingParameters.mm b/src/sdk/objc/api/peerconnection/RTCRtpEncodingParameters.mm
+index d6087da..e2020bb 100644
+--- a/src/sdk/objc/api/peerconnection/RTCRtpEncodingParameters.mm
++++ b/src/sdk/objc/api/peerconnection/RTCRtpEncodingParameters.mm
+@@ -20,6 +20,7 @@
+ @synthesize minBitrateBps = _minBitrateBps;
+ @synthesize maxFramerate = _maxFramerate;
+ @synthesize numTemporalLayers = _numTemporalLayers;
++@synthesize scalabilityMode = _scalabilityMode;
+ @synthesize scaleResolutionDownBy = _scaleResolutionDownBy;
+ @synthesize ssrc = _ssrc;
+ @synthesize bitratePriority = _bitratePriority;
+@@ -52,6 +53,9 @@
+     if (nativeParameters.num_temporal_layers) {
+       _numTemporalLayers = [NSNumber numberWithInt:*nativeParameters.num_temporal_layers];
+     }
++    if (nativeParameters.scalability_mode) {
++      _scalabilityMode = [NSString stringWithUTF8String:nativeParameters.scalability_mode->c_str()];
++    }
+     if (nativeParameters.scale_resolution_down_by) {
+       _scaleResolutionDownBy =
+           [NSNumber numberWithDouble:*nativeParameters.scale_resolution_down_by];
+@@ -85,6 +89,9 @@
+   if (_numTemporalLayers != nil) {
+     parameters.num_temporal_layers = absl::optional<int>(_numTemporalLayers.intValue);
+   }
++  if (_scalabilityMode != nil) {
++    parameters.scalability_mode = absl::optional<std::string>(std::string([_scalabilityMode UTF8String]));
++  }
+   if (_scaleResolutionDownBy != nil) {
+     parameters.scale_resolution_down_by =
+         absl::optional<double>(_scaleResolutionDownBy.doubleValue);
+diff --git a/src/sdk/objc/api/peerconnection/RTCRtpHeaderExtensionCapability+Private.h b/src/sdk/objc/api/peerconnection/RTCRtpHeaderExtensionCapability+Private.h
+new file mode 100644
+index 0000000..2fa8c25
+--- /dev/null
++++ b/src/sdk/objc/api/peerconnection/RTCRtpHeaderExtensionCapability+Private.h
+@@ -0,0 +1,33 @@
++/*
++ * Copyright 2023 LiveKit
++ *
++ * Licensed under the Apache License, Version 2.0 (the "License");
++ * you may not use this file except in compliance with the License.
++ * You may obtain a copy of the License at
++ *
++ *     http://www.apache.org/licenses/LICENSE-2.0
++ *
++ * Unless required by applicable law or agreed to in writing, software
++ * distributed under the License is distributed on an "AS IS" BASIS,
++ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++ * See the License for the specific language governing permissions and
++ * limitations under the License.
++ */
++
++#import "RTCRtpHeaderExtensionCapability.h"
++
++#include "api/rtp_parameters.h"
++
++NS_ASSUME_NONNULL_BEGIN
++
++@interface RTC_OBJC_TYPE (RTCRtpHeaderExtensionCapability)
++()
++
++    @property(nonatomic, readonly) webrtc::RtpHeaderExtensionCapability nativeHeaderExtensionCapability;
++
++- (instancetype)initWithNativeHeaderExtensionCapability:
++    (const webrtc::RtpHeaderExtensionCapability &)nativeHeaderExtensionCapability NS_DESIGNATED_INITIALIZER;
++
++@end
++
++NS_ASSUME_NONNULL_END
+\ No newline at end of file
+diff --git a/src/sdk/objc/api/peerconnection/RTCRtpHeaderExtensionCapability.h b/src/sdk/objc/api/peerconnection/RTCRtpHeaderExtensionCapability.h
+new file mode 100644
+index 0000000..27bb0e5
+--- /dev/null
++++ b/src/sdk/objc/api/peerconnection/RTCRtpHeaderExtensionCapability.h
+@@ -0,0 +1,37 @@
++/*
++ * Copyright 2023 LiveKit
++ *
++ * Licensed under the Apache License, Version 2.0 (the "License");
++ * you may not use this file except in compliance with the License.
++ * You may obtain a copy of the License at
++ *
++ *     http://www.apache.org/licenses/LICENSE-2.0
++ *
++ * Unless required by applicable law or agreed to in writing, software
++ * distributed under the License is distributed on an "AS IS" BASIS,
++ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++ * See the License for the specific language governing permissions and
++ * limitations under the License.
++ */
++
++#import <Foundation/Foundation.h>
++
++#import "RTCMacros.h"
++
++NS_ASSUME_NONNULL_BEGIN
++
++RTC_OBJC_EXPORT
++@interface RTC_OBJC_TYPE (RTCRtpHeaderExtensionCapability) : NSObject
++
++// URI of this extension, as defined in RFC8285.
++@property(nonatomic, readonly) NSString *uri;
++
++// Preferred value of ID that goes in the packet.
++@property(nonatomic, assign) NSNumber *preferred_id;
++
++// If true, it's preferred that the value in the header is encrypted.
++@property(nonatomic, assign) BOOL preferred_encrypt;
++
++@end
++
++NS_ASSUME_NONNULL_END
+\ No newline at end of file
+diff --git a/src/sdk/objc/api/peerconnection/RTCRtpHeaderExtensionCapability.mm b/src/sdk/objc/api/peerconnection/RTCRtpHeaderExtensionCapability.mm
+new file mode 100644
+index 0000000..e36d2b4
+--- /dev/null
++++ b/src/sdk/objc/api/peerconnection/RTCRtpHeaderExtensionCapability.mm
+@@ -0,0 +1,54 @@
++/*
++ * Copyright 2023 LiveKit
++ *
++ * Licensed under the Apache License, Version 2.0 (the "License");
++ * you may not use this file except in compliance with the License.
++ * You may obtain a copy of the License at
++ *
++ *     http://www.apache.org/licenses/LICENSE-2.0
++ *
++ * Unless required by applicable law or agreed to in writing, software
++ * distributed under the License is distributed on an "AS IS" BASIS,
++ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++ * See the License for the specific language governing permissions and
++ * limitations under the License.
++ */
++
++#import "RTCRtpHeaderExtensionCapability+Private.h"
++
++#import "helpers/NSString+StdString.h"
++
++#include "media/base/media_constants.h"
++#include "rtc_base/checks.h"
++
++@implementation RTC_OBJC_TYPE (RTCRtpHeaderExtensionCapability)
++
++@synthesize nativeHeaderExtensionCapability = _nativeHeaderExtensionCapability;
++
++- (instancetype)init {
++  return [self initWithNativeHeaderExtensionCapability:webrtc::RtpHeaderExtensionCapability()];
++}
++
++- (instancetype)initWithNativeHeaderExtensionCapability:
++    (const webrtc::RtpHeaderExtensionCapability &)nativeHeaderExtensionCapability {
++  if (self = [super init]) {
++    _nativeHeaderExtensionCapability = nativeHeaderExtensionCapability;
++  }
++
++  return self;
++}
++
++- (NSString *)uri {
++  return [NSString stringWithUTF8String:_nativeHeaderExtensionCapability.uri.c_str()];
++}
++
++- (NSNumber *)preferredId {
++  return [NSNumber numberWithInt:*_nativeHeaderExtensionCapability.preferred_id];
++
++}
++
++- (BOOL)preferredEncrypt {
++  return _nativeHeaderExtensionCapability.preferred_encrypt;
++}
++
++@end
+\ No newline at end of file
+diff --git a/src/api/video_codecs/builtin_video_encoder_factory.cc b/src/api/video_codecs/builtin_video_encoder_factory.cc
+index 573eb47..fada36f 100644
+--- a/src/api/video_codecs/builtin_video_encoder_factory.cc
++++ b/src/api/video_codecs/builtin_video_encoder_factory.cc
+@@ -13,6 +13,7 @@
+ #include <memory>
+ #include <string>
+ #include <vector>
++#include <android/log.h>
+ 
+ #include "absl/strings/match.h"
+ #include "absl/types/optional.h"
+@@ -50,6 +51,7 @@ class BuiltinVideoEncoderFactory : public VideoEncoderFactory {
+   }
+ 
+   std::vector<SdpVideoFormat> GetSupportedFormats() const override {
++  __android_log_print(ANDROID_LOG_ERROR, "HORSE", "%s", "NOPE");
+     return internal_encoder_factory_->GetSupportedFormats();
+   }
+ 
+diff --git a/src/api/video_codecs/video_decoder_factory_template.h b/src/api/video_codecs/video_decoder_factory_template.h
+index 703ae11..227ec0b 100644
+--- a/src/api/video_codecs/video_decoder_factory_template.h
++++ b/src/api/video_codecs/video_decoder_factory_template.h
+@@ -39,6 +39,7 @@ template <typename... Ts>
+ class VideoDecoderFactoryTemplate : public VideoDecoderFactory {
+  public:
+   std::vector<SdpVideoFormat> GetSupportedFormats() const override {
++    __android_log_print(ANDROID_LOG_ERROR, "HORSE2", "%s", "NOPE");
+     return GetSupportedFormatsInternal<Ts...>();
+   }
+ 
+@@ -60,12 +61,14 @@ class VideoDecoderFactoryTemplate : public VideoDecoderFactory {
+ 
+   template <typename V, typename... Vs>
+   std::vector<SdpVideoFormat> GetSupportedFormatsInternal() const {
++    __android_log_print(ANDROID_LOG_ERROR, "HORSE3", "%s", "NOPE")
+     auto supported_formats = V::SupportedFormats();
+ 
+     if constexpr (sizeof...(Vs) > 0) {
+       // Supported formats may overlap between implementations, so duplicates
+       // should be filtered out.
+       for (const auto& other_format : GetSupportedFormatsInternal<Vs...>()) {
++        __android_log_print(ANDROID_LOG_ERROR, "HORSE4", "%s", "NOPE")
+         if (!IsFormatInList(other_format, supported_formats)) {
+           supported_formats.push_back(other_format);
+         }
+diff --git a/src/api/video_codecs/video_encoder_factory_template.h b/src/api/video_codecs/video_encoder_factory_template.h
+index 10212ac..44f61a7 100644
+--- a/src/api/video_codecs/video_encoder_factory_template.h
++++ b/src/api/video_codecs/video_encoder_factory_template.h
+@@ -14,6 +14,7 @@
+ #include <memory>
+ #include <string>
+ #include <vector>
++#include <android/log.h>
+ 
+ #include "absl/algorithm/container.h"
+ #include "api/array_view.h"
+@@ -47,6 +48,7 @@ template <typename... Ts>
+ class VideoEncoderFactoryTemplate : public VideoEncoderFactory {
+  public:
+   std::vector<SdpVideoFormat> GetSupportedFormats() const override {
++    __android_log_print(ANDROID_LOG_ERROR, "HOPE", "%s", "NOPE")
+     return GetSupportedFormatsInternal<Ts...>();
+   }
+ 
+@@ -95,12 +97,14 @@ class VideoEncoderFactoryTemplate : public VideoEncoderFactory {
+ 
+   template <typename V, typename... Vs>
+   std::vector<SdpVideoFormat> GetSupportedFormatsInternal() const {
++    __android_log_print(ANDROID_LOG_ERROR, "HOPE2", "%s", "NOPE")
+     auto supported_formats = V::SupportedFormats();
+ 
+     if constexpr (sizeof...(Vs) > 0) {
+       // Supported formats may overlap between implementations, so duplicates
+       // should be filtered out.
+       for (const auto& other_format : GetSupportedFormatsInternal<Vs...>()) {
++    __android_log_print(ANDROID_LOG_ERROR, "HOPE3", "%s", "NOPE")
+         if (!IsFormatInList(other_format, supported_formats)) {
+           supported_formats.push_back(other_format);
+         }
+diff --git a/src/api/video_codecs/video_encoder_factory_template_libvpx_vp8_adapter.h b/src/api/video_codecs/video_encoder_factory_template_libvpx_vp8_adapter.h
+index 0f0a9ba..a2d608b 100644
+--- a/src/api/video_codecs/video_encoder_factory_template_libvpx_vp8_adapter.h
++++ b/src/api/video_codecs/video_encoder_factory_template_libvpx_vp8_adapter.h
+@@ -18,6 +18,7 @@
+ #include "api/video_codecs/sdp_video_format.h"
+ #include "modules/video_coding/codecs/vp8/include/vp8.h"
+ #include "modules/video_coding/codecs/vp8/vp8_scalability.h"
++#include <android/log.h>
+ 
+ namespace webrtc {
+ struct LibvpxVp8EncoderTemplateAdapter {
+@@ -26,6 +27,9 @@ struct LibvpxVp8EncoderTemplateAdapter {
+         scalability_modes;
+     for (const auto scalability_mode : kVP8SupportedScalabilityModes) {
+       scalability_modes.push_back(scalability_mode);
++        auto sv2 = ScalabilityModeToString(scalability_mode);
++        std::string s2 = {sv2.begin(), sv2.end()};
++        __android_log_print(ANDROID_LOG_ERROR, "LibvpxVp8EncoderTemplateAdapter", "%s", s2.c_str());
+     }
+ 
+     return {
+diff --git a/src/media/base/media_engine.cc b/src/media/base/media_engine.cc
+index 7304ab0..e69e712 100644
+--- a/src/media/base/media_engine.cc
++++ b/src/media/base/media_engine.cc
+@@ -15,6 +15,9 @@
+ #include <cstdint>
+ #include <string>
+ #include <utility>
++#include <sstream>
++#include <iostream>
++#include <android/log.h>
+ 
+ #include "absl/algorithm/container.h"
+ #include "api/video/video_bitrate_allocation.h"
+@@ -95,10 +98,22 @@ webrtc::RTCError CheckScalabilityModeValues(
+       }
+     }
+     if (rtp_parameters.encodings[i].scalability_mode) {
++        std::stringstream ss;
+       if (!send_codec) {
+-        bool scalabilityModeFound = false;
+-        for (const cricket::VideoCodec& codec : codec_preferences) {
+-          for (const auto& scalability_mode : codec.scalability_modes) {
++         bool scalabilityModeFound = false;
++        __android_log_print(ANDROID_LOG_ERROR, "codec_preferences", "%lu", (unsigned long) codec_preferences.size());
++         for (const cricket::VideoCodec& codec : codec_preferences) {
++        __android_log_print(ANDROID_LOG_ERROR, "codec", "|%s|", codec.name.c_str());
++        __android_log_print(ANDROID_LOG_ERROR, "codec_preferences.scalability_modes", "%lu", (unsigned long) codec.scalability_modes.size());
++           for (const auto& scalability_mode : codec.scalability_modes) {
++        auto sv = *rtp_parameters.encodings[i].scalability_mode; auto sv2 = ScalabilityModeToString(scalability_mode);
++        std::string s = {sv.begin(), sv.end()}; std::string s2 = {sv2.begin(), sv2.end()};
++        __android_log_print(ANDROID_LOG_ERROR, "scalability_mode", "|%s|", s2.c_str());
++        __android_log_print(ANDROID_LOG_ERROR, "scalability_mode2", "|%s|", s.c_str());
++
++
++          ss << "\nscalability_mode" << ScalabilityModeToString(scalability_mode) << "-" << *rtp_parameters.encodings[i].scalability_mode;
++
+             if (ScalabilityModeToString(scalability_mode) ==
+                 *rtp_parameters.encodings[i].scalability_mode) {
+               scalabilityModeFound = true;
+@@ -110,14 +125,24 @@ webrtc::RTCError CheckScalabilityModeValues(
+         }
+ 
+         if (!scalabilityModeFound) {
++        __android_log_print(ANDROID_LOG_ERROR, "AAAAA42", "%s", ss.str().c_str());
++          std::cout << ss.str() << std::endl;
+           LOG_AND_RETURN_ERROR(
+               RTCErrorType::INVALID_MODIFICATION,
+               "Attempted to set RtpParameters scalabilityMode "
+               "to an unsupported value for the current codecs.");
+         }
+       } else {
++          ss << "\nsend_codec";
++
+         bool scalabilityModeFound = false;
+         for (const auto& scalability_mode : send_codec->scalability_modes) {
++          ss << "\nscalability_mode" << ScalabilityModeToString(scalability_mode) << "-" << *rtp_parameters.encodings[i].scalability_mode;
++        auto sv = *rtp_parameters.encodings[i].scalability_mode; auto sv2 = ScalabilityModeToString(scalability_mode);
++        std::string s = {sv.begin(), sv.end()}; std::string s2 = {sv2.begin(), sv2.end()};
++        __android_log_print(ANDROID_LOG_ERROR, "scalability_mode", "|%s|", s2.c_str());
++        __android_log_print(ANDROID_LOG_ERROR, "scalability_mode2", "|%s|", s.c_str());
++
+           if (ScalabilityModeToString(scalability_mode) ==
+               *rtp_parameters.encodings[i].scalability_mode) {
+             scalabilityModeFound = true;
+@@ -125,6 +150,8 @@ webrtc::RTCError CheckScalabilityModeValues(
+           }
+         }
+         if (!scalabilityModeFound) {
++        __android_log_print(ANDROID_LOG_ERROR, "AAAAA422", "%s", ss.str().c_str());
++          std::cout << ss.str() << std::endl;
+           LOG_AND_RETURN_ERROR(
+               RTCErrorType::INVALID_MODIFICATION,
+               "Attempted to set RtpParameters scalabilityMode "
+diff --git a/src/media/engine/webrtc_video_engine.cc b/src/media/engine/webrtc_video_engine.cc
+index 91750b8..c63ced1 100644
+--- a/src/media/engine/webrtc_video_engine.cc
++++ b/src/media/engine/webrtc_video_engine.cc
+@@ -19,6 +19,7 @@
+ #include <string>
+ #include <type_traits>
+ #include <utility>
++#include <android/log.h>
+ 
+ #include "absl/algorithm/container.h"
+ #include "absl/container/inlined_vector.h"
+@@ -179,7 +180,10 @@ std::vector<VideoCodec> GetPayloadTypesAndDefaultCodecs(
+     bool is_decoder_factory,
+     bool include_rtx,
+     const webrtc::FieldTrialsView& trials) {
++
++  __android_log_print(ANDROID_LOG_ERROR, "GetPayloadTypesAndDefaultCodecs", "%s", "GetPayloadTypesAndDefaultCodecs");
+   if (!factory) {
++  __android_log_print(ANDROID_LOG_ERROR, "GetPayloadTypesAndDefaultCodecs", "%s", "NOPE");
+     return {};
+   }
+ 
+@@ -219,6 +223,8 @@ std::vector<VideoCodec> GetPayloadTypesAndDefaultCodecs(
+ 
+   std::vector<VideoCodec> output_codecs;
+   for (const webrtc::SdpVideoFormat& format : supported_formats) {
++  __android_log_print(ANDROID_LOG_ERROR, "GetPayloadTypesAndDefaultCodecs", "%s %lu", format.name.c_str(), (unsigned long) format.scalability_modes.size());
++
+     VideoCodec codec = cricket::CreateVideoCodec(format);
+     bool isFecCodec = absl::EqualsIgnoreCase(codec.name, kUlpfecCodecName) ||
+                       absl::EqualsIgnoreCase(codec.name, kFlexfecCodecName);
+diff --git a/src/modules/video_coding/codecs/av1/av1_svc_config.cc b/src/modules/video_coding/codecs/av1/av1_svc_config.cc
+index 30c0f30..325bc4e 100644
+--- a/src/modules/video_coding/codecs/av1/av1_svc_config.cc
++++ b/src/modules/video_coding/codecs/av1/av1_svc_config.cc
+@@ -20,6 +20,7 @@
+ #include "rtc_base/checks.h"
+ #include "rtc_base/logging.h"
+ #include "rtc_base/strings/string_builder.h"
++#include <android/log.h>
+ 
+ namespace webrtc {
+ namespace {
+@@ -58,6 +59,9 @@ LibaomAv1EncoderSupportedScalabilityModes() {
+   for (ScalabilityMode scalability_mode : kAllScalabilityModes) {
+     if (ScalabilityStructureConfig(scalability_mode) != absl::nullopt) {
+       scalability_modes.push_back(scalability_mode);
++              auto sv2 = ScalabilityModeToString(scalability_mode);
++        std::string s2 = {sv2.begin(), sv2.end()};
++        __android_log_print(ANDROID_LOG_ERROR, "LibaomAv1EncoderSupportedScalabilityModes", "%s", s2.c_str());
+     }
+   }
+   return scalability_modes;
+diff --git a/src/modules/video_coding/codecs/h264/h264.cc b/src/modules/video_coding/codecs/h264/h264.cc
+index 5b9f033..177b8e3 100644
+--- a/src/modules/video_coding/codecs/h264/h264.cc
++++ b/src/modules/video_coding/codecs/h264/h264.cc
+@@ -19,6 +19,7 @@
+ #include "api/video_codecs/sdp_video_format.h"
+ #include "media/base/media_constants.h"
+ #include "rtc_base/trace_event.h"
++#include <android/log.h>
+ 
+ #if defined(WEBRTC_USE_H264)
+ #include "modules/video_coding/codecs/h264/h264_decoder_impl.h"
+@@ -61,6 +62,9 @@ SdpVideoFormat CreateH264Format(H264Profile profile,
+   if (add_scalability_modes) {
+     for (const auto scalability_mode : kSupportedScalabilityModes) {
+       scalability_modes.push_back(scalability_mode);
++              auto sv2 = ScalabilityModeToString(scalability_mode);
++        std::string s2 = {sv2.begin(), sv2.end()};
++        __android_log_print(ANDROID_LOG_ERROR, "H264ProfileLevelIdToString", "%s", s2.c_str());
+     }
+   }
+   return SdpVideoFormat(
+diff --git a/src/modules/video_coding/codecs/vp9/vp9.cc b/src/modules/video_coding/codecs/vp9/vp9.cc
+index c1dbf3a..2a810be 100644
+--- a/src/modules/video_coding/codecs/vp9/vp9.cc
++++ b/src/modules/video_coding/codecs/vp9/vp9.cc
+@@ -25,6 +25,7 @@
+ #include "vpx/vp8cx.h"
+ #include "vpx/vp8dx.h"
+ #include "vpx/vpx_codec.h"
++#include <android/log.h>
+ 
+ namespace webrtc {
+ 
+@@ -43,6 +44,9 @@ std::vector<SdpVideoFormat> SupportedVP9Codecs(bool add_scalability_modes) {
+     for (const auto scalability_mode : kAllScalabilityModes) {
+       if (ScalabilityStructureConfig(scalability_mode).has_value()) {
+         scalability_modes.push_back(scalability_mode);
++                auto sv2 = ScalabilityModeToString(scalability_mode);
++        std::string s2 = {sv2.begin(), sv2.end()};
++        __android_log_print(ANDROID_LOG_ERROR, "SupportedVP9Codecs", "%s", s2.c_str());
+       }
+     }
+   }
+diff --git a/src/pc/rtp_sender.cc b/src/pc/rtp_sender.cc
+index cdae159..f7827da 100644
+--- a/src/pc/rtp_sender.cc
++++ b/src/pc/rtp_sender.cc
+@@ -237,6 +237,7 @@ void RtpSenderBase::SetParametersInternal(const RtpParameters& parameters,
+   RTC_DCHECK_RUN_ON(signaling_thread_);
+   RTC_DCHECK(!stopped_);
+ 
++  // nope2
+   if (UnimplementedRtpParameterHasValue(parameters)) {
+     RTCError error(
+         RTCErrorType::UNSUPPORTED_PARAMETER,
+@@ -247,6 +248,7 @@ void RtpSenderBase::SetParametersInternal(const RtpParameters& parameters,
+     return;
+   }
+   if (!media_channel_ || !ssrc_) {
++    // nope3
+     auto result = cricket::CheckRtpParametersInvalidModificationAndValues(
+         init_parameters_, parameters, codec_preferences_, absl::nullopt);
+     if (result.ok()) {
+@@ -265,6 +267,7 @@ void RtpSenderBase::SetParametersInternal(const RtpParameters& parameters,
+                                              old_parameters.encodings);
+     }
+ 
++    // nope4
+     RTCError result = cricket::CheckRtpParametersInvalidModificationAndValues(
+         old_parameters, rtp_parameters);
+     if (!result.ok()) {
+@@ -272,6 +275,8 @@ void RtpSenderBase::SetParametersInternal(const RtpParameters& parameters,
+       return;
+     }
+ 
++    // nope ?
++
+     result = CheckCodecParameters(rtp_parameters);
+     if (!result.ok()) {
+       webrtc::InvokeSetParametersCallback(callback, result);
+@@ -353,7 +358,8 @@ RTCError RtpSenderBase::CheckCodecParameters(const RtpParameters& parameters) {
+       send_codec_with_svc_info = *codec_match;
+     }
+   }
+-
++  
++  // here
+   return cricket::CheckScalabilityModeValues(parameters, codec_preferences_,
+                                              send_codec_with_svc_info);
+ }
+@@ -364,6 +370,7 @@ RTCError RtpSenderBase::SetParameters(const RtpParameters& parameters) {
+   RTCError result = CheckSetParameters(parameters);
+   if (!result.ok())
+     return result;
++  // nope
+ 
+   // Some tests rely on working in single thread mode without a run loop and a
+   // blocking call is required to keep them working. The encoder configuration
+diff --git a/src/pc/rtp_sender.h b/src/pc/rtp_sender.h
+index d29c376..1a7c34c 100644
+--- a/src/pc/rtp_sender.h
++++ b/src/pc/rtp_sender.h
+@@ -21,6 +21,7 @@
+ #include <memory>
+ #include <string>
+ #include <vector>
++#include <android/log.h>
+ 
+ #include "absl/types/optional.h"
+ #include "api/crypto/frame_encryptor_interface.h"
+@@ -225,6 +226,22 @@ class RtpSenderBase : public RtpSenderInternal, public ObserverInterface {
+ 
+   void SetCodecPreferences(
+       std::vector<cricket::Codec> codec_preferences) override {
++    __android_log_print(ANDROID_LOG_ERROR, "SetCodecPreferences", "%lu",
++                        (unsigned long)codec_preferences.size());
++    for (size_t i = 0; i < codec_preferences.size(); ++i) {
++      __android_log_print(
++          ANDROID_LOG_ERROR, "SetCodecPreferences scalability_modes", "%lu",
++          (unsigned long)codec_preferences[i].scalability_modes.size());
++
++      for (size_t j = 0; j < codec_preferences[i].scalability_modes.size(); ++j) {
++        auto sv =
++            ScalabilityModeToString(codec_preferences[i].scalability_modes[j]);
++        std::string s = {sv.begin(), sv.end()};
++
++        __android_log_print(ANDROID_LOG_ERROR, "SetCodecPreferences MOD", "%s",
++                            s.c_str());
++      }
++    }
+     codec_preferences_ = codec_preferences;
+   }
+ 
+diff --git a/src/pc/rtp_transceiver.cc b/src/pc/rtp_transceiver.cc
+index 815ec9d..381ba9f 100644
+--- a/src/pc/rtp_transceiver.cc
++++ b/src/pc/rtp_transceiver.cc
+@@ -17,6 +17,7 @@
+ #include <string>
+ #include <utility>
+ #include <vector>
++#include <android/log.h>
+ 
+ #include "absl/algorithm/container.h"
+ #include "absl/memory/memory.h"
+@@ -171,6 +172,28 @@ RtpTransceiver::RtpTransceiver(
+   RTC_DCHECK(media_type_ == cricket::M
\ No newline at end of file
diff --git a/src/sdk/BUILD.gn b/src/sdk/BUILD.gn
index 4f5ceb5..a743579 100644
--- a/src/sdk/BUILD.gn
+++ b/src/sdk/BUILD.gn
@@ -991,6 +991,15 @@ if (is_ios || is_mac) {
         "objc/api/peerconnection/RTCRtcpParameters+Private.h",
         "objc/api/peerconnection/RTCRtcpParameters.h",
         "objc/api/peerconnection/RTCRtcpParameters.mm",
+        "objc/api/peerconnection/RTCRtpCapabilities.h",
+        "objc/api/peerconnection/RTCRtpCapabilities.mm",
+        "objc/api/peerconnection/RTCRtpCapabilities+Private.h",
+        "objc/api/peerconnection/RTCRtpCodecCapability.h",
+        "objc/api/peerconnection/RTCRtpCodecCapability.mm",
+        "objc/api/peerconnection/RTCRtpCodecCapability+Private.h",
+        "objc/api/peerconnection/RTCRtpHeaderExtensionCapability.h",
+        "objc/api/peerconnection/RTCRtpHeaderExtensionCapability.mm",
+        "objc/api/peerconnection/RTCRtpHeaderExtensionCapability+Private.h",
         "objc/api/peerconnection/RTCRtpCodecParameters+Private.h",
         "objc/api/peerconnection/RTCRtpCodecParameters.h",
         "objc/api/peerconnection/RTCRtpCodecParameters.mm",
@@ -1309,6 +1318,9 @@ if (is_ios || is_mac) {
           "objc/api/peerconnection/RTCPeerConnectionFactory.h",
           "objc/api/peerconnection/RTCPeerConnectionFactoryOptions.h",
           "objc/api/peerconnection/RTCRtcpParameters.h",
+          "objc/api/peerconnection/RTCRtpCapabilities.h",
+          "objc/api/peerconnection/RTCRtpCodecCapability.h",
+          "objc/api/peerconnection/RTCRtpHeaderExtensionCapability.h",
           "objc/api/peerconnection/RTCRtpCodecParameters.h",
           "objc/api/peerconnection/RTCRtpEncodingParameters.h",
           "objc/api/peerconnection/RTCRtpHeaderExtension.h",
@@ -1423,6 +1435,9 @@ if (is_ios || is_mac) {
           "objc/api/peerconnection/RTCPeerConnectionFactory.h",
           "objc/api/peerconnection/RTCPeerConnectionFactoryOptions.h",
           "objc/api/peerconnection/RTCRtcpParameters.h",
+          "objc/api/peerconnection/RTCRtpCapabilities.h",
+          "objc/api/peerconnection/RTCRtpCodecCapability.h",
+          "objc/api/peerconnection/RTCRtpHeaderExtensionCapability.h",
           "objc/api/peerconnection/RTCRtpCodecParameters.h",
           "objc/api/peerconnection/RTCRtpEncodingParameters.h",
           "objc/api/peerconnection/RTCRtpHeaderExtension.h",
diff --git a/src/sdk/android/api/org/webrtc/HardwareVideoEncoderFactory.java b/src/sdk/android/api/org/webrtc/HardwareVideoEncoderFactory.java
index d43fc27..5c17b8e 100644
--- a/src/sdk/android/api/org/webrtc/HardwareVideoEncoderFactory.java
+++ b/src/sdk/android/api/org/webrtc/HardwareVideoEncoderFactory.java
@@ -133,6 +133,8 @@ public class HardwareVideoEncoderFactory implements VideoEncoderFactory {
     List<VideoCodecInfo> supportedCodecInfos = new ArrayList<VideoCodecInfo>();
     // Generate a list of supported codecs in order of preference:
     // VP8, VP9, H264 (high profile), H264 (baseline profile), AV1 and H265.
+
+    // tut?
     for (VideoCodecMimeType type :
         new VideoCodecMimeType[] {VideoCodecMimeType.VP8, VideoCodecMimeType.VP9,
             VideoCodecMimeType.H264, VideoCodecMimeType.AV1, VideoCodecMimeType.H265}) {
@@ -141,13 +143,82 @@ public class HardwareVideoEncoderFactory implements VideoEncoderFactory {
         String name = type.name();
         // TODO(sakal): Always add H264 HP once WebRTC correctly removes codecs that are not
         // supported by the decoder.
+
         if (type == VideoCodecMimeType.H264 && isH264HighProfileSupported(codec)) {
           supportedCodecInfos.add(new VideoCodecInfo(
-              name, MediaCodecUtils.getCodecProperties(type, /* highProfile= */ true)));
+              name, MediaCodecUtils.getCodecProperties(type, /* highProfile= */ true), Arrays.asList(
+                  "L1T1",
+                  "L1T2",
+                  "L1T3",
+                  "L2T1",
+                  "L2T1h",
+                  "L2T1_KEY",
+                  "L2T2",
+                  "L2T2h",
+                  "L2T2_KEY",
+                  "L2T2_KEY_SHIFT",
+                  "L2T3",
+                  "L2T3h",
+                  "L2T3_KEY",
+                  "L3T1",
+                  "L3T1h",
+                  "L3T1_KEY",
+                  "L3T2",
+                  "L3T2h",
+                  "L3T2_KEY",
+                  "L3T3",
+                  "L3T3h",
+                  "L3T3_KEY",
+                  "S2T1",
+                  "S2T1h",
+                  "S2T2",
+                  "S2T2h",
+                  "S2T3",
+                  "S2T3h",
+                  "S3T1",
+                  "S3T1h",
+                  "S3T2",
+                  "S3T2h",
+                  "S3T3",
+                  "S3T3h")));
         }
 
-        supportedCodecInfos.add(new VideoCodecInfo(
-            name, MediaCodecUtils.getCodecProperties(type, /* highProfile= */ false)));
+          supportedCodecInfos.add(new VideoCodecInfo(
+              name, MediaCodecUtils.getCodecProperties(type, /* highProfile= */ false), Arrays.asList(
+                  "L1T1",
+                  "L1T2",
+                  "L1T3",
+                  "L2T1",
+                  "L2T1h",
+                  "L2T1_KEY",
+                  "L2T2",
+                  "L2T2h",
+                  "L2T2_KEY",
+                  "L2T2_KEY_SHIFT",
+                  "L2T3",
+                  "L2T3h",
+                  "L2T3_KEY",
+                  "L3T1",
+                  "L3T1h",
+                  "L3T1_KEY",
+                  "L3T2",
+                  "L3T2h",
+                  "L3T2_KEY",
+                  "L3T3",
+                  "L3T3h",
+                  "L3T3_KEY",
+                  "S2T1",
+                  "S2T1h",
+                  "S2T2",
+                  "S2T2h",
+                  "S2T3",
+                  "S2T3h",
+                  "S3T1",
+                  "S3T1h",
+                  "S3T2",
+                  "S3T2h",
+                  "S3T3",
+                  "S3T3h")));
       }
     }
 
diff --git a/src/sdk/android/api/org/webrtc/RtpParameters.java b/src/sdk/android/api/org/webrtc/RtpParameters.java
index 9ca8311..1fcffe7 100644
--- a/src/sdk/android/api/org/webrtc/RtpParameters.java
+++ b/src/sdk/android/api/org/webrtc/RtpParameters.java
@@ -73,6 +73,8 @@ public class RtpParameters {
     @Nullable public Integer maxFramerate;
     // The number of temporal layers for video.
     @Nullable public Integer numTemporalLayers;
+    // https://w3c.github.io/webrtc-svc/#rtcrtpencodingparameters
+    @Nullable public String scalabilityMode;
     // If non-null, scale the width and height down by this factor for video. If null,
     // implementation default scaling factor will be used.
     @Nullable public Double scaleResolutionDownBy;
@@ -93,7 +95,7 @@ public class RtpParameters {
     @CalledByNative("Encoding")
     Encoding(String rid, boolean active, double bitratePriority, @Priority int networkPriority,
         Integer maxBitrateBps, Integer minBitrateBps, Integer maxFramerate,
-        Integer numTemporalLayers, Double scaleResolutionDownBy, Long ssrc,
+        Integer numTemporalLayers, String scalabilityMode, Double scaleResolutionDownBy, Long ssrc,
         boolean adaptiveAudioPacketTime) {
       this.rid = rid;
       this.active = active;
@@ -103,6 +105,7 @@ public class RtpParameters {
       this.minBitrateBps = minBitrateBps;
       this.maxFramerate = maxFramerate;
       this.numTemporalLayers = numTemporalLayers;
+      this.scalabilityMode = scalabilityMode;
       this.scaleResolutionDownBy = scaleResolutionDownBy;
       this.ssrc = ssrc;
       this.adaptiveAudioPacketTime = adaptiveAudioPacketTime;
@@ -154,6 +157,12 @@ public class RtpParameters {
       return numTemporalLayers;
     }
 
+    @Nullable
+    @CalledByNative("Encoding")
+    String getScalabilityMode() {
+      return scalabilityMode;
+    }
+
     @Nullable
     @CalledByNative("Encoding")
     Double getScaleResolutionDownBy() {
diff --git a/src/sdk/android/api/org/webrtc/VideoCodecInfo.java b/src/sdk/android/api/org/webrtc/VideoCodecInfo.java
index 4f97cf7..d357ff0 100644
--- a/src/sdk/android/api/org/webrtc/VideoCodecInfo.java
+++ b/src/sdk/android/api/org/webrtc/VideoCodecInfo.java
@@ -34,20 +34,23 @@ public class VideoCodecInfo {
 
   public final String name;
   public final Map<String, String> params;
+  public final List<String> scalabilityMods;
   @Deprecated public final int payload;
 
   @CalledByNative
-  public VideoCodecInfo(String name, Map<String, String> params) {
+  public VideoCodecInfo(String name, Map<String, String> params, List<String> scalabilityMods) {
     this.payload = 0;
     this.name = name;
     this.params = params;
+    this.scalabilityMods = scalabilityMods;
   }
 
   @Deprecated
-  public VideoCodecInfo(int payload, String name, Map<String, String> params) {
+  public VideoCodecInfo(int payload, String name, Map<String, String> params, List<String> scalabilityMods) {
     this.payload = payload;
     this.name = name;
     this.params = params;
+    this.scalabilityMods = scalabilityMods;
   }
 
   @Override
@@ -83,4 +86,9 @@ public class VideoCodecInfo {
   Map getParams() {
     return params;
   }
+
+  @CalledByNative
+  List getScalabiltyMods() {
+    return scalabilityMods;
+  }
 }
diff --git a/src/sdk/android/src/java/org/webrtc/MediaCodecVideoDecoderFactory.java b/src/sdk/android/src/java/org/webrtc/MediaCodecVideoDecoderFactory.java
index 9a73bc4..043c598 100644
--- a/src/sdk/android/src/java/org/webrtc/MediaCodecVideoDecoderFactory.java
+++ b/src/sdk/android/src/java/org/webrtc/MediaCodecVideoDecoderFactory.java
@@ -19,6 +19,7 @@ import android.media.MediaCodecList;
 import android.os.Build;
 import androidx.annotation.Nullable;
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.List;
 
 /** Factory for decoders backed by Android MediaCodec API. */
@@ -72,11 +73,79 @@ class MediaCodecVideoDecoderFactory implements VideoDecoderFactory {
         String name = type.name();
         if (type == VideoCodecMimeType.H264 && isH264HighProfileSupported(codec)) {
           supportedCodecInfos.add(new VideoCodecInfo(
-              name, MediaCodecUtils.getCodecProperties(type, /* highProfile= */ true)));
+              name, MediaCodecUtils.getCodecProperties(type, /* highProfile= */ true), Arrays.asList(
+                  "L1T1",
+                  "L1T2",
+                  "L1T3",
+                  "L2T1",
+                  "L2T1h",
+                  "L2T1_KEY",
+                  "L2T2",
+                  "L2T2h",
+                  "L2T2_KEY",
+                  "L2T2_KEY_SHIFT",
+                  "L2T3",
+                  "L2T3h",
+                  "L2T3_KEY",
+                  "L3T1",
+                  "L3T1h",
+                  "L3T1_KEY",
+                  "L3T2",
+                  "L3T2h",
+                  "L3T2_KEY",
+                  "L3T3",
+                  "L3T3h",
+                  "L3T3_KEY",
+                  "S2T1",
+                  "S2T1h",
+                  "S2T2",
+                  "S2T2h",
+                  "S2T3",
+                  "S2T3h",
+                  "S3T1",
+                  "S3T1h",
+                  "S3T2",
+                  "S3T2h",
+                  "S3T3",
+                  "S3T3h")));
         }
 
-        supportedCodecInfos.add(new VideoCodecInfo(
-            name, MediaCodecUtils.getCodecProperties(type, /* highProfile= */ false)));
+          supportedCodecInfos.add(new VideoCodecInfo(
+              name, MediaCodecUtils.getCodecProperties(type, /* highProfile= */ false), Arrays.asList(
+                  "L1T1",
+                  "L1T2",
+                  "L1T3",
+                  "L2T1",
+                  "L2T1h",
+                  "L2T1_KEY",
+                  "L2T2",
+                  "L2T2h",
+                  "L2T2_KEY",
+                  "L2T2_KEY_SHIFT",
+                  "L2T3",
+                  "L2T3h",
+                  "L2T3_KEY",
+                  "L3T1",
+                  "L3T1h",
+                  "L3T1_KEY",
+                  "L3T2",
+                  "L3T2h",
+                  "L3T2_KEY",
+                  "L3T3",
+                  "L3T3h",
+                  "L3T3_KEY",
+                  "S2T1",
+                  "S2T1h",
+                  "S2T2",
+                  "S2T2h",
+                  "S2T3",
+                  "S2T3h",
+                  "S3T1",
+                  "S3T1h",
+                  "S3T2",
+                  "S3T2h",
+                  "S3T3",
+                  "S3T3h")));
       }
     }
 
diff --git a/src/sdk/android/src/jni/pc/rtp_parameters.cc b/src/sdk/android/src/jni/pc/rtp_parameters.cc
index 4bd9ee0..1f5957b 100644
--- a/src/sdk/android/src/jni/pc/rtp_parameters.cc
+++ b/src/sdk/android/src/jni/pc/rtp_parameters.cc
@@ -52,6 +52,7 @@ ScopedJavaLocalRef<jobject> NativeToJavaRtpEncodingParameter(
       NativeToJavaInteger(env, encoding.min_bitrate_bps),
       NativeToJavaInteger(env, encoding.max_framerate),
       NativeToJavaInteger(env, encoding.num_temporal_layers),
+      NativeToJavaString(env, encoding.scalability_mode),
       NativeToJavaDouble(env, encoding.scale_resolution_down_by),
       encoding.ssrc ? NativeToJavaLong(env, *encoding.ssrc) : nullptr,
       encoding.adaptive_ptime);
@@ -112,6 +113,11 @@ RtpEncodingParameters JavaToNativeRtpEncodingParameters(
       Java_Encoding_getNumTemporalLayers(jni, j_encoding_parameters);
   encoding.num_temporal_layers =
       JavaToNativeOptionalInt(jni, j_num_temporal_layers);
+  ScopedJavaLocalRef<jstring> j_scalability_mode =
+      Java_Encoding_getScalabilityMode(jni, j_encoding_parameters);
+  if (!IsNull(jni, j_scalability_mode)) {
+    encoding.scalability_mode = JavaToNativeString(jni, j_scalability_mode);
+  }
   ScopedJavaLocalRef<jobject> j_scale_resolution_down_by =
       Java_Encoding_getScaleResolutionDownBy(jni, j_encoding_parameters);
   encoding.scale_resolution_down_by =
diff --git a/src/sdk/android/src/jni/pc/rtp_sender.cc b/src/sdk/android/src/jni/pc/rtp_sender.cc
index ddb53f6..533d0e9 100644
--- a/src/sdk/android/src/jni/pc/rtp_sender.cc
+++ b/src/sdk/android/src/jni/pc/rtp_sender.cc
@@ -70,7 +70,7 @@ jlong JNI_RtpSender_GetDtmfSender(JNIEnv* jni, jlong j_rtp_sender_pointer) {
           ->GetDtmfSender()
           .release());
 }
-
+ // here
 jboolean JNI_RtpSender_SetParameters(
     JNIEnv* jni,
     jlong j_rtp_sender_pointer,
diff --git a/src/sdk/android/src/jni/video_codec_info.cc b/src/sdk/android/src/jni/video_codec_info.cc
index a218a1d..df0a844 100644
--- a/src/sdk/android/src/jni/video_codec_info.cc
+++ b/src/sdk/android/src/jni/video_codec_info.cc
@@ -13,15 +13,30 @@
 #include "sdk/android/generated_video_jni/VideoCodecInfo_jni.h"
 #include "sdk/android/native_api/jni/java_types.h"
 #include "sdk/android/src/jni/jni_helpers.h"
+#include "absl/container/inlined_vector.h"
+#include "absl/types/optional.h"
+#include "api/video_codecs/scalability_mode.h"
 
 namespace webrtc {
 namespace jni {
 
 SdpVideoFormat VideoCodecInfoToSdpVideoFormat(JNIEnv* jni,
                                               const JavaRef<jobject>& j_info) {
+  absl::InlinedVector<ScalabilityMode, kScalabilityModeCount> scalability_modes;
+  auto scalability_modes_str = JavaToStdVectorStrings(Java_VideoCodecInfo_getScalabiltyMods(jni, j_info));
+  for (size_t i = 0; i<scalability_modes_str.size(); ++i) {
+    for (size_t j = 0; j < kAllScalabilityModes.size(); ++j) {
+      if (ScalabilityModeToString(kAllScalabilityModes[j]) == scalability_modes_str[i]) {
+        scalability_modes.push(kAllScalabilityModes[j]);
+      }
+    }
+
+  }
   return SdpVideoFormat(
       JavaToNativeString(jni, Java_VideoCodecInfo_getName(jni, j_info)),
-      JavaToNativeStringMap(jni, Java_VideoCodecInfo_getParams(jni, j_info)));
+      JavaToNativeStringMap(jni, Java_VideoCodecInfo_getParams(jni, j_info)),
+      scalability_modes
+      );
 }
 
 ScopedJavaLocalRef<jobject> SdpVideoFormatToVideoCodecInfo(
@@ -29,8 +44,12 @@ ScopedJavaLocalRef<jobject> SdpVideoFormatToVideoCodecInfo(
     const SdpVideoFormat& format) {
   ScopedJavaLocalRef<jobject> j_params =
       NativeToJavaStringMap(jni, format.parameters);
+  ScopedJavaLocalRef<jobject> j_scala = NativeToJavaList(
+      jni, format.scalability_modes, [](JNIEnv* jni, ScalabilityMode mode) {
+        NativeToJavaString(jni, ScalabilityModeToString(mode))
+      });
   return Java_VideoCodecInfo_Constructor(
-      jni, NativeToJavaString(jni, format.name), j_params);
+      jni, NativeToJavaString(jni, format.name), j_params, j_scala);
 }
 
 }  // namespace jni
diff --git a/src/sdk/android/src/jni/video_encoder_factory_wrapper.cc b/src/sdk/android/src/jni/video_encoder_factory_wrapper.cc
index 7df129b..67b2931 100644
--- a/src/sdk/android/src/jni/video_encoder_factory_wrapper.cc
+++ b/src/sdk/android/src/jni/video_encoder_factory_wrapper.cc
@@ -77,6 +77,7 @@ class VideoEncoderSelectorWrapper
 
 }  // namespace
 
+ // here!!
 VideoEncoderFactoryWrapper::VideoEncoderFactoryWrapper(
     JNIEnv* jni,
     const JavaRef<jobject>& encoder_factory)
diff --git a/src/sdk/objc/api/peerconnection/RTCPeerConnectionFactory.h b/src/sdk/objc/api/peerconnection/RTCPeerConnectionFactory.h
index 5575af9..f8dfae1 100644
--- a/src/sdk/objc/api/peerconnection/RTCPeerConnectionFactory.h
+++ b/src/sdk/objc/api/peerconnection/RTCPeerConnectionFactory.h
@@ -23,6 +23,10 @@ NS_ASSUME_NONNULL_BEGIN
 @class RTC_OBJC_TYPE(RTCVideoSource);
 @class RTC_OBJC_TYPE(RTCVideoTrack);
 @class RTC_OBJC_TYPE(RTCPeerConnectionFactoryOptions);
+@class RTC_OBJC_TYPE(RTCRtpCapabilities);
+
+typedef NS_ENUM(NSInteger, RTCRtpMediaType);
+
 @protocol RTC_OBJC_TYPE
 (RTCPeerConnectionDelegate);
 @protocol RTC_OBJC_TYPE
@@ -51,6 +55,10 @@ RTC_OBJC_EXPORT
             decoderFactory:(nullable id<RTC_OBJC_TYPE(RTCVideoDecoderFactory)>)decoderFactory
                audioDevice:(nullable id<RTC_OBJC_TYPE(RTCAudioDevice)>)audioDevice;
 
+- (RTC_OBJC_TYPE(RTCRtpCapabilities) *)rtpSenderCapabilitiesFor:(RTCRtpMediaType)mediaType;
+
+- (RTC_OBJC_TYPE(RTCRtpCapabilities) *)rtpReceiverCapabilitiesFor:(RTCRtpMediaType)mediaType;
+
 /** Initialize an RTCAudioSource with constraints. */
 - (RTC_OBJC_TYPE(RTCAudioSource) *)audioSourceWithConstraints:
     (nullable RTC_OBJC_TYPE(RTCMediaConstraints) *)constraints;
diff --git a/src/sdk/objc/api/peerconnection/RTCPeerConnectionFactory.mm b/src/sdk/objc/api/peerconnection/RTCPeerConnectionFactory.mm
index 62b5554..e63104d 100644
--- a/src/sdk/objc/api/peerconnection/RTCPeerConnectionFactory.mm
+++ b/src/sdk/objc/api/peerconnection/RTCPeerConnectionFactory.mm
@@ -21,6 +21,9 @@
 #import "RTCPeerConnection+Private.h"
 #import "RTCVideoSource+Private.h"
 #import "RTCVideoTrack+Private.h"
+#import "RTCRtpReceiver+Private.h"
+#import "RTCRtpCapabilities+Private.h"
+#import "RTCRtpCodecCapability+Private.h"
 #import "base/RTCLogging.h"
 #import "base/RTCVideoDecoderFactory.h"
 #import "base/RTCVideoEncoderFactory.h"
@@ -116,6 +119,20 @@
 #endif
 }
 
+- (RTC_OBJC_TYPE(RTCRtpCapabilities) *)rtpSenderCapabilitiesFor:(RTCRtpMediaType)mediaType {
+
+  webrtc::RtpCapabilities capabilities = _nativeFactory->GetRtpSenderCapabilities([RTCRtpReceiver nativeMediaTypeForMediaType: mediaType]);
+
+  return [[RTCRtpCapabilities alloc] initWithNativeCapabilities: capabilities];
+}
+
+- (RTC_OBJC_TYPE(RTCRtpCapabilities) *)rtpReceiverCapabilitiesFor:(RTCRtpMediaType)mediaType {
+
+  webrtc::RtpCapabilities capabilities = _nativeFactory->GetRtpReceiverCapabilities([RTCRtpReceiver nativeMediaTypeForMediaType: mediaType]);
+
+  return [[RTCRtpCapabilities alloc] initWithNativeCapabilities: capabilities];
+}
+
 - (instancetype)initNative {
   if (self = [super init]) {
     _networkThread = rtc::Thread::CreateWithSocketServer();
diff --git a/src/sdk/objc/api/peerconnection/RTCRtpCapabilities+Private.h b/src/sdk/objc/api/peerconnection/RTCRtpCapabilities+Private.h
new file mode 100644
index 0000000..15c8fe3
--- /dev/null
+++ b/src/sdk/objc/api/peerconnection/RTCRtpCapabilities+Private.h
@@ -0,0 +1,33 @@
+/*
+ * Copyright 2023 LiveKit
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#import "RTCRtpCapabilities.h"
+
+#include "api/rtp_parameters.h"
+
+NS_ASSUME_NONNULL_BEGIN
+
+@interface RTC_OBJC_TYPE (RTCRtpCapabilities)
+()
+
+    @property(nonatomic, readonly) webrtc::RtpCapabilities nativeCapabilities;
+
+- (instancetype)initWithNativeCapabilities:(const webrtc::RtpCapabilities &)nativeCapabilities
+    NS_DESIGNATED_INITIALIZER;
+
+@end
+
+NS_ASSUME_NONNULL_END
\ No newline at end of file
diff --git a/src/sdk/objc/api/peerconnection/RTCRtpCapabilities.h b/src/sdk/objc/api/peerconnection/RTCRtpCapabilities.h
new file mode 100644
index 0000000..2dea41a
--- /dev/null
+++ b/src/sdk/objc/api/peerconnection/RTCRtpCapabilities.h
@@ -0,0 +1,37 @@
+/*
+ * Copyright 2023 LiveKit
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#import <Foundation/Foundation.h>
+
+#import "RTCMacros.h"
+
+@class RTC_OBJC_TYPE(RTCRtpCodecCapability);
+@class RTC_OBJC_TYPE(RTCRtpHeaderExtensionCapability);
+
+NS_ASSUME_NONNULL_BEGIN
+
+RTC_OBJC_EXPORT
+@interface RTC_OBJC_TYPE (RTCRtpCapabilities) : NSObject
+
+- (instancetype)init NS_UNAVAILABLE;
+
+@property(nonatomic, readonly) NSArray<RTC_OBJC_TYPE(RTCRtpCodecCapability) *> *codecs;
+
+@property(nonatomic, readonly) NSArray<RTC_OBJC_TYPE(RTCRtpHeaderExtensionCapability) *> *header_extensions;
+
+@end
+
+NS_ASSUME_NONNULL_END
\ No newline at end of file
diff --git a/src/sdk/objc/api/peerconnection/RTCRtpCapabilities.mm b/src/sdk/objc/api/peerconnection/RTCRtpCapabilities.mm
new file mode 100644
index 0000000..7f73108
--- /dev/null
+++ b/src/sdk/objc/api/peerconnection/RTCRtpCapabilities.mm
@@ -0,0 +1,63 @@
+/*
+ * Copyright 2023 LiveKit
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#import "RTCRtpCapabilities+Private.h"
+#import "RTCRtpCodecCapability+Private.h"
+#import "RTCRtpHeaderExtensionCapability+Private.h"
+
+#import "RTCMediaStreamTrack.h"
+#import "helpers/NSString+StdString.h"
+
+#include "media/base/media_constants.h"
+#include "rtc_base/checks.h"
+
+@implementation RTC_OBJC_TYPE (RTCRtpCapabilities)
+
+@synthesize nativeCapabilities = _nativeCapabilities;
+
+- (instancetype)initWithNativeCapabilities:(const webrtc::RtpCapabilities &)nativeCapabilities {
+  if (self = [super init]) {
+    _nativeCapabilities = nativeCapabilities;
+  }
+
+  return self;
+}
+
+- (NSArray<RTC_OBJC_TYPE(RTCRtpCodecCapability) *> *)codecs {
+  NSMutableArray *result = [NSMutableArray array];
+
+  for (auto &element : _nativeCapabilities.codecs) {
+    RTCRtpCodecCapability *object =
+        [[RTCRtpCodecCapability alloc] initWithNativeCodecCapability:element];
+    [result addObject:object];
+  }
+
+  return result;
+}
+
+- (NSArray<RTC_OBJC_TYPE(RTCRtpHeaderExtensionCapability) *> *)header_extensions {
+  NSMutableArray *result = [NSMutableArray array];
+
+  for (auto &element : _nativeCapabilities.header_extensions) {
+    RTCRtpHeaderExtensionCapability *object =
+        [[RTCRtpHeaderExtensionCapability alloc] initWithNativeHeaderExtensionCapability:element];
+    [result addObject:object];
+  }
+
+  return result;
+}
+
+@end
\ No newline at end of file
diff --git a/src/sdk/objc/api/peerconnection/RTCRtpCodecCapability+Private.h b/src/sdk/objc/api/peerconnection/RTCRtpCodecCapability+Private.h
new file mode 100644
index 0000000..b36d26c
--- /dev/null
+++ b/src/sdk/objc/api/peerconnection/RTCRtpCodecCapability+Private.h
@@ -0,0 +1,33 @@
+/*
+ * Copyright 2023 LiveKit
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#import "RTCRtpCodecCapability.h"
+
+#include "api/rtp_parameters.h"
+
+NS_ASSUME_NONNULL_BEGIN
+
+@interface RTC_OBJC_TYPE (RTCRtpCodecCapability)
+()
+
+    @property(nonatomic, readonly) webrtc::RtpCodecCapability nativeCodecCapability;
+
+- (instancetype)initWithNativeCodecCapability:
+    (const webrtc::RtpCodecCapability &)nativeCodecCapability NS_DESIGNATED_INITIALIZER;
+
+@end
+
+NS_ASSUME_NONNULL_END
\ No newline at end of file
diff --git a/src/sdk/objc/api/peerconnection/RTCRtpCodecCapability.h b/src/sdk/objc/api/peerconnection/RTCRtpCodecCapability.h
new file mode 100644
index 0000000..0daf40e
--- /dev/null
+++ b/src/sdk/objc/api/peerconnection/RTCRtpCodecCapability.h
@@ -0,0 +1,63 @@
+/*
+ * Copyright 2023 LiveKit
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#import <Foundation/Foundation.h>
+
+#import "RTCMacros.h"
+
+typedef NS_ENUM(NSInteger, RTCRtpMediaType);
+
+NS_ASSUME_NONNULL_BEGIN
+
+RTC_OBJC_EXPORT
+@interface RTC_OBJC_TYPE (RTCRtpCodecCapability) : NSObject
+
+// Build MIME "type/subtype" string from `name` and `kind`.
+@property(nonatomic, readonly) NSString *mimeType;
+
+// Used to identify the codec. Equivalent to MIME subtype.
+@property(nonatomic, copy) NSString *name;
+
+// The media type of this codec. Equivalent to MIME top-level type.
+@property(nonatomic, assign) RTCRtpMediaType kind;
+
+// Clock rate in Hertz. If unset, the codec is applicable to any clock rate.
+@property(nonatomic, copy, nullable) NSNumber *clockRate;
+
+// Default payload type for this codec. Mainly needed for codecs that use
+// that have statically assigned payload types.
+@property(nonatomic, copy, nullable) NSNumber *preferredPayloadType;
+
+// The number of audio channels supported. Unused for video codecs.
+@property(nonatomic, copy, nullable) NSNumber *numChannels;
+
+// Codec-specific parameters that must be signaled to the remote party.
+//
+// Corresponds to "a=fmtp" parameters in SDP.
+//
+// Contrary to ORTC, these parameters are named using all lowercase strings.
+// This helps make the mapping to SDP simpler, if an application is using SDP.
+// Boolean values are represented by the string "1".
+// std::map<std::string, std::string> parameters;
+@property(nonatomic, copy) NSDictionary<NSString *, NSString *> *parameters;
+
+// Feedback mechanisms supported for this codec.
+// std::vector<RtcpFeedback> rtcp_feedback;
+// Not implemented.
+
+@end
+
+NS_ASSUME_NONNULL_END
\ No newline at end of file
diff --git a/src/sdk/objc/api/peerconnection/RTCRtpCodecCapability.mm b/src/sdk/objc/api/peerconnection/RTCRtpCodecCapability.mm
new file mode 100644
index 0000000..341cde4
--- /dev/null
+++ b/src/sdk/objc/api/peerconnection/RTCRtpCodecCapability.mm
@@ -0,0 +1,138 @@
+/*
+ * Copyright 2023 LiveKit
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#import "RTCRtpCodecCapability+Private.h"
+
+#import "RTCRtpReceiver+Private.h"
+
+#import "RTCMediaStreamTrack.h"
+#import "helpers/NSString+StdString.h"
+
+#include "media/base/media_constants.h"
+#include "rtc_base/checks.h"
+
+@implementation RTC_OBJC_TYPE (RTCRtpCodecCapability)
+
+@synthesize nativeCodecCapability = _nativeCodecCapability;
+
+- (instancetype)init {
+  return [self initWithNativeCodecCapability:webrtc::RtpCodecCapability()];
+}
+
+- (instancetype)initWithNativeCodecCapability:
+    (const webrtc::RtpCodecCapability &)nativeCodecCapability {
+  if (self = [super init]) {
+    _nativeCodecCapability = nativeCodecCapability;
+  }
+
+  return self;
+}
+
+- (NSString *)mimeType {
+  return [NSString stringWithUTF8String:_nativeCodecCapability.mime_type().c_str()];
+}
+
+- (NSString *)name {
+  return [NSString stringWithUTF8String:_nativeCodecCapability.name.c_str()];
+}
+
+- (void)setName:(NSString *)name {
+  _nativeCodecCapability.name = std::string([name UTF8String]);
+}
+
+- (RTCRtpMediaType)kind {
+  return [RTCRtpReceiver mediaTypeForNativeMediaType:_nativeCodecCapability.kind];
+}
+
+- (void)setKind:(RTCRtpMediaType)kind {
+  _nativeCodecCapability.kind = [RTCRtpReceiver nativeMediaTypeForMediaType:kind];
+}
+
+- (NSNumber *)clockRate {
+  if (!_nativeCodecCapability.clock_rate) {
+    return nil;
+  }
+
+  return [NSNumber numberWithInt:*_nativeCodecCapability.clock_rate];
+}
+
+- (void)setClockRate:(NSNumber *)clockRate {
+  if (clockRate == nil) {
+    _nativeCodecCapability.clock_rate = absl::optional<int>();
+    return;
+  }
+
+  _nativeCodecCapability.clock_rate = absl::optional<int>(clockRate.intValue);
+}
+
+- (NSNumber *)preferredPayloadType {
+  if (!_nativeCodecCapability.preferred_payload_type) {
+    return nil;
+  }
+
+  return [NSNumber numberWithInt:*_nativeCodecCapability.preferred_payload_type];
+}
+
+- (void)setPreferredPayloadType:(NSNumber *)preferredPayloadType {
+  if (preferredPayloadType == nil) {
+    _nativeCodecCapability.preferred_payload_type = absl::optional<int>();
+    return;
+  }
+
+  _nativeCodecCapability.preferred_payload_type =
+      absl::optional<int>(preferredPayloadType.intValue);
+}
+
+- (NSNumber *)numChannels {
+  if (!_nativeCodecCapability.num_channels) {
+    return nil;
+  }
+
+  return [NSNumber numberWithInt:*_nativeCodecCapability.num_channels];
+}
+
+- (void)setNumChannels:(NSNumber *)numChannels {
+  if (numChannels == nil) {
+    _nativeCodecCapability.num_channels = absl::optional<int>();
+    return;
+  }
+
+  _nativeCodecCapability.num_channels = absl::optional<int>(numChannels.intValue);
+}
+
+- (NSDictionary<NSString *, NSString *> *)parameters {
+  NSMutableDictionary *result = [NSMutableDictionary dictionary];
+  auto _parameters = _nativeCodecCapability.parameters;
+  for (auto it = _parameters.begin(); it != _parameters.end(); ++it) {
+    [result setObject:[NSString stringForStdString:it->second]
+               forKey:[NSString stringForStdString:it->first]];
+  }
+
+  return result;
+}
+
+- (void)setParameters:(NSDictionary<NSString *, NSString *> *)parameters {
+  std::map<std::string, std::string> _parameters;
+  for (NSString *paramKey in parameters.allKeys) {
+    std::string key = [NSString stdStringForString:paramKey];
+    std::string value = [NSString stdStringForString:parameters[paramKey]];
+    _parameters[key] = value;
+  }
+
+  _nativeCodecCapability.parameters = _parameters;
+}
+
+@end
\ No newline at end of file
diff --git a/src/sdk/objc/api/peerconnection/RTCRtpEncodingParameters.h b/src/sdk/objc/api/peerconnection/RTCRtpEncodingParameters.h
index 07f6b7a..d055115 100644
--- a/src/sdk/objc/api/peerconnection/RTCRtpEncodingParameters.h
+++ b/src/sdk/objc/api/peerconnection/RTCRtpEncodingParameters.h
@@ -51,6 +51,10 @@ RTC_OBJC_EXPORT
  */
 @property(nonatomic, copy, nullable) NSNumber *numTemporalLayers;
 
+/** A case-sensitive identifier of the scalability mode to be used for this stream.
+  https://w3c.github.io/webrtc-svc/#rtcrtpencodingparameters */
+@property(nonatomic, copy, nullable) NSString *scalabilityMode;
+
 /** Scale the width and height down by this factor for video. If nil,
  * implementation default scaling factor will be used.
  */
diff --git a/src/sdk/objc/api/peerconnection/RTCRtpEncodingParameters.mm b/src/sdk/objc/api/peerconnection/RTCRtpEncodingParameters.mm
index d6087da..e2020bb 100644
--- a/src/sdk/objc/api/peerconnection/RTCRtpEncodingParameters.mm
+++ b/src/sdk/objc/api/peerconnection/RTCRtpEncodingParameters.mm
@@ -20,6 +20,7 @@
 @synthesize minBitrateBps = _minBitrateBps;
 @synthesize maxFramerate = _maxFramerate;
 @synthesize numTemporalLayers = _numTemporalLayers;
+@synthesize scalabilityMode = _scalabilityMode;
 @synthesize scaleResolutionDownBy = _scaleResolutionDownBy;
 @synthesize ssrc = _ssrc;
 @synthesize bitratePriority = _bitratePriority;
@@ -52,6 +53,9 @@
     if (nativeParameters.num_temporal_layers) {
       _numTemporalLayers = [NSNumber numberWithInt:*nativeParameters.num_temporal_layers];
     }
+    if (nativeParameters.scalability_mode) {
+      _scalabilityMode = [NSString stringWithUTF8String:nativeParameters.scalability_mode->c_str()];
+    }
     if (nativeParameters.scale_resolution_down_by) {
       _scaleResolutionDownBy =
           [NSNumber numberWithDouble:*nativeParameters.scale_resolution_down_by];
@@ -85,6 +89,9 @@
   if (_numTemporalLayers != nil) {
     parameters.num_temporal_layers = absl::optional<int>(_numTemporalLayers.intValue);
   }
+  if (_scalabilityMode != nil) {
+    parameters.scalability_mode = absl::optional<std::string>(std::string([_scalabilityMode UTF8String]));
+  }
   if (_scaleResolutionDownBy != nil) {
     parameters.scale_resolution_down_by =
         absl::optional<double>(_scaleResolutionDownBy.doubleValue);
diff --git a/src/sdk/objc/api/peerconnection/RTCRtpHeaderExtensionCapability+Private.h b/src/sdk/objc/api/peerconnection/RTCRtpHeaderExtensionCapability+Private.h
new file mode 100644
index 0000000..2fa8c25
--- /dev/null
+++ b/src/sdk/objc/api/peerconnection/RTCRtpHeaderExtensionCapability+Private.h
@@ -0,0 +1,33 @@
+/*
+ * Copyright 2023 LiveKit
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#import "RTCRtpHeaderExtensionCapability.h"
+
+#include "api/rtp_parameters.h"
+
+NS_ASSUME_NONNULL_BEGIN
+
+@interface RTC_OBJC_TYPE (RTCRtpHeaderExtensionCapability)
+()
+
+    @property(nonatomic, readonly) webrtc::RtpHeaderExtensionCapability nativeHeaderExtensionCapability;
+
+- (instancetype)initWithNativeHeaderExtensionCapability:
+    (const webrtc::RtpHeaderExtensionCapability &)nativeHeaderExtensionCapability NS_DESIGNATED_INITIALIZER;
+
+@end
+
+NS_ASSUME_NONNULL_END
\ No newline at end of file
diff --git a/src/sdk/objc/api/peerconnection/RTCRtpHeaderExtensionCapability.h b/src/sdk/objc/api/peerconnection/RTCRtpHeaderExtensionCapability.h
new file mode 100644
index 0000000..27bb0e5
--- /dev/null
+++ b/src/sdk/objc/api/peerconnection/RTCRtpHeaderExtensionCapability.h
@@ -0,0 +1,37 @@
+/*
+ * Copyright 2023 LiveKit
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#import <Foundation/Foundation.h>
+
+#import "RTCMacros.h"
+
+NS_ASSUME_NONNULL_BEGIN
+
+RTC_OBJC_EXPORT
+@interface RTC_OBJC_TYPE (RTCRtpHeaderExtensionCapability) : NSObject
+
+// URI of this extension, as defined in RFC8285.
+@property(nonatomic, readonly) NSString *uri;
+
+// Preferred value of ID that goes in the packet.
+@property(nonatomic, assign) NSNumber *preferred_id;
+
+// If true, it's preferred that the value in the header is encrypted.
+@property(nonatomic, assign) BOOL preferred_encrypt;
+
+@end
+
+NS_ASSUME_NONNULL_END
\ No newline at end of file
diff --git a/src/sdk/objc/api/peerconnection/RTCRtpHeaderExtensionCapability.mm b/src/sdk/objc/api/peerconnection/RTCRtpHeaderExtensionCapability.mm
new file mode 100644
index 0000000..e36d2b4
--- /dev/null
+++ b/src/sdk/objc/api/peerconnection/RTCRtpHeaderExtensionCapability.mm
@@ -0,0 +1,54 @@
+/*
+ * Copyright 2023 LiveKit
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#import "RTCRtpHeaderExtensionCapability+Private.h"
+
+#import "helpers/NSString+StdString.h"
+
+#include "media/base/media_constants.h"
+#include "rtc_base/checks.h"
+
+@implementation RTC_OBJC_TYPE (RTCRtpHeaderExtensionCapability)
+
+@synthesize nativeHeaderExtensionCapability = _nativeHeaderExtensionCapability;
+
+- (instancetype)init {
+  return [self initWithNativeHeaderExtensionCapability:webrtc::RtpHeaderExtensionCapability()];
+}
+
+- (instancetype)initWithNativeHeaderExtensionCapability:
+    (const webrtc::RtpHeaderExtensionCapability &)nativeHeaderExtensionCapability {
+  if (self = [super init]) {
+    _nativeHeaderExtensionCapability = nativeHeaderExtensionCapability;
+  }
+
+  return self;
+}
+
+- (NSString *)uri {
+  return [NSString stringWithUTF8String:_nativeHeaderExtensionCapability.uri.c_str()];
+}
+
+- (NSNumber *)preferredId {
+  return [NSNumber numberWithInt:*_nativeHeaderExtensionCapability.preferred_id];
+
+}
+
+- (BOOL)preferredEncrypt {
+  return _nativeHeaderExtensionCapability.preferred_encrypt;
+}
+
+@end
\ No newline at end of file
